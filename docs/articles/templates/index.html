<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Templates | zeroy&#39;s blog</title>
<meta name="keywords" content="" />
<meta name="description" content="@zeroy.site
 读入输出挂 inline int read(){ char c=getchar(); int num=0,fl=1; while(c&lt;48 || c&gt;57){if(c==&#39;-&#39;)fl=-1;c=getchar();} while(c&gt;=48 &amp;&amp; c&lt;=57){num=(num&lt;&lt;1)&#43;(num&lt;&lt;3)&#43;(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x&lt;0){ putchar(&#39;-&#39;); x=-x; } if(x&gt;9)write(x/10); putchar(x%10&#43;&#39;0&#39;); } 正向表 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[&#43;&#43;tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } 基础数据结构 树状数组 void Add(int x,int d){ while(x&lt;=n){ C[x]&#43;=d; x&#43;=(x&amp;-x); } } int Sum(int x){ int res=0; while(x){ res&#43;=C[x]; x-=(x&amp;-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表 预处理">
<meta name="author" content="zeroy">
<link rel="canonical" href="https://zeroy.site/articles/templates/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zeroy.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zeroy.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zeroy.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zeroy.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://zeroy.site/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.92.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Templates" />
<meta property="og:description" content="@zeroy.site
 读入输出挂 inline int read(){ char c=getchar(); int num=0,fl=1; while(c&lt;48 || c&gt;57){if(c==&#39;-&#39;)fl=-1;c=getchar();} while(c&gt;=48 &amp;&amp; c&lt;=57){num=(num&lt;&lt;1)&#43;(num&lt;&lt;3)&#43;(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x&lt;0){ putchar(&#39;-&#39;); x=-x; } if(x&gt;9)write(x/10); putchar(x%10&#43;&#39;0&#39;); } 正向表 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[&#43;&#43;tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } 基础数据结构 树状数组 void Add(int x,int d){ while(x&lt;=n){ C[x]&#43;=d; x&#43;=(x&amp;-x); } } int Sum(int x){ int res=0; while(x){ res&#43;=C[x]; x-=(x&amp;-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表 预处理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zeroy.site/articles/templates/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2022-05-20T22:40:09&#43;08:00" />
<meta property="article:modified_time" content="2022-05-20T22:40:09&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Templates"/>
<meta name="twitter:description" content="@zeroy.site
 读入输出挂 inline int read(){ char c=getchar(); int num=0,fl=1; while(c&lt;48 || c&gt;57){if(c==&#39;-&#39;)fl=-1;c=getchar();} while(c&gt;=48 &amp;&amp; c&lt;=57){num=(num&lt;&lt;1)&#43;(num&lt;&lt;3)&#43;(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x&lt;0){ putchar(&#39;-&#39;); x=-x; } if(x&gt;9)write(x/10); putchar(x%10&#43;&#39;0&#39;); } 正向表 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[&#43;&#43;tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } 基础数据结构 树状数组 void Add(int x,int d){ while(x&lt;=n){ C[x]&#43;=d; x&#43;=(x&amp;-x); } } int Sum(int x){ int res=0; while(x){ res&#43;=C[x]; x-=(x&amp;-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表 预处理"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Articles",
      "item": "https://zeroy.site/articles/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Templates",
      "item": "https://zeroy.site/articles/templates/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Templates",
  "name": "Templates",
  "description": "@zeroy.site\n 读入输出挂 inline int read(){ char c=getchar(); int num=0,fl=1; while(c\u0026lt;48 || c\u0026gt;57){if(c==\u0026#39;-\u0026#39;)fl=-1;c=getchar();} while(c\u0026gt;=48 \u0026amp;\u0026amp; c\u0026lt;=57){num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x\u0026lt;0){ putchar(\u0026#39;-\u0026#39;); x=-x; } if(x\u0026gt;9)write(x/10); putchar(x%10+\u0026#39;0\u0026#39;); } 正向表 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[++tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } 基础数据结构 树状数组 void Add(int x,int d){ while(x\u0026lt;=n){ C[x]+=d; x+=(x\u0026amp;-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026amp;-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表 预处理",
  "keywords": [
    
  ],
  "articleBody": " @zeroy.site\n 读入输出挂 inline int read(){ char c=getchar(); int num=0,fl=1; while(c48 || c57){if(c=='-')fl=-1;c=getchar();} while(c=48 \u0026\u0026 c57){num=(num1)+(num3)+(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x0){ putchar('-'); x=-x; } if(x9)write(x/10); putchar(x%10+'0'); } 正向表 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[++tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } 基础数据结构 树状数组 void Add(int x,int d){ while(xn){ C[x]+=d; x+=(x\u0026-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表 预处理\nvoid Init_RMQ(int n){ for(int i=1;in;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;in;i++)lg2[i]=lg2[i1]+1; for(int j=1;(1j)n;j++) for(int i=1;i+(1j)-1n;i++) f[i][j]=max(f[i][j-1],f[i+(1(j-1))][j-1]); } 查询\nint query(int l,int r){ int k=lg2[r-l+1]; return max(f[l][k],f[r-(1k)+1][k]); } //预处理复杂度为O(nlogn),单次查询复杂度为O(1) 线段树 struct Segment_tree{ #define fa tree[p] \t#define lson tree[p\t#define rson tree[p\tstruct node{ int l,r; LL add;//懒标记  LL sum; int len(){return r-l+1;} }tree[M2]; void up(int p){ fa.sum=lson.sum+rson.sum;\t} void down(int p){ if(fa.add==0)return; lson.add+=fa.add; lson.sum+=fa.add*lson.len(); rson.add+=fa.add; rson.sum+=fa.add*rson.len(); fa.add=0; } void build(int l,int r,int p){ fa.l=l;fa.r=r;fa.sum=fa.add=0; if(l==r){fa.sum=A[l];return;} int mid=(l+r)1; build(l,mid,p1); build(mid+1,r,p1|1); up(p); } void update(int l,int r,LL d,int p){ if(fa.l==l\u0026\u0026fa.r==r){ fa.sum+=1LL*fa.len()*d; fa.add+=d; return; } int mid=(fa.l+fa.r)1; down(p); if(rmid)update(l,r,d,p1); else if(lmid)update(l,r,d,p1|1); else { update(l,mid,d,p1); update(mid+1,r,d,p1|1);\t} up(p); } LL query(int l,int r,int p){ if(fa.l==l\u0026\u0026fa.r==r)return fa.sum; down(p); int mid=(fa.l+fa.r)1; if(rmid)return query(l,r,p1); else if(lmid)return query(l,r,p1|1); return query(l,mid,p1)+query(mid+1,r,p1|1); } }T; //区间加减，区间查询和，单次操作复杂度均为O(logn) //可实现的变种：区间乘积，区间染色问题等等。 并查集 int getfa(int x){ return fa[x]==x?x:fa[x]=getfa(fa[x]); } //初始状态下所有fa[x]=x void Union(int x,int y){//两个集合合并  fa[getfa(x)]=getfa(y); } 树上算法 LCA 跳重链\nvoid dfs(int x,int f,int d){ dep[x]=d; sz[x]=1; fa[x]=f;son[x]=0; for(int i=0;iG[x].size();i++){ int u=G[x][i]; if(u==f)continue; dfs(u,x,d+1); if(sz[u]sz[son[x]])son[x]=u; sz[x]+=sz[u]; } } void dfs_top(int x,int tp){ top[x]=tp; if(son[x])dfs_top(son[x],tp); for(int i=0;iG[x].size();i++){ int u=G[x][i]; if(u==fa[x]||u==son[x])continue; dfs_top(u,u); } } int LCA(int a,int b){ while(top[a]!=top[b]){ if(dep[top[a]]dep[top[b]])a=fa[top[a]]; else b=fa[top[b]]; } return dep[a]dep[b]?b:a; } 倍增\nvoid dfs(int x,int f,int d){ dep[x]=d; fa[x][0]=f; for(int i=0;iG[x].size();i++){ int u=G[x][i]; if(u==f)continue; dfs(u,x,d+1); } } int LCA(int a,int b){ if(dep[a]dep[b])swap(a,b); int step=dep[b]-dep[a]; for(int i=19;i=0;i--) if(step\u00261i)b=fa[b][i]; if(a==b)return a; for(int i=19;i=0;i--) if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i]; return fa[a][0]; } for(int j=1;j19;j++) for(int i=1;in;i++) fa[i][j]=fa[fa[i][j-1]][j-1]; 树链剖分 寻找重儿子\nvoid dfs(int x,int f,int d){ dep[x]=d;fa[x]=f;sz[x]=1;son[x]=0; for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==f)continue; dfs(u,x,d+1); if(sz[u]sz[son[x]])son[x]=u; sz[x]+=sz[u]; } } 处理top\nvoid dfs_top(int x,int tp){ top[x]=tp;ID[x]=++tt;ln[tt]=x; if(son[x])dfs_top(son[x],tp); for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==son[x]||u==fa[x])continue; dfs_top(u,u); } } query\nwhile(top[u]!=top[v]){ if(dep[top[u]]dep[top[v]]){ query(ID[top[u]],ID[u],1); u=fa[top[u]]; } else { query(ID[top[v]],ID[v],1); v=fa[top[v]]; } } if(dep[u]dep[v])query(ID[v],ID[u],1); else query(ID[u],ID[v],1); 数学 扩展欧几里得算法 void exgcd(ll a,ll b,ll \u0026d,ll \u0026x,ll \u0026y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u00261)res=res*a%mod; a=a*a%mod; b=1; } return res; } //注意不要爆int或者long long 线性筛逆元 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;in;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;in;i++)//线性筛逆元 \trev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026res) const{ return (Complex){x+res.x,y+res.y};\t} Complex operator - (const Complex \u0026res) const{ return (Complex){x-res.x,y-res.y};\t} Complex operator * (const Complex \u0026res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x};\t} }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n1],R[n1]; for(int i=0;in;i+=2)L[i1]=y[i],R[i1]=y[i+1]; FFT(L,n1,f);FFT(R,n1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i(n1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //...  int nn=n,mm=n; mm+=nn; for(nn=1;nnmm;nn1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;inn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } 字符串算法 KMP 给出两个字符串S1和S2，若S1的区间[l,r]与S2完全相同，则称S2在S1中出现了，其出现位置为l。\n现在请你求出S2在S1中所有出现的位置。\n定义一个字符串S的border为S的一个非S本身的子串t，满足t既是S的前缀，又是S的后缀。\n对于S2，你还需要求出对于每个前缀S’的最长border t‘的长度。\n#include#define M 1000005 using namespace std; char s1[M],s2[M]; int f[M]; void getf(char *s,int l){ f[0]=f[1]=0; for(int i=1;il;i++){ int j=f[i]; while(j\u0026\u0026s[i]!=s[j])j=f[j]; if(s[i]==s[j])j++; f[i+1]=j; } } int main(){ scanf(\"%s%s\",s1,s2); int l1=strlen(s1); int l2=strlen(s2); getf(s2,l2); for(int i=0,j=0;il1;i++){ while(j\u0026\u0026s2[j]!=s1[i])j=f[j]; if(s2[j]==s1[i])j++; if(j==l2) printf(\"%d\\n\",i-l2+2); } for(int i=1;il2;i++) printf(\"%d \",f[i]); return 0; } ",
  "wordCount" : "532",
  "inLanguage": "zh-cn",
  "datePublished": "2022-05-20T22:40:09+08:00",
  "dateModified": "2022-05-20T22:40:09+08:00",
  "author":{
    "@type": "Person",
    "name": "zeroy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zeroy.site/articles/templates/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zeroy's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zeroy.site/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zeroy.site/" accesskey="h" title="zeroy&#39;s blog (Alt + H)">zeroy&#39;s blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zeroy.site/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://zeroy.site/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://zeroy.site/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://zeroy.site/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://zeroy.site/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zeroy.site/links/" title="友链">
                    <span>友链</span>
                </a>
            </li>
        </ul>
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=80 src="//music.163.com/outchain/player?type=2&id=415904308&auto=1&height=66"></iframe>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zeroy.site/">Home</a>&nbsp;»&nbsp;<a href="https://zeroy.site/articles/">Articles</a></div>
    <h1 class="post-title">
      Templates
    </h1>
    <div class="post-meta"><span title='2022-05-20 22:40:09 +0800 CST'>May 20, 2022</span>&nbsp;·&nbsp;zeroy

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%af%bb%e5%85%a5%e8%be%93%e5%87%ba%e6%8c%82" aria-label="读入输出挂">读入输出挂</a></li>
                <li>
                    <a href="#%e6%ad%a3%e5%90%91%e8%a1%a8" aria-label="正向表">正向表</a></li>
                <li>
                    <a href="#%e5%9f%ba%e7%a1%80%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="基础数据结构">基础数据结构</a><ul>
                        
                <li>
                    <a href="#%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84" aria-label="树状数组">树状数组</a></li>
                <li>
                    <a href="#st%e8%a1%a8" aria-label="ST表">ST表</a></li>
                <li>
                    <a href="#%e7%ba%bf%e6%ae%b5%e6%a0%91" aria-label="线段树">线段树</a></li>
                <li>
                    <a href="#%e5%b9%b6%e6%9f%a5%e9%9b%86" aria-label="并查集">并查集</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a0%91%e4%b8%8a%e7%ae%97%e6%b3%95" aria-label="树上算法">树上算法</a><ul>
                        
                <li>
                    <a href="#lca" aria-label="LCA">LCA</a></li>
                <li>
                    <a href="#%e6%a0%91%e9%93%be%e5%89%96%e5%88%86" aria-label="树链剖分">树链剖分</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e5%ad%a6" aria-label="数学">数学</a><ul>
                        
                <li>
                    <a href="#%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95" aria-label="扩展欧几里得算法">扩展欧几里得算法</a></li>
                <li>
                    <a href="#%e9%80%86%e5%85%83" aria-label="逆元">逆元</a></li>
                <li>
                    <a href="#%e7%ba%bf%e6%80%a7%e7%ad%9b%e9%80%86%e5%85%83" aria-label="线性筛逆元">线性筛逆元</a></li>
                <li>
                    <a href="#fft" aria-label="FFT">FFT</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%ae%97%e6%b3%95" aria-label="字符串算法">字符串算法</a><ul>
                        
                <li>
                    <a href="#kmp" aria-label="KMP">KMP</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
    
</div>

  <div class="post-content"><blockquote>
<p>@zeroy.site</p>
</blockquote>
<h3 id="读入输出挂">读入输出挂<a hidden class="anchor" aria-hidden="true" href="#读入输出挂">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(){
	<span style="color:#66d9ef">char</span> c<span style="color:#f92672">=</span>getchar();
	<span style="color:#66d9ef">int</span> num<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,fl<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">while</span>(c<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">48</span> <span style="color:#f92672">||</span> c<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">57</span>){<span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;-&#39;</span>)fl<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;c<span style="color:#f92672">=</span>getchar();}
	<span style="color:#66d9ef">while</span>(c<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">48</span> <span style="color:#f92672">&amp;&amp;</span> c<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">57</span>){num<span style="color:#f92672">=</span>(num<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>(num<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">3</span>)<span style="color:#f92672">+</span>(c<span style="color:#f92672">^</span><span style="color:#ae81ff">48</span>);c<span style="color:#f92672">=</span>getchar();}
	<span style="color:#66d9ef">return</span> num<span style="color:#f92672">*</span>fl; 
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">if</span>(x<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>){
		putchar(<span style="color:#e6db74">&#39;-&#39;</span>);
		x<span style="color:#f92672">=-</span>x;
	}
	<span style="color:#66d9ef">if</span>(x<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">9</span>)write(x<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>);
	putchar(x<span style="color:#f92672">%</span><span style="color:#ae81ff">10</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#39;0&#39;</span>);
}
</code></pre></div><h3 id="正向表">正向表<a hidden class="anchor" aria-hidden="true" href="#正向表">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> tot<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,h[M];
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">edge</span>{
    <span style="color:#66d9ef">int</span> nxt;
    <span style="color:#66d9ef">int</span> to,cost;
}G[<span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>M];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span> c){
    G[<span style="color:#f92672">++</span>tot]<span style="color:#f92672">=</span>(edge){h[a],b,c};
    h[a]<span style="color:#f92672">=</span>tot;
}
<span style="color:#75715e">//图论题存图用的
</span><span style="color:#75715e">//遍历：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>h[x];i;i<span style="color:#f92672">=</span>G[i].nxt){
    <span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>G[i].to,v<span style="color:#f92672">=</span>G[i].cost;
    <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="基础数据结构">基础数据结构<a hidden class="anchor" aria-hidden="true" href="#基础数据结构">#</a></h3>
<h4 id="树状数组">树状数组<a hidden class="anchor" aria-hidden="true" href="#树状数组">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> d){
	<span style="color:#66d9ef">while</span>(x<span style="color:#f92672">&lt;=</span>n){
        C[x]<span style="color:#f92672">+=</span>d;
        x<span style="color:#f92672">+=</span>(x<span style="color:#f92672">&amp;-</span>x);
	}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Sum</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">int</span> res<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span>(x){
		res<span style="color:#f92672">+=</span>C[x];
        x<span style="color:#f92672">-=</span>(x<span style="color:#f92672">&amp;-</span>x);
    }
    <span style="color:#66d9ef">return</span> res;
}
<span style="color:#75715e">//在线单点加值，查询前缀和，单次操作复杂度均为O(logn)
</span></code></pre></div><h4 id="st表">ST表<a hidden class="anchor" aria-hidden="true" href="#st表">#</a></h4>
<p><strong>预处理</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Init_RMQ</span>(<span style="color:#66d9ef">int</span> n){
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)f[i][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>A[i];
	lg2[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)lg2[i]<span style="color:#f92672">=</span>lg2[i<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>j)<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>)
		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>j)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
			f[i][j]<span style="color:#f92672">=</span>max(f[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],f[i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>(j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
} 
</code></pre></div><p><strong>查询</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r){
	<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span>lg2[r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
	<span style="color:#66d9ef">return</span> max(f[l][k],f[r<span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>k)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][k]);
}
<span style="color:#75715e">//预处理复杂度为O(nlogn),单次查询复杂度为O(1)
</span></code></pre></div><h4 id="线段树">线段树<a hidden class="anchor" aria-hidden="true" href="#线段树">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Segment_tree</span>{
	<span style="color:#75715e">#define fa tree[p]
</span><span style="color:#75715e"></span>	<span style="color:#75715e">#define lson tree[p&lt;&lt;1]
</span><span style="color:#75715e"></span>	<span style="color:#75715e">#define rson tree[p&lt;&lt;1|1]
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span>{
		<span style="color:#66d9ef">int</span> l,r;
		LL add;<span style="color:#75715e">//懒标记
</span><span style="color:#75715e"></span>        LL sum;
		<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">len</span>(){<span style="color:#66d9ef">return</span> r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;}
	}tree[M<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">2</span>];
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">int</span> p){
		fa.sum<span style="color:#f92672">=</span>lson.sum<span style="color:#f92672">+</span>rson.sum;	
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down</span>(<span style="color:#66d9ef">int</span> p){
		<span style="color:#66d9ef">if</span>(fa.add<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#66d9ef">return</span>;
		lson.add<span style="color:#f92672">+=</span>fa.add;
		lson.sum<span style="color:#f92672">+=</span>fa.add<span style="color:#f92672">*</span>lson.len();
		rson.add<span style="color:#f92672">+=</span>fa.add;
		rson.sum<span style="color:#f92672">+=</span>fa.add<span style="color:#f92672">*</span>rson.len();
		fa.add<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,<span style="color:#66d9ef">int</span> p){
		fa.l<span style="color:#f92672">=</span>l;fa.r<span style="color:#f92672">=</span>r;fa.sum<span style="color:#f92672">=</span>fa.add<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">if</span>(l<span style="color:#f92672">==</span>r){fa.sum<span style="color:#f92672">=</span>A[l];<span style="color:#66d9ef">return</span>;}
		<span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=</span>(l<span style="color:#f92672">+</span>r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
		build(l,mid,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>);
		build(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,r,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>);
		up(p);
	}
	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,LL d,<span style="color:#66d9ef">int</span> p){
		<span style="color:#66d9ef">if</span>(fa.l<span style="color:#f92672">==</span>l<span style="color:#f92672">&amp;&amp;</span>fa.r<span style="color:#f92672">==</span>r){
			fa.sum<span style="color:#f92672">+=</span><span style="color:#ae81ff">1LL</span><span style="color:#f92672">*</span>fa.len()<span style="color:#f92672">*</span>d;
			fa.add<span style="color:#f92672">+=</span>d;
			<span style="color:#66d9ef">return</span>;
		}
		<span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=</span>(fa.l<span style="color:#f92672">+</span>fa.r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
		down(p);
		<span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&lt;=</span>mid)update(l,r,d,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>);
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&gt;</span>mid)update(l,r,d,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>);
		<span style="color:#66d9ef">else</span> {
			update(l,mid,d,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>);
			update(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,r,d,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>);	
		}
		up(p);
	}
	LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,<span style="color:#66d9ef">int</span> p){
		<span style="color:#66d9ef">if</span>(fa.l<span style="color:#f92672">==</span>l<span style="color:#f92672">&amp;&amp;</span>fa.r<span style="color:#f92672">==</span>r)<span style="color:#66d9ef">return</span> fa.sum;
		down(p);
		<span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=</span>(fa.l<span style="color:#f92672">+</span>fa.r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&lt;=</span>mid)<span style="color:#66d9ef">return</span> query(l,r,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>);
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&gt;</span>mid)<span style="color:#66d9ef">return</span> query(l,r,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>);
		<span style="color:#66d9ef">return</span> query(l,mid,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>query(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,r,p<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">|</span><span style="color:#ae81ff">1</span>);
	}
}T;
<span style="color:#75715e">//区间加减，区间查询和，单次操作复杂度均为O(logn)
</span><span style="color:#75715e">//可实现的变种：区间乘积，区间染色问题等等。
</span></code></pre></div><h4 id="并查集">并查集<a hidden class="anchor" aria-hidden="true" href="#并查集">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getfa</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">return</span> fa[x]<span style="color:#f92672">==</span>x<span style="color:#f92672">?</span>x:fa[x]<span style="color:#f92672">=</span>getfa(fa[x]);
}
<span style="color:#75715e">//初始状态下所有fa[x]=x
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Union</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y){<span style="color:#75715e">//两个集合合并
</span><span style="color:#75715e"></span>    fa[getfa(x)]<span style="color:#f92672">=</span>getfa(y);
}
</code></pre></div><h3 id="树上算法">树上算法<a hidden class="anchor" aria-hidden="true" href="#树上算法">#</a></h3>
<h4 id="lca">LCA<a hidden class="anchor" aria-hidden="true" href="#lca">#</a></h4>
<p><strong>跳重链</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> f,<span style="color:#66d9ef">int</span> d){
	dep[x]<span style="color:#f92672">=</span>d;
	sz[x]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
	fa[x]<span style="color:#f92672">=</span>f;son[x]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; 
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>G[x].size();i<span style="color:#f92672">++</span>){
		<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>G[x][i];
		<span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>f)<span style="color:#66d9ef">continue</span>;
		dfs(u,x,d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
		<span style="color:#66d9ef">if</span>(sz[u]<span style="color:#f92672">&gt;</span>sz[son[x]])son[x]<span style="color:#f92672">=</span>u;
		sz[x]<span style="color:#f92672">+=</span>sz[u];
	}
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_top</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> tp){
	top[x]<span style="color:#f92672">=</span>tp;
	<span style="color:#66d9ef">if</span>(son[x])dfs_top(son[x],tp);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>G[x].size();i<span style="color:#f92672">++</span>){
		<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>G[x][i];
		<span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>fa[x]<span style="color:#f92672">||</span>u<span style="color:#f92672">==</span>son[x])<span style="color:#66d9ef">continue</span>;
		dfs_top(u,u);
	}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LCA</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
	<span style="color:#66d9ef">while</span>(top[a]<span style="color:#f92672">!=</span>top[b]){
		<span style="color:#66d9ef">if</span>(dep[top[a]]<span style="color:#f92672">&gt;</span>dep[top[b]])a<span style="color:#f92672">=</span>fa[top[a]];
		<span style="color:#66d9ef">else</span> b<span style="color:#f92672">=</span>fa[top[b]];
	}
	<span style="color:#66d9ef">return</span> dep[a]<span style="color:#f92672">&gt;</span>dep[b]<span style="color:#f92672">?</span>b:a;
}
</code></pre></div><p><strong>倍增</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> f,<span style="color:#66d9ef">int</span> d){
	dep[x]<span style="color:#f92672">=</span>d;
	fa[x][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>f;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>G[x].size();i<span style="color:#f92672">++</span>){
		<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>G[x][i];
		<span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>f)<span style="color:#66d9ef">continue</span>;
		dfs(u,x,d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
	}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">LCA</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
	<span style="color:#66d9ef">if</span>(dep[a]<span style="color:#f92672">&gt;</span>dep[b])swap(a,b);
	<span style="color:#66d9ef">int</span> step<span style="color:#f92672">=</span>dep[b]<span style="color:#f92672">-</span>dep[a];
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">19</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)
		<span style="color:#66d9ef">if</span>(step<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>i)b<span style="color:#f92672">=</span>fa[b][i];
	<span style="color:#66d9ef">if</span>(a<span style="color:#f92672">==</span>b)<span style="color:#66d9ef">return</span> a;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">19</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)
		<span style="color:#66d9ef">if</span>(fa[a][i]<span style="color:#f92672">!=</span>fa[b][i])a<span style="color:#f92672">=</span>fa[a][i],b<span style="color:#f92672">=</span>fa[b][i];
	<span style="color:#66d9ef">return</span> fa[a][<span style="color:#ae81ff">0</span>];
} 
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">19</span>;j<span style="color:#f92672">++</span>)
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
		fa[i][j]<span style="color:#f92672">=</span>fa[fa[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</code></pre></div><h4 id="树链剖分">树链剖分<a hidden class="anchor" aria-hidden="true" href="#树链剖分">#</a></h4>
<p><strong>寻找重儿子</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> f,<span style="color:#66d9ef">int</span> d){
	dep[x]<span style="color:#f92672">=</span>d;fa[x]<span style="color:#f92672">=</span>f;sz[x]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;son[x]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>h[x];i;i<span style="color:#f92672">=</span>G[i].nxt){
		<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>G[i].to;
		<span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>f)<span style="color:#66d9ef">continue</span>;
		dfs(u,x,d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>); 
		<span style="color:#66d9ef">if</span>(sz[u]<span style="color:#f92672">&gt;</span>sz[son[x]])son[x]<span style="color:#f92672">=</span>u;
		sz[x]<span style="color:#f92672">+=</span>sz[u];
	}
}
</code></pre></div><p><strong>处理top</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_top</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> tp){
	top[x]<span style="color:#f92672">=</span>tp;ID[x]<span style="color:#f92672">=++</span>tt;ln[tt]<span style="color:#f92672">=</span>x;
	<span style="color:#66d9ef">if</span>(son[x])dfs_top(son[x],tp);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>h[x];i;i<span style="color:#f92672">=</span>G[i].nxt){
		<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>G[i].to;
		<span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>son[x]<span style="color:#f92672">||</span>u<span style="color:#f92672">==</span>fa[x])<span style="color:#66d9ef">continue</span>;
		dfs_top(u,u);
	}
}
</code></pre></div><p><strong>query</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">while</span>(top[u]<span style="color:#f92672">!=</span>top[v]){
	<span style="color:#66d9ef">if</span>(dep[top[u]]<span style="color:#f92672">&gt;</span>dep[top[v]]){
		query(ID[top[u]],ID[u],<span style="color:#ae81ff">1</span>);
		u<span style="color:#f92672">=</span>fa[top[u]];
	}
	<span style="color:#66d9ef">else</span> {
		query(ID[top[v]],ID[v],<span style="color:#ae81ff">1</span>);
		v<span style="color:#f92672">=</span>fa[top[v]];
	}
} 
<span style="color:#66d9ef">if</span>(dep[u]<span style="color:#f92672">&gt;</span>dep[v])query(ID[v],ID[u],<span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">query</span>(ID[u],ID[v],<span style="color:#ae81ff">1</span>);
</code></pre></div><h3 id="数学">数学<a hidden class="anchor" aria-hidden="true" href="#数学">#</a></h3>
<h4 id="扩展欧几里得算法">扩展欧几里得算法<a hidden class="anchor" aria-hidden="true" href="#扩展欧几里得算法">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exgcd</span>(ll a,ll b,ll <span style="color:#f92672">&amp;</span>d,ll <span style="color:#f92672">&amp;</span>x,ll <span style="color:#f92672">&amp;</span>y){
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>b){d<span style="color:#f92672">=</span>a;x<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;y<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#66d9ef">return</span>;}
    exgcd(b,a<span style="color:#f92672">%</span>b,d,y,x);y<span style="color:#f92672">-=</span>a<span style="color:#f92672">/</span>b<span style="color:#f92672">*</span>x;
} 
</code></pre></div><h4 id="逆元">逆元<a hidden class="anchor" aria-hidden="true" href="#逆元">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">inv</span>(<span style="color:#66d9ef">int</span> a){
    ll x,y,d;
    exgcd(a,m,d,x,y);
    <span style="color:#66d9ef">return</span> (x<span style="color:#f92672">%</span>MOD<span style="color:#f92672">+</span>MOD)<span style="color:#f92672">%</span>MOD;
}
<span style="color:#75715e">//当a与mod互质时也可使用费马小定理，qkpow(a,mod-2)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qkpow</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
	<span style="color:#66d9ef">int</span> res<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span>(b){
		<span style="color:#66d9ef">if</span>(b<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>)res<span style="color:#f92672">=</span>res<span style="color:#f92672">*</span>a<span style="color:#f92672">%</span>mod;
        a<span style="color:#f92672">=</span>a<span style="color:#f92672">*</span>a<span style="color:#f92672">%</span>mod;
        b<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}
<span style="color:#75715e">//注意不要爆int或者long long
</span></code></pre></div><h4 id="线性筛逆元">线性筛逆元<a hidden class="anchor" aria-hidden="true" href="#线性筛逆元">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Init</span>(){
	fac[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;rev[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
		fac[i]<span style="color:#f92672">=</span>(fac[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>i)<span style="color:#f92672">%</span>MOD;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//线性筛逆元 
</span><span style="color:#75715e"></span>		rev[i]<span style="color:#f92672">=</span>(MOD<span style="color:#f92672">-</span>MOD<span style="color:#f92672">/</span>i)<span style="color:#f92672">*</span>rev[MOD<span style="color:#f92672">%</span>i]<span style="color:#f92672">%</span>MOD;
}
</code></pre></div><h4 id="fft">FFT<a hidden class="anchor" aria-hidden="true" href="#fft">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Complex</span>{
	<span style="color:#66d9ef">double</span> x,y;
	Complex(){}
	Complex(<span style="color:#66d9ef">double</span> _x,<span style="color:#66d9ef">double</span> _y)<span style="color:#f92672">:</span>x(_x),y(_y){}
	Complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>res) <span style="color:#66d9ef">const</span>{
		<span style="color:#66d9ef">return</span> (Complex){x<span style="color:#f92672">+</span>res.x,y<span style="color:#f92672">+</span>res.y};	
	}
	Complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">-</span> (<span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>res) <span style="color:#66d9ef">const</span>{
		<span style="color:#66d9ef">return</span> (Complex){x<span style="color:#f92672">-</span>res.x,y<span style="color:#f92672">-</span>res.y};	
	}
	Complex <span style="color:#66d9ef">operator</span> <span style="color:#f92672">*</span> (<span style="color:#66d9ef">const</span> Complex <span style="color:#f92672">&amp;</span>res) <span style="color:#66d9ef">const</span>{
		<span style="color:#66d9ef">return</span> (Complex){x<span style="color:#f92672">*</span>res.x<span style="color:#f92672">-</span>y<span style="color:#f92672">*</span>res.y,x<span style="color:#f92672">*</span>res.y<span style="color:#f92672">+</span>y<span style="color:#f92672">*</span>res.x};	
	}
};
Complex A[M],B[M];
<span style="color:#66d9ef">double</span> pi<span style="color:#f92672">=</span>acos(<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">FFT</span>(Complex <span style="color:#f92672">*</span>y,<span style="color:#66d9ef">int</span> n,<span style="color:#66d9ef">int</span> f){
	<span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>)<span style="color:#66d9ef">return</span>;
	Complex L[n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>],R[n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>];
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">+=</span><span style="color:#ae81ff">2</span>)L[i<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>y[i],R[i<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>y[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
	FFT(L,n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>,f);FFT(R,n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>,f);
	Complex wn(cos(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>pi<span style="color:#f92672">/</span>n),f<span style="color:#f92672">*</span>sin(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>pi<span style="color:#f92672">/</span>n)),w(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>(n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);i<span style="color:#f92672">++</span>,w<span style="color:#f92672">=</span>w<span style="color:#f92672">*</span>wn){
		y[i]<span style="color:#f92672">=</span>L[i]<span style="color:#f92672">+</span>w<span style="color:#f92672">*</span>R[i];
		y[i<span style="color:#f92672">+</span>(n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>)]<span style="color:#f92672">=</span>L[i]<span style="color:#f92672">-</span>w<span style="color:#f92672">*</span>R[i];
	}
}
<span style="color:#66d9ef">double</span> q[M],b[M],C[M];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> nn<span style="color:#f92672">=</span>n,mm<span style="color:#f92672">=</span>n;
	mm<span style="color:#f92672">+=</span>nn;
	<span style="color:#66d9ef">for</span>(nn<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;nn<span style="color:#f92672">&lt;=</span>mm;nn<span style="color:#f92672">&lt;&lt;=</span><span style="color:#ae81ff">1</span>);
	FFT(A,nn,<span style="color:#ae81ff">1</span>);FFT(B,nn,<span style="color:#ae81ff">1</span>);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>nn;i<span style="color:#f92672">++</span>)A[i]<span style="color:#f92672">=</span>A[i]<span style="color:#f92672">*</span>B[i];
	FFT(A,nn,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="字符串算法">字符串算法<a hidden class="anchor" aria-hidden="true" href="#字符串算法">#</a></h3>
<h4 id="kmp">KMP<a hidden class="anchor" aria-hidden="true" href="#kmp">#</a></h4>
<p>给出两个字符串S1和S2，若S1的区间[l,r]与S2完全相同，则称S2在S1中出现了，其出现位置为l。</p>
<p>现在请你求出S2在S1中所有出现的位置。</p>
<p>定义一个字符串S的border为S的一个非S本身的子串t，满足t既是S的前缀，又是S的后缀。</p>
<p>对于S2，你还需要求出对于每个前缀S&rsquo;的最长border t‘的长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define M 1000005
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">char</span> s1[M],s2[M];
<span style="color:#66d9ef">int</span> f[M];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getf</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s,<span style="color:#66d9ef">int</span> l){
	f[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>f[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>l;i<span style="color:#f92672">++</span>){
		<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>f[i];
		<span style="color:#66d9ef">while</span>(j<span style="color:#f92672">&amp;&amp;</span>s[i]<span style="color:#f92672">!=</span>s[j])j<span style="color:#f92672">=</span>f[j];
		<span style="color:#66d9ef">if</span>(s[i]<span style="color:#f92672">==</span>s[j])j<span style="color:#f92672">++</span>;
		f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>j;
	}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	scanf(<span style="color:#e6db74">&#34;%s%s&#34;</span>,s1,s2);
	<span style="color:#66d9ef">int</span> l1<span style="color:#f92672">=</span>strlen(s1);
	<span style="color:#66d9ef">int</span> l2<span style="color:#f92672">=</span>strlen(s2);
	getf(s2,l2);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>l1;i<span style="color:#f92672">++</span>){
		<span style="color:#66d9ef">while</span>(j<span style="color:#f92672">&amp;&amp;</span>s2[j]<span style="color:#f92672">!=</span>s1[i])j<span style="color:#f92672">=</span>f[j];
		<span style="color:#66d9ef">if</span>(s2[j]<span style="color:#f92672">==</span>s1[i])j<span style="color:#f92672">++</span>;
		<span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span>l2)
			printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i<span style="color:#f92672">-</span>l2<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>);
	}
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>l2;i<span style="color:#f92672">++</span>)
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>,f[i]);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>

  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://zeroy.site/articles/GraphCompiler/">
    <span class="title">« </span>
    <br>
    <span>编译原理大作业报告</span>
  </a>
  <a class="next" href="https://zeroy.site/articles/reverse-exercise-area/">
    <span class="title"> »</span>
    <br>
    <span>攻防世界reverse练习区WP</span>
  </a>
  
</nav>

  </footer><script src="https://utteranc.es/client.js"
        repo="zeroy0410/zeroy0410.github.io"
        issue-term="pathname"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://zeroy.site/">zeroy&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></body>

</html>
